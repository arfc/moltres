<!DOCTYPE html><head><meta charset="UTF-8"><title>KernelScalarBase | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="3d71304f-4f7c-440e-a195-5e88d3ab2b95" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f62adc92-9e70-4895-a6db-f3aee851c2f0" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="79d9dfe4-f147-4b04-9b10-d53ade49a278" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="0fc1a6ea-d1de-487a-9e54-eef6c2081175"><i class="material-icons">menu</i></a><ul class="sidenav" id="0fc1a6ea-d1de-487a-9e54-eef6c2081175"><li><a href="#!" class="dropdown-trigger" data-target="feaf3a3e-21ef-4477-9133-23887883e7b7" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="14ab6c37-b24b-4f59-a753-6e0c91945cd5" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1a4c2b01-cb29-41c6-b8f9-245e0a1c6380" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="3d71304f-4f7c-440e-a195-5e88d3ab2b95"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="f62adc92-9e70-4895-a6db-f3aee851c2f0"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="79d9dfe4-f147-4b04-9b10-d53ade49a278"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="feaf3a3e-21ef-4477-9133-23887883e7b7"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="14ab6c37-b24b-4f59-a753-6e0c91945cd5"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="1a4c2b01-cb29-41c6-b8f9-245e0a1c6380"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">kernels</span><a href="#" class="breadcrumb">KernelScalarBase</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="c9f83f15-ef1e-4e2d-9bc9-46cf8bb3d816" data-section-level="1" data-section-text="KernelScalarBase"><h1 id="kernelscalarbase">KernelScalarBase</h1><p>The <code>KernelScalarBase</code> is part of the scalar augmentation system to complement the <a href="../../syntax/ScalarKernels/index.html">ScalarKernel</a> class. Its principal purpose is to add standard quadrature loops and assembly routines to handle the contributions from a single added scalar variable to a <a href="../../syntax/Kernels/index.html">Kernel</a> class, including the entire row of the Jacobian. These routines will assist with representing weak form terms in a partial differential equation involving scalar variables integrated over the interior of a domain. As usual, this piece of physics is referred to as the &quot;residual&quot; and is evaluated at integration quadrature points within that domain. To implement your own physics in MOOSE, you create your own kernel by subclassing the MOOSE <code>KernelScalarBase</code> class.</p><p>The Kernel scalar augmentation system supports the use of <span>automatic differentiation (AD)</span> for residual calculations, as such there are two options for creating field-scalar coupling objects: <code>KernelScalarBase</code> and <code>ADKernelScalarBase</code>. To further understand automatic differentiation, please refer to the <a href="../../automatic_differentiation/index.html">Automatic Differentiation</a> page for more information.</p><p>Developers should read all sections; users can find <a href="KernelScalarBase.html#KSB-parameters">Parameters</a> described at the bottom.</p><section class="scrollspy" id="b1224530-c2dd-455e-b731-979ed178c1de" data-section-level="2" data-section-text="Creation of Kernel Scalar Coupling Classes"><h2 id="KSB-coupling">Creation of Kernel Scalar Coupling Classes</h2><p>Each <code>Kernel</code> object has a <strong>focus</strong> field variable or spatial variable; its job is to contribute to the residual as well as the row of the Jacobian matrix. Herein, as in the source code of <code>Kernels</code>, this spatial variable will be called <code>_var</code>. In a coupled (multi-phyics) weak form, all domain integral terms containing the test function of <code>_var</code> are potential candidates for <code>Kernel</code> contributions.</p><p>The philosphy of the scalar augmentation class <code>KernelScalarBase</code> is to add a focus scalar variable referred to as <code>_kappa</code> to the <code>Kernel</code> object so that all terms in the coupled weak form that involve <code>_var</code>, <code>_kappa</code>, and/or their test functions can be assembled in one or multiple class instances. This philosophy is similar to how the lower dimensional variable <code>_lambda</code> is added to the element faces of <code>DGKernel</code> and <code>IntegratedBC</code> objects associated with the hybrid finite element method (HFEM). Documentation for that approach can be found <a href="../dgkernels/HFEMDiffusion.html">HFEMDiffusion</a> and <a href="../bcs/HFEMDirichletBC.html">HFEMDirichletBC</a> along with the base classes <code>DGLowerDKernel</code> and <code>LowerDIntegratedBC</code>.</p><p>In a <code>KernelScalarBase</code> subclass, a naming scheme is established for the quadrature point methods of the two variable types: methods contributing to the test function of <code>_kappa</code> have &quot;Scalar&quot; near the front and methods contributing to the trial function of scalar variables in the Jacobian have &quot;Scalar&quot; at the end. The <code>computeScalarQpResidual()</code> function <strong>should</strong> be overridden (see <a href="KernelScalarBase.html#KSB-parameters">Parameters</a> for cases where the scalar should be suppressed). The <code>computeQpResidual()</code> function <strong>must</strong> be overridden as usual for <code>Kernels</code>, although it may return zero.</p><p>For non-AD objects, several contributions to the Jacobian matrix can be optionally overridden for use in Newton-type nonlinear solvers. As mentioned later, the developer should choose and document which terms (rows) of the residual and terms (rows and columns) of the Jacobian will be attributed to an instance of the developed class. These choices can be motivated by whether some terms in the weak form can be or have already been implemented within other MOOSE classes.</p><ul class="browser-default"><li><p><code>computeQpJacobian()</code>: Jacobian component d-<code>_var</code>-residual / d-<code>_var</code> </p></li><li><p><code>computeQpOffDiagJacobian(jvar_num)</code>: off-diagonal Jacobian component d-<code>_var</code>-residual / d-<code>jvar</code> </p></li><li><p><code>computeQpOffDiagJacobianScalar(svar_num)</code>: off-diagonal Jacobian component d-<code>_var</code>-residual / d-<code>svar</code> </p></li><li><p><code>computeScalarQpJacobian()</code>: Jacobian component d-<code>_kappa</code>-residual / d-<code>_kappa</code> </p></li><li><p><code>computeScalarQpOffDiagJacobian(jvar_num)</code>: off-diagonal Jacobian component d-<code>_kappa</code>-residual / d-<code>jvar</code> </p></li><li><p><code>computeScalarQpOffDiagJacobianScalar(svar_num)</code>: off-diagonal Jacobian component d-<code>_kappa</code>-residual / d-<code>svar</code></p></li></ul><p>Examples of some of these methods are shown below in <a href="KernelScalarBase.html#KSB-examples">Examples from Source Code</a>. Loops over the coupled variables wrap around these quadrature loops. The integer for the spatial variable is <code>jvar_num</code> and the integer for the scalar variable is <code>svar_num</code>. </p><p>Also, there are some pre-calculation routines that are called within the quadrature loop once before the loop over spatial variable test and shape functions as well as  before the loop over scalar components. These methods are useful for material or stabilization calculations.</p><ul class="browser-default"><li><p><code>initScalarQpResidual()</code>: evaluations depending on qp but independent of test functions </p></li><li><p><code>initScalarQpJacobian(jvar_num)</code>: evaluations depending on qp but independent of test and shape functions </p></li><li><p><code>initScalarQpOffDiagJacobian(jsvar)</code>: evaluations depending on qp but independent of test and shape functions</p></li></ul><p>In addition to those mentioned in the <a href="../../syntax/Kernels/index.html">Kernel</a> documentation, you have access to several member variables inside your <code>KernelScalarBase</code> class for computing the residual and Jacobian values in the above mentioned functions:</p><ul class="browser-default"><li><p><code>_h</code>, <code>_l</code>: indices for the current test and trial scalar component respectively. </p></li><li><p><code>_kappa</code>: value of the scalar variable this Kernel operates on; indexed by <code>_h</code> (i.e. <code>_kappa[_h]</code>). </p></li><li><p><code>_kappa_var</code>: ID number of this scalar variable; useful to differentiate from others. </p></li><li><p><code>_k_order</code>: order (number of components) of the scalar variable.</p></li></ul><p>Since the test and trial &quot;shape&quot; functions of a scalar are &quot;1&quot;, variables are not required for that value. Examples of the source codes below demonstrate this fact.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning:</span>AD global indexing required</div><div class="card-content"><div class="moose-alert-content"><p><code>ADKernelScalarBase</code> only works with MOOSE configured with global AD indexing (the default).</p></div></div></div><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Parallelization of scalar contributions</div><div class="card-content"><div class="moose-alert-content"><p>While these quadrature loops are convenient for implementation in a single object, the speed of  parallel execution may be slower due to the sequential assembly needed from each element assemblying to the same scalar variable <code>_kappa</code>. For greater speed, the developer may instead implement the terms for <code>computeScalarQpResidual()</code> and <code>computeScalarQpJacobian()</code> through a derived class of <code>ElementIntegralUserObject</code> as discussed at <a href="../../syntax/ScalarKernels/index.html#couple-spatial">Coupling with Spatial Variables</a>.</p></div></div></div></section><section class="scrollspy" id="23f66e09-3699-49be-a0c0-54ff98109fca" data-section-level="2" data-section-text="Examples from Source Code"><h2 id="KSB-examples">Examples from Source Code</h2><p>As mentioned, the <code>computeScalarQpResidual</code> method <strong>should</strong> be overridden for both flavors of kernels, non-AD and AD. As an example, consider the scalar residual weak form term of the  <a href="ScalarLMKernel.html"><code>ScalarLMKernel</code></a> class:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-3e8bc76b-32db-47e9-8057-87aedf61344a"></span><span class="moose-katex-equation-number">(1)</span><script>var element = document.getElementById("moose-equation-3e8bc76b-32db-47e9-8057-87aedf61344a");katex.render("  F^{(\\lambda)} \\equiv \\int_{\\Omega} \\phi^h \\;\\text{d}\\Omega - V_0 = 0 ", element, {displayMode:true,throwOnError:false});</script></span></p><p>The <a href="ScalarLMKernel.html"><code>ScalarLMKernel</code></a> class is implemented using the <a href="GenericKernelScalar.html"><code>GenericKernelScalar</code></a> template class to contain both the AD and non-AD versions within the same source files; the test sources files in the Tensor Mechanics module described at the bottom of this section appear more simply since they are non-AD only: <a href="#HTLSDR-header">Listing 5</a>. The <code>computeScalarQpResidual</code> method for this class is provided in <a href="#scalar-kernel-non-ad-residual">Listing 1</a>, where <code>_value/_pp_value</code> is equal to <span class="moose-katex-inline-equation" id="moose-equation-e83da677-1943-430d-bd25-9f3f7aabeb56"><script>var element = document.getElementById("moose-equation-e83da677-1943-430d-bd25-9f3f7aabeb56");katex.render("V_0", element, {displayMode:false,throwOnError:false});</script></span>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 1: </span><span class="moose-caption-text" id="scalar-kernel-non-ad-residual">The C++ weak-form residual statement of <a href="#moose-equation-3e8bc76b-32db-47e9-8057-87aedf61344a">Eq. (1)</a>.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ddaf6701-669a-477c-8db4-de6c41bce08e">(moose/framework/src/kernels/ScalarLMKernel.C)</a></div></div><p>Meanwhile, the contribution to the spatial variable residual of this object is associated with <a href="#moose-equation-783aa9de-51e7-46c1-b89d-e3b3c4514f9e">Eq. (2)</a> and implemented in <a href="#kernel-non-ad-residual">Listing 2</a> (note that the scalar variable <code>_kappa</code> is termed as  <span class="moose-katex-inline-equation" id="moose-equation-5eb08868-f5ce-432f-a646-641f1d5ad36b"><script>var element = document.getElementById("moose-equation-5eb08868-f5ce-432f-a646-641f1d5ad36b");katex.render("\\lambda^h", element, {displayMode:false,throwOnError:false});</script></span> in this weak form).</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-783aa9de-51e7-46c1-b89d-e3b3c4514f9e"></span><span class="moose-katex-equation-number">(2)</span><script>var element = document.getElementById("moose-equation-783aa9de-51e7-46c1-b89d-e3b3c4514f9e");katex.render("  F^{(\\phi)}_i \\equiv \\lambda^h \\int_{\\Omega} \\varphi_i \\;\\text{d}\\Omega ", element, {displayMode:true,throwOnError:false});</script></span></p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 2: </span><span class="moose-caption-text" id="kernel-non-ad-residual">The C++ weak-form residual statement of <a href="#moose-equation-783aa9de-51e7-46c1-b89d-e3b3c4514f9e">Eq. (2)</a>.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#de751f4d-57ad-43b3-bd9d-71c64a69ba9e">(moose/framework/src/kernels/ScalarLMKernel.C)</a></div></div><p>This object also overrides the <code>computeScalarQpOffDiagJacobian</code> method to define the Jacobian term related to <a href="#moose-equation-3e8bc76b-32db-47e9-8057-87aedf61344a">Eq. (1)</a> as shown in <a href="#non-ad-s-v-jacobian">Listing 3</a>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 3: </span><span class="moose-caption-text" id="non-ad-s-v-jacobian">The C++ weak-form Jacobian for d-<code>_kappa</code>-residual / d-<code>jvar</code>.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#645fbbca-d6e5-44c7-a7f3-71b7aee2a889">(moose/framework/src/kernels/ScalarLMKernel.C)</a></div></div><p>Notice that there is a conditional to confirm that the coupled <code>jvar</code> is the focus variable <code>_var</code>, otherwise it returns zero. Also, this method only returns a &quot;Real&quot; value since this method is only called by the non-AD version of the class during Jacobian computation; an assert is used to verify this intention.</p><p>Similarly, it also overrides the <code>computeQpOffDiagJacobianScalar</code> method to define the Jacobian term related to <a href="#moose-equation-783aa9de-51e7-46c1-b89d-e3b3c4514f9e">Eq. (2)</a> as shown in <a href="#non-ad-v-s-jacobian">Listing 4</a>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 4: </span><span class="moose-caption-text" id="non-ad-v-s-jacobian">The C++ weak-form Jacobian for d-<code>_var</code>-residual / d-<code>svar</code>.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#8dbcff91-0d6c-45bb-ae49-445cea5b09f7">(moose/framework/src/kernels/ScalarLMKernel.C)</a></div></div><p>Also notice the conditional that confirms the coupled <code>svar</code> is the focus scalar <code>_kappa</code>, otherwise it returns zero.</p><p>Depending upon the weak form and its coupling terms between spatial and scalar variables, not all of the methods listed in <a href="KernelScalarBase.html#KSB-coupling">Creation of Kernel Scalar Coupling Classes</a> need to be overridden.</p><p>The AD version of this object, <a href="ADScalarLMKernel.html"><code>ADScalarLMKernel</code></a>, only requires the residual implementation. A solely AD source file would only need to override <code>computeScalarQpResidual</code> and <code>computeQpResidual</code> and leave all the Jacobian methods as base definitions, which return zero. See  <a href="../constraints/MortarScalarBase.html">MortarScalarBase</a> for examples of AD-only and non-AD separate classes.</p><p>As a more complicated example of the scalar augmentation system for kernels, the Tensor Mechanics test app contains headers, source, and test files for an alternative implementation of the &quot;HomogenizedTotalLagrangianStressDivergence&quot; system from the Tensor Mechanics module. This Kernel is designated with the suffix &quot;S&quot; to distinguish from the existing objects in the module. Also, there are other intermediate classes such as &quot;TotalLagrangianStressDivergence&quot; that are also designated with an &quot;S&quot; suffix. These other classes are needed since the lower class needs to also derive from <code>KernelScalarBase</code>. Meanwhile, they do not need the <code>scalar_variable</code> parameter and function identically to their original module source object; see the <a href="KernelScalarBase.html#KSB-parameters">Parameters</a> section for a comment about leaving this parameter blank.</p><p>The scalar augmentation system is designed such that multiple scalar variables can be coupled to an instance of the Kernel class, each focusing on one scalar from the list. This approach is similar to how Tensor Mechanics module classes operator on one component variable of the displacement vector field and are coupled to the other components. The developer can decide how to organize the coupling and off-diagonal Jacobian terms in a logical way and document this for the user.</p><p>Examples of two schemes for decomposing the coupling terms and having multiple scalar variables are contained in the source files of the Tensor Mechanics module test directory as well as input files <code>2drow.i</code> and <code>2dsole.i</code>, with listings below. The comments within these header and source files serve as documentation and should be consulted to visualize how the rows and columns of the relevant residual and Jacobian contributions are handled. The suffix &quot;R&quot; refers to assembling the entire row of the Jacobian in one object, and the suffix &quot;A&quot; refers to assembling symmetric pairs of the residual and Jacobian; see the header file for clarification.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 5: </span><span class="moose-caption-text" id="HTLSDR-header">Organization of spatial and scalar variable contributions by row.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">/// Total Lagrangian formulation with most homogenization terms (one disp_xyz field and one scalar)
/// The macro_gradient variable is split into two scalars: the first component called &#x27;_hvar&#x27;
/// herein and all other components called &#x27;_avar&#x27; herein. For parameter _beta = 0, the primary
/// scalar (_kappa) is _hvar and the coupled scalar is _avar. For parameter _beta = 1, the primary
/// scalar (_kappa) is _avar and the coupled scalar is _hvar. Just like the primary field variable
/// (_var) is either disp_x or disp_y or disp_z depending on _alpha.
///
/// Thus, each instance of HomogenizedTotalLagrangianStressDivergenceR acts on one field variable
/// (_disp_alpha) and one scalar variable (_hvar_beta). The job of the kernel is to assemble the
/// residual of all dofs of _disp_alpha and of all dofs of _hvar_beta (namely, selected rows).
/// Also, it assembles the ENTIRE row for _disp_alpha and _hvar_beta (namely the columns
/// from all dofs of all _disp field variables and all dofs of all scalar variables _hvar and
/// _avar). The rows for the other field/scalar variables are handled by other instances of the
/// kernel, according to the flags compute_scalar_residuals and compute_field_residuals.
/// When compute_field_residuals is given, only component=_alpha matters and beta = {0,1}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b61460d3-80d1-47aa-8224-275249b72457">(moose/modules/tensor_mechanics/test/include/kernels/HomogenizedTotalLagrangianStressDivergenceR.h)</a></div></div><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Kernels]
  [sdx]
    type = HomogenizedTotalLagrangianStressDivergenceR
    variable = disp_x
    component = 0
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    compute_field_residuals = true
    compute_scalar_residuals = false
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sdy]
    type = HomogenizedTotalLagrangianStressDivergenceR
    variable = disp_y
    component = 1
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    compute_field_residuals = true
    compute_scalar_residuals = false
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sd0]
    type = HomogenizedTotalLagrangianStressDivergenceR
    variable = disp_x
    component = 0
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    compute_field_residuals = false
    compute_scalar_residuals = true
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sd1]
    type = HomogenizedTotalLagrangianStressDivergenceR
    variable = disp_y
    component = 1
    macro_var = hvarA
    macro_other = hvar
    prime_scalar = 1
    compute_field_residuals = false
    compute_scalar_residuals = true
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ec20e356-af93-4ad6-a6a5-8d9cb17c958d">(moose/modules/tensor_mechanics/test/tests/lagrangian/cartesian/total/homogenization/scalar_kernel/2drow.i)</a><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 6: </span><span class="moose-caption-text" id="HTLSDA-header">Organization of spatial and scalar variable contributions by symmetric pairs.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">/// Total Lagrangian formulation with most homogenization terms (one disp_xyz field and one scalar)
/// The macro_gradient variable is split into two scalars: the first component called &#x27;_hvar&#x27;
/// herein and all other components called &#x27;_avar&#x27; herein. For parameter _beta = 0, the primary
/// scalar (_kappa) is _hvar and the coupled scalar is _avar. For parameter _beta = 1, the primary
/// scalar (_kappa) is _avar and the coupled scalar is _hvar. Just like the primary field variable
/// (_var) is either disp_x or disp_y or disp_z depending on _alpha.
///
/// Thus, each instance of HomogenizedTotalLagrangianStressDivergenceA acts on one field variable
/// (_disp_alpha) and one scalar variable (_hvar_beta). The job of the kernel is to assemble the
/// residual of all dofs of _disp_alpha and of all dofs of _hvar_beta (namely, selected entries).
/// It assembles a symmetric portion of the Jacobian for _disp_alpha and _hvar_beta, with some
/// logical checks to access only the particular desired terms (often for _alpha or _beta = 0).
/// The entries for the other field/scalar variables are handled by other instances of the
/// kernel, which have other values of _alpha AND _beta. The logical checks ensure the proper
/// decomposition of the jobs.
///
/// In summary, for x=disp_x etc. and h=_hvar and a=_avar, then the contributions of the instances are
/// _alpha=0, _beta=0
/// R = [Rx,  00,  00,  Rh,  00 ]^T
/// J = [Jxx, Jxy, Jxz, Jxh, 000
///      Jhx, 000, 000, Jhh, Jha]
/// _alpha=1, _beta=0
/// R = [00,  Ry,  00,  00,  00 ]^T
/// J = [Jyx, Jyy, Jyz, Jyh, 000
///      000, Jhy, 000, 000, 000]
/// _alpha=2, _beta=0
/// R = [00,  00,  Rz,  00,  00 ]^T
/// J = [Jzx, Jzy, Jzz, Jzh, 000
///      000, 000, Jhz, 000, 000]
/// _alpha=0, _beta=1
/// R = [00,  00,  00,  00,  Ra ]^T
/// J = [000, 000, 000, 000, Jxa
///      Jax, 000, 000, Jah, Jaa]
/// _alpha=1, _beta=1
/// R = [00,  00,  00,  00,  00 ]^T
/// J = [000, 000, 000, 000, Jya
///      000, Jay, 000, 000, 000]
/// _alpha=2, _beta=1
/// R = [00,  00,  00,  00,  00 ]^T
/// J = [000, 000, 000, 000, Jza
///      000, 000, Jaz, 000, 000]
///
/// In this manner, the full R and J are obtained with NO duplication of jobs:
/// R = [Rx,  Ry,  Rz,  Rh,  Ra ]^T
/// J = [Jxx, Jxy, Jxz, Jxh, Jxa
///      Jyx, Jyy, Jyz, Jyh, Jya
///      Jzx, Jzy, Jzz, Jzh, Jza
///      Jhx, Jhy, Jhz, Jhh, Jha
///      Jax, Jay, Jaz, Jah, Jaa]
///
class HomogenizedTotalLagrangianStressDivergenceA : public TotalLagrangianStressDivergenceS
{
public:
  static InputParameters validParams();
  HomogenizedTotalLagrangianStressDivergenceA(const InputParameters &amp; parameters);

protected:
  // Add overrides to base class contributions to only happen for _beta==0, to happen only once
  virtual Real computeQpResidual() override;
  virtual Real computeQpJacobianDisplacement(unsigned int alpha, unsigned int beta) override;

  /**
   * Method for computing the scalar part of residual for _kappa
   */
  virtual void computeScalarResidual() override;

  /**
   * Method for computing the scalar variable part of Jacobian for d-_kappa-residual / d-_kappa
   */
  virtual void computeScalarJacobian() override;

  /**
   * Method for computing an off-diagonal jacobian component d-_kappa-residual / d-jvar
   * jvar is looped over all field variables, which herein is just disp_x and disp_y
   */
  virtual void computeScalarOffDiagJacobian(const unsigned int jvar_num) override;

  /**
   * Method for computing an off-diagonal jacobian component at quadrature points.
   */
  virtual Real computeScalarQpOffDiagJacobian(const unsigned int jvar_num) override;

  /**
   * Method for computing an off-diagonal jacobian component d-_var-residual / d-svar.
   * svar is looped over all scalar variables, which herein is just _kappa and _kappa_other
   */
  virtual void computeOffDiagJacobianScalarLocal(const unsigned int svar_num) override;

  /**
   * Method for computing d-_var-residual / d-_svar at quadrature points.
   */
  virtual Real computeQpOffDiagJacobianScalar(const unsigned int svar_num) override;

  /**
   * Method for computing an off-diagonal jacobian component d-_kappa-residual / d-svar
   * svar is looped over other scalar variables, which herein is just _kappa_other
   */
  virtual void computeScalarOffDiagJacobianScalar(const unsigned int svar_num) override;

protected:
  /// Which component of the scalar vector residual this constraint is responsible for
  const unsigned int _beta;

  /// (Pointer to) Scalar variable this kernel operates on
  const MooseVariableScalar * const _kappao_var_ptr;

  /// The unknown scalar variable ID
  const unsigned int _kappao_var;

  /// Order of the scalar variable, used in several places
  const unsigned int _ko_order;

  /// Reference to the current solution at the current quadrature point
  const VariableValue &amp; _kappa_other;

  /// Type of each constraint (stress or strain) for each component
  HomogenizationA::ConstraintMap _cmap;

  /// The constraint type; initialize with &#x27;none&#x27;
  HomogenizationA::ConstraintType _ctype = HomogenizationA::ConstraintType::None;

  /// Used internally to iterate over each scalar component
  unsigned int _m;
  unsigned int _n;
  unsigned int _a;
  unsigned int _b;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b0cf8ccb-32c2-460d-973e-f97623888f98">(moose/modules/tensor_mechanics/test/include/kernels/HomogenizedTotalLagrangianStressDivergenceA.h)</a></div></div><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Kernels]
  [sdx0]
    type = HomogenizedTotalLagrangianStressDivergenceA
    variable = disp_x
    component = 0
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sdy0]
    type = HomogenizedTotalLagrangianStressDivergenceA
    variable = disp_y
    component = 1
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sdx1]
    type = HomogenizedTotalLagrangianStressDivergenceA
    variable = disp_x
    component = 0
    macro_var = hvarA
    macro_other = hvar
    prime_scalar = 1
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sdy1]
    type = HomogenizedTotalLagrangianStressDivergenceA
    variable = disp_y
    component = 1
    macro_var = hvarA
    macro_other = hvar
    prime_scalar = 1
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#c1be4f7b-0541-4df2-90c7-f1259275a080">(moose/modules/tensor_mechanics/test/tests/lagrangian/cartesian/total/homogenization/scalar_kernel/2dsole.i)</a><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Displaced mesh features untested</div><div class="card-content"><div class="moose-alert-content"><p>The displaced mesh features are not yet tested for the scalar augmentation system.</p></div></div></div></section><section class="scrollspy" id="37bd86a9-9dcb-4de2-a8fe-498c73407ed2" data-section-level="2" data-section-text="Parameters"><h2 id="KSB-parameters">Parameters</h2><p>There is one required parameters the user must supply for a kernel derived from <code>KernelScalarBase</code>:</p><ul class="browser-default"><li><p><code>scalar_variable</code>: the focus scalar variable of the kernel, for which assembly of the residual and Jacobian contributions will occur. It must be a <code>MooseScalarVariable</code>. This parameter may be renamed in a derived class to be more physically meaningful.</p></li></ul><p>If the <code>scalar_variable</code> parameter is not specified, then the derived class will behave identically to a regular <code>Kernel</code>, namely without any scalar functionality. This feature is useful if the scalar augmentation in inserted into a class structure with several levels and not all derived members use scalar variables.</p><p>As an example, the parameter listing is shown below for the <code>ScalarLMKernel</code> object with the <code>scalar_variable</code> parameter renamed to <code>kappa</code>:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []

  [ffnk]
    type = BodyForce
    variable = u
    function = ffn
  []

  [sk_lm]
    type = ScalarLMKernel
    variable = u
    kappa = lambda
    pp_name = pp
    value = 2.666666666666666
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a2c851aa-59d7-43e8-8a6e-53f24c7ecf9c">(moose/test/tests/kernels/scalar_kernel_constraint/scalar_constraint_kernel.i)</a><p>Note: to avoid an error message &quot;Variable &#x27;kappa&#x27; does not exist in this system&quot;, the following block should be added to the input file:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Problem]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#08fee468-c86e-4dff-874a-bffafbe3b820">(moose/test/tests/kernels/scalar_kernel_constraint/scalar_constraint_kernel.i)</a><p>There are also some optional parameters that can be supplied to <code>KernelScalarBase</code> classes. They are:</p><ul class="browser-default"><li><p><code>compute_scalar_residuals</code>: Whether to compute scalar residuals. This will automatically be set to false if a <code>scalar_variable</code> parameter is not supplied. Other cases where the user may want to set this to false is during testing when the scalar variable is an <code>AuxVariable</code> and not a solution variable in the system. </p></li><li><p><code>compute_field_residuals</code>: Whether to compute residuals for the primal field variable. If several <code>KernelScalarBase</code> objects are used in the input file to compute different rows (i.e. different variables) of the global residual, then some objects can be targeted to field variable rows and others to scalar variable rows.</p></li></ul></section></section><div class="moose-modal modal" id="ddaf6701-669a-477c-8db4-de6c41bce08e"><div class="modal-content"><h4>(moose/framework/src/kernels/ScalarLMKernel.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ScalarLMKernel.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ScalarLMKernel);
registerMooseObject(&quot;MooseApp&quot;, ADScalarLMKernel);

template &lt;bool is_ad&gt;
InputParameters
ScalarLMKernelTempl&lt;is_ad&gt;::validParams()
{
  InputParameters params = GenericKernelScalar&lt;is_ad&gt;::validParams();
  params.addClassDescription(&quot;This class is used to enforce integral of phi = V_0 with a &quot;
                             &quot;Lagrange multiplier approach.&quot;);
  params.renameCoupledVar(&quot;scalar_variable&quot;, &quot;kappa&quot;, &quot;Primary coupled scalar variable&quot;);
  params.addRequiredParam&lt;PostprocessorName&gt;(
      &quot;pp_name&quot;, &quot;Name of the Postprocessor containing the volume of the domain.&quot;);
  params.addRequiredParam&lt;Real&gt;(
      &quot;value&quot;, &quot;Given (constant) which we want the integral of the solution variable to match.&quot;);

  return params;
}

template &lt;bool is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::ScalarLMKernelTempl(const InputParameters &amp; parameters)
  : GenericKernelScalar&lt;is_ad&gt;(parameters),
    _value(this-&gt;template getParam&lt;Real&gt;(&quot;value&quot;)),
    _pp_value(this-&gt;getPostprocessorValue(&quot;pp_name&quot;))
{
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpJacobian()
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(
      !is_ad,
      &quot;In ADScalarLMKernel, computeScalarQpJacobian should not be called. Check computeJacobian &quot;
      &quot;implementation.&quot;);
  return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}

template class ScalarLMKernelTempl&lt;false&gt;;
template class ScalarLMKernelTempl&lt;true&gt;;
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="de751f4d-57ad-43b3-bd9d-71c64a69ba9e"><div class="modal-content"><h4>(moose/framework/src/kernels/ScalarLMKernel.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ScalarLMKernel.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ScalarLMKernel);
registerMooseObject(&quot;MooseApp&quot;, ADScalarLMKernel);

template &lt;bool is_ad&gt;
InputParameters
ScalarLMKernelTempl&lt;is_ad&gt;::validParams()
{
  InputParameters params = GenericKernelScalar&lt;is_ad&gt;::validParams();
  params.addClassDescription(&quot;This class is used to enforce integral of phi = V_0 with a &quot;
                             &quot;Lagrange multiplier approach.&quot;);
  params.renameCoupledVar(&quot;scalar_variable&quot;, &quot;kappa&quot;, &quot;Primary coupled scalar variable&quot;);
  params.addRequiredParam&lt;PostprocessorName&gt;(
      &quot;pp_name&quot;, &quot;Name of the Postprocessor containing the volume of the domain.&quot;);
  params.addRequiredParam&lt;Real&gt;(
      &quot;value&quot;, &quot;Given (constant) which we want the integral of the solution variable to match.&quot;);

  return params;
}

template &lt;bool is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::ScalarLMKernelTempl(const InputParameters &amp; parameters)
  : GenericKernelScalar&lt;is_ad&gt;(parameters),
    _value(this-&gt;template getParam&lt;Real&gt;(&quot;value&quot;)),
    _pp_value(this-&gt;getPostprocessorValue(&quot;pp_name&quot;))
{
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpJacobian()
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(
      !is_ad,
      &quot;In ADScalarLMKernel, computeScalarQpJacobian should not be called. Check computeJacobian &quot;
      &quot;implementation.&quot;);
  return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}

template class ScalarLMKernelTempl&lt;false&gt;;
template class ScalarLMKernelTempl&lt;true&gt;;
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="645fbbca-d6e5-44c7-a7f3-71b7aee2a889"><div class="modal-content"><h4>(moose/framework/src/kernels/ScalarLMKernel.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ScalarLMKernel.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ScalarLMKernel);
registerMooseObject(&quot;MooseApp&quot;, ADScalarLMKernel);

template &lt;bool is_ad&gt;
InputParameters
ScalarLMKernelTempl&lt;is_ad&gt;::validParams()
{
  InputParameters params = GenericKernelScalar&lt;is_ad&gt;::validParams();
  params.addClassDescription(&quot;This class is used to enforce integral of phi = V_0 with a &quot;
                             &quot;Lagrange multiplier approach.&quot;);
  params.renameCoupledVar(&quot;scalar_variable&quot;, &quot;kappa&quot;, &quot;Primary coupled scalar variable&quot;);
  params.addRequiredParam&lt;PostprocessorName&gt;(
      &quot;pp_name&quot;, &quot;Name of the Postprocessor containing the volume of the domain.&quot;);
  params.addRequiredParam&lt;Real&gt;(
      &quot;value&quot;, &quot;Given (constant) which we want the integral of the solution variable to match.&quot;);

  return params;
}

template &lt;bool is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::ScalarLMKernelTempl(const InputParameters &amp; parameters)
  : GenericKernelScalar&lt;is_ad&gt;(parameters),
    _value(this-&gt;template getParam&lt;Real&gt;(&quot;value&quot;)),
    _pp_value(this-&gt;getPostprocessorValue(&quot;pp_name&quot;))
{
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpJacobian()
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(
      !is_ad,
      &quot;In ADScalarLMKernel, computeScalarQpJacobian should not be called. Check computeJacobian &quot;
      &quot;implementation.&quot;);
  return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}

template class ScalarLMKernelTempl&lt;false&gt;;
template class ScalarLMKernelTempl&lt;true&gt;;
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="8dbcff91-0d6c-45bb-ae49-445cea5b09f7"><div class="modal-content"><h4>(moose/framework/src/kernels/ScalarLMKernel.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ScalarLMKernel.h&quot;

registerMooseObject(&quot;MooseApp&quot;, ScalarLMKernel);
registerMooseObject(&quot;MooseApp&quot;, ADScalarLMKernel);

template &lt;bool is_ad&gt;
InputParameters
ScalarLMKernelTempl&lt;is_ad&gt;::validParams()
{
  InputParameters params = GenericKernelScalar&lt;is_ad&gt;::validParams();
  params.addClassDescription(&quot;This class is used to enforce integral of phi = V_0 with a &quot;
                             &quot;Lagrange multiplier approach.&quot;);
  params.renameCoupledVar(&quot;scalar_variable&quot;, &quot;kappa&quot;, &quot;Primary coupled scalar variable&quot;);
  params.addRequiredParam&lt;PostprocessorName&gt;(
      &quot;pp_name&quot;, &quot;Name of the Postprocessor containing the volume of the domain.&quot;);
  params.addRequiredParam&lt;Real&gt;(
      &quot;value&quot;, &quot;Given (constant) which we want the integral of the solution variable to match.&quot;);

  return params;
}

template &lt;bool is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::ScalarLMKernelTempl(const InputParameters &amp; parameters)
  : GenericKernelScalar&lt;is_ad&gt;(parameters),
    _value(this-&gt;template getParam&lt;Real&gt;(&quot;value&quot;)),
    _pp_value(this-&gt;getPostprocessorValue(&quot;pp_name&quot;))
{
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpResidual()
{
  return _kappa[0] * _test[_i][_qp];
}

template &lt;bool is_ad&gt;
GenericReal&lt;is_ad&gt;
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpResidual()
{
  return _u[_qp] - _value / _pp_value;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpJacobian()
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(
      !is_ad,
      &quot;In ADScalarLMKernel, computeScalarQpJacobian should not be called. Check computeJacobian &quot;
      &quot;implementation.&quot;);
  return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeQpOffDiagJacobianScalar(unsigned int svar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeQpOffDiagJacobianScalar should not be called. Check &quot;
              &quot;computeOffDiagJacobianScalar &quot;
              &quot;implementation.&quot;);
  if (svar == _kappa_var)
    return _test[_i][_qp];
  else
    return 0.;
}

template &lt;bool is_ad&gt;
Real
ScalarLMKernelTempl&lt;is_ad&gt;::computeScalarQpOffDiagJacobian(unsigned int jvar)
{
  // This function will never be called for the AD version. But because C++ does
  // not support an optional function declaration based on a template parameter,
  // we must keep this template for all cases.
  mooseAssert(!is_ad,
              &quot;In ADScalarLMKernel, computeScalarQpOffDiagJacobian should not be called. Check &quot;
              &quot;computeOffDiagJacobian &quot;
              &quot;implementation.&quot;);
  if (jvar == _var.number())
    return _phi[_j][_qp];
  else
    return 0.;
}

template class ScalarLMKernelTempl&lt;false&gt;;
template class ScalarLMKernelTempl&lt;true&gt;;
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b61460d3-80d1-47aa-8224-275249b72457"><div class="modal-content"><h4>(moose/modules/tensor_mechanics/test/include/kernels/HomogenizedTotalLagrangianStressDivergenceR.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;TotalLagrangianStressDivergenceS.h&quot;

// Helpers common to the whole homogenization system
namespace HomogenizationR
{
/// Moose constraint type, for input
const MultiMooseEnum constraintType(&quot;strain stress none&quot;);
/// Constraint type: stress/PK stress or strain/deformation gradient
enum class ConstraintType
{
  Strain,
  Stress,
  None
};
typedef std::map&lt;std::pair&lt;unsigned int, unsigned int&gt;, std::pair&lt;ConstraintType, const Function *&gt;&gt;
    ConstraintMap;
}

/// Total Lagrangian formulation with most homogenization terms (one disp_xyz field and one scalar)
/// The macro_gradient variable is split into two scalars: the first component called &#x27;_hvar&#x27;
/// herein and all other components called &#x27;_avar&#x27; herein. For parameter _beta = 0, the primary
/// scalar (_kappa) is _hvar and the coupled scalar is _avar. For parameter _beta = 1, the primary
/// scalar (_kappa) is _avar and the coupled scalar is _hvar. Just like the primary field variable
/// (_var) is either disp_x or disp_y or disp_z depending on _alpha.
///
/// Thus, each instance of HomogenizedTotalLagrangianStressDivergenceR acts on one field variable
/// (_disp_alpha) and one scalar variable (_hvar_beta). The job of the kernel is to assemble the
/// residual of all dofs of _disp_alpha and of all dofs of _hvar_beta (namely, selected rows).
/// Also, it assembles the ENTIRE row for _disp_alpha and _hvar_beta (namely the columns
/// from all dofs of all _disp field variables and all dofs of all scalar variables _hvar and
/// _avar). The rows for the other field/scalar variables are handled by other instances of the
/// kernel, according to the flags compute_scalar_residuals and compute_field_residuals.
/// When compute_field_residuals is given, only component=_alpha matters and beta = {0,1} is looped.
/// When compute_scalar_residuals is given, only prime_scalar=_beta matters and alpha = {0,1,2} is looped.
///
/// In summary, for x=disp_x etc. and h=_hvar and a=_avar, then the contributions of the instances are
/// _alpha=0
/// R = [Rx,  00,  00,  00,  00 ]^T
/// J = [Jxx, Jxy, Jxz, Jxh, Jxa]
/// _alpha=1
/// R = [00,  Ry,  00,  00,  00 ]^T
/// J = [Jyx, Jyy, Jyz, Jyh, Jya]
/// _alpha=2
/// R = [00,  00,  Rz,  00,  00 ]^T
/// J = [Jzx, Jzy, Jzz, Jzh, Jza]
/// _beta=0
/// R = [00,  00,  00,  Rh,  00 ]^T
/// J = [Jhx, Jhy, Jhz, Jhh, Jha]
/// _beta=1
/// R = [00,  00,  00,  00,  Ra ]^T
/// J = [Jax, Jay, Jaz, Jah, Jaa]
///
/// In this manner, the full R and J are obtained with NO duplication of jobs:
/// R = [Rx,  Ry,  Rz,  Rh,  Ra ]^T
/// J = [Jxx, Jxy, Jxz, Jxh, Jxa
///      Jyx, Jyy, Jyz, Jyh, Jya
///      Jzx, Jzy, Jzz, Jzh, Jza
///      Jhx, Jhy, Jhz, Jhh, Jha
///      Jax, Jay, Jaz, Jah, Jaa]
///
class HomogenizedTotalLagrangianStressDivergenceR : public TotalLagrangianStressDivergenceS
{
public:
  static InputParameters validParams();
  HomogenizedTotalLagrangianStressDivergenceR(const InputParameters &amp; parameters);

protected:
  // Add overrides to base class contributions to only happen for _beta==0, to happen only once
  virtual Real computeQpResidual() override;
  virtual Real computeQpJacobianDisplacement(unsigned int alpha, unsigned int beta) override;

  /**
   * Method for computing the scalar part of residual for _kappa
   */
  virtual void computeScalarResidual() override;

  /**
   * Method for computing the scalar variable part of Jacobian for d-_kappa-residual / d-_kappa
   */
  virtual void computeScalarJacobian() override;

  /**
   * Method for computing an off-diagonal jacobian component d-_kappa-residual / d-jvar
   * jvar is looped over all field variables, which herein is just disp_x and disp_y
   */
  virtual void computeScalarOffDiagJacobian(const unsigned int jvar_num) override;

  /**
   * Method for computing an off-diagonal jacobian component at quadrature points.
   */
  virtual Real computeScalarQpOffDiagJacobian(const unsigned int jvar_num) override;

  /**
   * Method for computing an off-diagonal jacobian component d-_var-residual / d-svar.
   * svar is looped over all scalar variables, which herein is just _kappa and _kappa_other
   */
  virtual void computeOffDiagJacobianScalarLocal(const unsigned int svar_num) override;

  /**
   * Method for computing d-_var-residual / d-_svar at quadrature points.
   */
  virtual Real computeQpOffDiagJacobianScalar(const unsigned int /*svar_num*/) override;

  /**
   * Method for computing an off-diagonal jacobian component d-_kappa-residual / d-svar
   * svar is looped over other scalar variables, which herein is just _kappa_other
   */
  virtual void computeScalarOffDiagJacobianScalar(const unsigned int svar_num) override;

protected:
  /// Which component of the scalar vector residual this constraint is responsible for
  const unsigned int _beta;

  /// (Pointer to) Scalar variable this kernel operates on
  const MooseVariableScalar * const _kappao_var_ptr;

  /// The unknown scalar variable ID
  const unsigned int _kappao_var;

  /// Order of the scalar variable, used in several places
  const unsigned int _ko_order;

  /// Reference to the current solution at the current quadrature point
  const VariableValue &amp; _kappa_other;

  /// Type of each constraint (stress or strain) for each component
  HomogenizationR::ConstraintMap _cmap;

  /// The constraint type; initialize with &#x27;none&#x27;
  HomogenizationR::ConstraintType _ctype = HomogenizationR::ConstraintType::None;

  /// Used internally to iterate over each scalar component
  unsigned int _m;
  unsigned int _n;
  unsigned int _a;
  unsigned int _b;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ec20e356-af93-4ad6-a6a5-8d9cb17c958d"><div class="modal-content"><h4>(moose/modules/tensor_mechanics/test/tests/lagrangian/cartesian/total/homogenization/scalar_kernel/2drow.i)</h4><pre class="moose-pre"><code class="language-text"># 2D with mixed conditions on stress/strain

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  large_kinematics = false
[]

[Mesh]
  [base]
    type = FileMeshGenerator
    file = &#x27;2d.exo&#x27;
  []

  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = base
    normals = &#x27;-1 0 0
                1 0 0
                0 -1 0
                0 1 0&#x27;
    fixed_normal = true
    new_boundary = &#x27;left right bottom top&#x27;
  []
[]

[Variables]
  [disp_x]
  []
  [disp_y]
  []
  [hvar]
    family = SCALAR
    order = FIRST
  []
  [hvarA]
    family = SCALAR
    order = SECOND
  []
[]

[AuxVariables]
  [sxx]
    family = MONOMIAL
    order = CONSTANT
  []
  [syy]
    family = MONOMIAL
    order = CONSTANT
  []
  [sxy]
    family = MONOMIAL
    order = CONSTANT
  []
  [exx]
    family = MONOMIAL
    order = CONSTANT
  []
  [eyy]
    family = MONOMIAL
    order = CONSTANT
  []
  [exy]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[Kernels]
  [sdx]
    type = HomogenizedTotalLagrangianStressDivergenceR
    variable = disp_x
    component = 0
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    compute_field_residuals = true
    compute_scalar_residuals = false
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sdy]
    type = HomogenizedTotalLagrangianStressDivergenceR
    variable = disp_y
    component = 1
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    compute_field_residuals = true
    compute_scalar_residuals = false
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sd0]
    type = HomogenizedTotalLagrangianStressDivergenceR
    variable = disp_x
    component = 0
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    compute_field_residuals = false
    compute_scalar_residuals = true
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sd1]
    type = HomogenizedTotalLagrangianStressDivergenceR
    variable = disp_y
    component = 1
    macro_var = hvarA
    macro_other = hvar
    prime_scalar = 1
    compute_field_residuals = false
    compute_scalar_residuals = true
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
[]

[Problem]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]

[AuxKernels]
  [sxx]
    type = RankTwoAux
    variable = sxx
    rank_two_tensor = pk1_stress
    index_i = 0
    index_j = 0
  []
  [syy]
    type = RankTwoAux
    variable = syy
    rank_two_tensor = pk1_stress
    index_i = 1
    index_j = 1
  []
  [sxy]
    type = RankTwoAux
    variable = sxy
    rank_two_tensor = pk1_stress
    index_i = 0
    index_j = 1
  []
  [exx]
    type = RankTwoAux
    variable = exx
    rank_two_tensor = mechanical_strain
    index_i = 0
    index_j = 0
  []
  [eyy]
    type = RankTwoAux
    variable = eyy
    rank_two_tensor = mechanical_strain
    index_i = 1
    index_j = 1
  []
  [exy]
    type = RankTwoAux
    variable = exy
    rank_two_tensor = mechanical_strain
    index_i = 0
    index_j = 1
  []
[]

[Functions]
  [strain11]
    type = ParsedFunction
    value = &#x27;4.0e-2*t&#x27;
  []
  [strain22]
    type = ParsedFunction
    value = &#x27;-2.0e-2*t&#x27;
  []
  [strain12]
    type = ParsedFunction
    value = &#x27;1.0e-2*t&#x27;
  []
  [stress11]
    type = ParsedFunction
    value = &#x27;400*t&#x27;
  []
  [stress22]
    type = ParsedFunction
    value = &#x27;-200*t&#x27;
  []
  [stress12]
    type = ParsedFunction
    value = &#x27;100*t&#x27;
  []
[]

[BCs]
  [Periodic]
    [x]
      variable = disp_x
      auto_direction = &#x27;x y&#x27;
    []
    [y]
      variable = disp_y
      auto_direction = &#x27;x y&#x27;
    []
  []

  [fix1_x]
    type = DirichletBC
    boundary = &quot;fix1&quot;
    variable = disp_x
    value = 0
  []
  [fix1_y]
    type = DirichletBC
    boundary = &quot;fix1&quot;
    variable = disp_y
    value = 0
  []

  [fix2_y]
    type = DirichletBC
    boundary = &quot;fix2&quot;
    variable = disp_y
    value = 0
  []
[]

[Materials]
  [elastic_tensor_1]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 100000.0
    poissons_ratio = 0.3
    block = &#x27;1&#x27;
  []
  [elastic_tensor_2]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 120000.0
    poissons_ratio = 0.21
    block = &#x27;2&#x27;
  []
  [elastic_tensor_3]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 80000.0
    poissons_ratio = 0.4
    block = &#x27;3&#x27;
  []
  [compute_stress]
    type = ComputeLagrangianLinearElasticStress
  []
  [compute_strain]
    type = ComputeLagrangianStrain
    homogenization_gradient_names = &#x27;homogenization_gradient&#x27;
  []
  [compute_homogenization_gradient]
    type = ComputeHomogenizedLagrangianStrainA
    macro_gradientA = hvar
    macro_gradient = hvarA
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
[]

[Postprocessors]
  [sxx]
    type = ElementAverageValue
    variable = sxx
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [syy]
    type = ElementAverageValue
    variable = syy
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [sxy]
    type = ElementAverageValue
    variable = sxy
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [exx]
    type = ElementAverageValue
    variable = exx
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [eyy]
    type = ElementAverageValue
    variable = eyy
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [exy]
    type = ElementAverageValue
    variable = exy
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Transient

  solve_type = &#x27;newton&#x27;
#  solve_type = &#x27;PJFNK&#x27;
  line_search = none

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;

  l_max_its = 2
  l_tol = 1e-14
  nl_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 0.2
  dtmin = 0.2
  end_time = 1.0
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b0cf8ccb-32c2-460d-973e-f97623888f98"><div class="modal-content"><h4>(moose/modules/tensor_mechanics/test/include/kernels/HomogenizedTotalLagrangianStressDivergenceA.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;TotalLagrangianStressDivergenceS.h&quot;

// Helpers common to the whole homogenization system
namespace HomogenizationA
{
/// Moose constraint type, for input
const MultiMooseEnum constraintType(&quot;strain stress none&quot;);
/// Constraint type: stress/PK stress or strain/deformation gradient
enum class ConstraintType
{
  Strain,
  Stress,
  None
};
typedef std::map&lt;std::pair&lt;unsigned int, unsigned int&gt;, std::pair&lt;ConstraintType, const Function *&gt;&gt;
    ConstraintMap;
}

/// Total Lagrangian formulation with most homogenization terms (one disp_xyz field and one scalar)
/// The macro_gradient variable is split into two scalars: the first component called &#x27;_hvar&#x27;
/// herein and all other components called &#x27;_avar&#x27; herein. For parameter _beta = 0, the primary
/// scalar (_kappa) is _hvar and the coupled scalar is _avar. For parameter _beta = 1, the primary
/// scalar (_kappa) is _avar and the coupled scalar is _hvar. Just like the primary field variable
/// (_var) is either disp_x or disp_y or disp_z depending on _alpha.
///
/// Thus, each instance of HomogenizedTotalLagrangianStressDivergenceA acts on one field variable
/// (_disp_alpha) and one scalar variable (_hvar_beta). The job of the kernel is to assemble the
/// residual of all dofs of _disp_alpha and of all dofs of _hvar_beta (namely, selected entries).
/// It assembles a symmetric portion of the Jacobian for _disp_alpha and _hvar_beta, with some
/// logical checks to access only the particular desired terms (often for _alpha or _beta = 0).
/// The entries for the other field/scalar variables are handled by other instances of the
/// kernel, which have other values of _alpha AND _beta. The logical checks ensure the proper
/// decomposition of the jobs.
///
/// In summary, for x=disp_x etc. and h=_hvar and a=_avar, then the contributions of the instances are
/// _alpha=0, _beta=0
/// R = [Rx,  00,  00,  Rh,  00 ]^T
/// J = [Jxx, Jxy, Jxz, Jxh, 000
///      Jhx, 000, 000, Jhh, Jha]
/// _alpha=1, _beta=0
/// R = [00,  Ry,  00,  00,  00 ]^T
/// J = [Jyx, Jyy, Jyz, Jyh, 000
///      000, Jhy, 000, 000, 000]
/// _alpha=2, _beta=0
/// R = [00,  00,  Rz,  00,  00 ]^T
/// J = [Jzx, Jzy, Jzz, Jzh, 000
///      000, 000, Jhz, 000, 000]
/// _alpha=0, _beta=1
/// R = [00,  00,  00,  00,  Ra ]^T
/// J = [000, 000, 000, 000, Jxa
///      Jax, 000, 000, Jah, Jaa]
/// _alpha=1, _beta=1
/// R = [00,  00,  00,  00,  00 ]^T
/// J = [000, 000, 000, 000, Jya
///      000, Jay, 000, 000, 000]
/// _alpha=2, _beta=1
/// R = [00,  00,  00,  00,  00 ]^T
/// J = [000, 000, 000, 000, Jza
///      000, 000, Jaz, 000, 000]
///
/// In this manner, the full R and J are obtained with NO duplication of jobs:
/// R = [Rx,  Ry,  Rz,  Rh,  Ra ]^T
/// J = [Jxx, Jxy, Jxz, Jxh, Jxa
///      Jyx, Jyy, Jyz, Jyh, Jya
///      Jzx, Jzy, Jzz, Jzh, Jza
///      Jhx, Jhy, Jhz, Jhh, Jha
///      Jax, Jay, Jaz, Jah, Jaa]
///
class HomogenizedTotalLagrangianStressDivergenceA : public TotalLagrangianStressDivergenceS
{
public:
  static InputParameters validParams();
  HomogenizedTotalLagrangianStressDivergenceA(const InputParameters &amp; parameters);

protected:
  // Add overrides to base class contributions to only happen for _beta==0, to happen only once
  virtual Real computeQpResidual() override;
  virtual Real computeQpJacobianDisplacement(unsigned int alpha, unsigned int beta) override;

  /**
   * Method for computing the scalar part of residual for _kappa
   */
  virtual void computeScalarResidual() override;

  /**
   * Method for computing the scalar variable part of Jacobian for d-_kappa-residual / d-_kappa
   */
  virtual void computeScalarJacobian() override;

  /**
   * Method for computing an off-diagonal jacobian component d-_kappa-residual / d-jvar
   * jvar is looped over all field variables, which herein is just disp_x and disp_y
   */
  virtual void computeScalarOffDiagJacobian(const unsigned int jvar_num) override;

  /**
   * Method for computing an off-diagonal jacobian component at quadrature points.
   */
  virtual Real computeScalarQpOffDiagJacobian(const unsigned int jvar_num) override;

  /**
   * Method for computing an off-diagonal jacobian component d-_var-residual / d-svar.
   * svar is looped over all scalar variables, which herein is just _kappa and _kappa_other
   */
  virtual void computeOffDiagJacobianScalarLocal(const unsigned int svar_num) override;

  /**
   * Method for computing d-_var-residual / d-_svar at quadrature points.
   */
  virtual Real computeQpOffDiagJacobianScalar(const unsigned int svar_num) override;

  /**
   * Method for computing an off-diagonal jacobian component d-_kappa-residual / d-svar
   * svar is looped over other scalar variables, which herein is just _kappa_other
   */
  virtual void computeScalarOffDiagJacobianScalar(const unsigned int svar_num) override;

protected:
  /// Which component of the scalar vector residual this constraint is responsible for
  const unsigned int _beta;

  /// (Pointer to) Scalar variable this kernel operates on
  const MooseVariableScalar * const _kappao_var_ptr;

  /// The unknown scalar variable ID
  const unsigned int _kappao_var;

  /// Order of the scalar variable, used in several places
  const unsigned int _ko_order;

  /// Reference to the current solution at the current quadrature point
  const VariableValue &amp; _kappa_other;

  /// Type of each constraint (stress or strain) for each component
  HomogenizationA::ConstraintMap _cmap;

  /// The constraint type; initialize with &#x27;none&#x27;
  HomogenizationA::ConstraintType _ctype = HomogenizationA::ConstraintType::None;

  /// Used internally to iterate over each scalar component
  unsigned int _m;
  unsigned int _n;
  unsigned int _a;
  unsigned int _b;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="c1be4f7b-0541-4df2-90c7-f1259275a080"><div class="modal-content"><h4>(moose/modules/tensor_mechanics/test/tests/lagrangian/cartesian/total/homogenization/scalar_kernel/2dsole.i)</h4><pre class="moose-pre"><code class="language-text"># 2D with mixed conditions on stress/strain

[GlobalParams]
  displacements = &#x27;disp_x disp_y&#x27;
  large_kinematics = false
[]

[Mesh]
  [base]
    type = FileMeshGenerator
    file = &#x27;2d.exo&#x27;
  []

  [sidesets]
    type = SideSetsFromNormalsGenerator
    input = base
    normals = &#x27;-1 0 0
                1 0 0
                0 -1 0
                0 1 0&#x27;
    fixed_normal = true
    new_boundary = &#x27;left right bottom top&#x27;
  []
[]

[Variables]
  [disp_x]
  []
  [disp_y]
  []
  [hvar]
    family = SCALAR
    order = FIRST
  []
  [hvarA]
    family = SCALAR
    order = SECOND
  []
[]

[AuxVariables]
  [sxx]
    family = MONOMIAL
    order = CONSTANT
  []
  [syy]
    family = MONOMIAL
    order = CONSTANT
  []
  [sxy]
    family = MONOMIAL
    order = CONSTANT
  []
  [exx]
    family = MONOMIAL
    order = CONSTANT
  []
  [eyy]
    family = MONOMIAL
    order = CONSTANT
  []
  [exy]
    family = MONOMIAL
    order = CONSTANT
  []
[]

[Kernels]
  [sdx0]
    type = HomogenizedTotalLagrangianStressDivergenceA
    variable = disp_x
    component = 0
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sdy0]
    type = HomogenizedTotalLagrangianStressDivergenceA
    variable = disp_y
    component = 1
    macro_var = hvar
    macro_other = hvarA
    prime_scalar = 0
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sdx1]
    type = HomogenizedTotalLagrangianStressDivergenceA
    variable = disp_x
    component = 0
    macro_var = hvarA
    macro_other = hvar
    prime_scalar = 1
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
  [sdy1]
    type = HomogenizedTotalLagrangianStressDivergenceA
    variable = disp_y
    component = 1
    macro_var = hvarA
    macro_other = hvar
    prime_scalar = 1
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
[]

[Problem]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]

[AuxKernels]
  [sxx]
    type = RankTwoAux
    variable = sxx
    rank_two_tensor = pk1_stress
    index_i = 0
    index_j = 0
  []
  [syy]
    type = RankTwoAux
    variable = syy
    rank_two_tensor = pk1_stress
    index_i = 1
    index_j = 1
  []
  [sxy]
    type = RankTwoAux
    variable = sxy
    rank_two_tensor = pk1_stress
    index_i = 0
    index_j = 1
  []
  [exx]
    type = RankTwoAux
    variable = exx
    rank_two_tensor = mechanical_strain
    index_i = 0
    index_j = 0
  []
  [eyy]
    type = RankTwoAux
    variable = eyy
    rank_two_tensor = mechanical_strain
    index_i = 1
    index_j = 1
  []
  [exy]
    type = RankTwoAux
    variable = exy
    rank_two_tensor = mechanical_strain
    index_i = 0
    index_j = 1
  []
[]

[Functions]
  [strain11]
    type = ParsedFunction
    value = &#x27;4.0e-2*t&#x27;
  []
  [strain22]
    type = ParsedFunction
    value = &#x27;-2.0e-2*t&#x27;
  []
  [strain12]
    type = ParsedFunction
    value = &#x27;1.0e-2*t&#x27;
  []
  [stress11]
    type = ParsedFunction
    value = &#x27;400*t&#x27;
  []
  [stress22]
    type = ParsedFunction
    value = &#x27;-200*t&#x27;
  []
  [stress12]
    type = ParsedFunction
    value = &#x27;100*t&#x27;
  []
[]

[BCs]
  [Periodic]
    [x]
      variable = disp_x
      auto_direction = &#x27;x y&#x27;
    []
    [y]
      variable = disp_y
      auto_direction = &#x27;x y&#x27;
    []
  []

  [fix1_x]
    type = DirichletBC
    boundary = &quot;fix1&quot;
    variable = disp_x
    value = 0
  []
  [fix1_y]
    type = DirichletBC
    boundary = &quot;fix1&quot;
    variable = disp_y
    value = 0
  []

  [fix2_y]
    type = DirichletBC
    boundary = &quot;fix2&quot;
    variable = disp_y
    value = 0
  []
[]

[Materials]
  [elastic_tensor_1]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 100000.0
    poissons_ratio = 0.3
    block = &#x27;1&#x27;
  []
  [elastic_tensor_2]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 120000.0
    poissons_ratio = 0.21
    block = &#x27;2&#x27;
  []
  [elastic_tensor_3]
    type = ComputeIsotropicElasticityTensor
    youngs_modulus = 80000.0
    poissons_ratio = 0.4
    block = &#x27;3&#x27;
  []
  [compute_stress]
    type = ComputeLagrangianLinearElasticStress
  []
  [compute_strain]
    type = ComputeLagrangianStrain
    homogenization_gradient_names = &#x27;homogenization_gradient&#x27;
  []
  [compute_homogenization_gradient]
    type = ComputeHomogenizedLagrangianStrainA
    macro_gradientA = hvar
    macro_gradient = hvarA
    constraint_types = ${constraint_types}
    targets = ${targets}
  []
[]

[Postprocessors]
  [sxx]
    type = ElementAverageValue
    variable = sxx
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [syy]
    type = ElementAverageValue
    variable = syy
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [sxy]
    type = ElementAverageValue
    variable = sxy
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [exx]
    type = ElementAverageValue
    variable = exx
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [eyy]
    type = ElementAverageValue
    variable = eyy
    execute_on = &#x27;initial timestep_end&#x27;
  []
  [exy]
    type = ElementAverageValue
    variable = exy
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Executioner]
  type = Transient

  solve_type = &#x27;newton&#x27;
#  solve_type = &#x27;PJFNK&#x27;
  line_search = none

  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;

  l_max_its = 2
  l_tol = 1e-14
  nl_max_its = 30
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10

  start_time = 0.0
  dt = 0.2
  dtmin = 0.2
  end_time = 1.0
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a2c851aa-59d7-43e8-8a6e-53f24c7ecf9c"><div class="modal-content"><h4>(moose/test/tests/kernels/scalar_kernel_constraint/scalar_constraint_kernel.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [exact_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  []

  [ffn]
    type = ParsedFunction
    value = -4
  []

  [bottom_bc_fn]
    type = ParsedFunction
    value = -2*y
  []

  [right_bc_fn]
    type = ParsedFunction
    value =  2*x
  []

  [top_bc_fn]
    type = ParsedFunction
    value =  2*y
  []

  [left_bc_fn]
    type = ParsedFunction
    value = -2*x
  []
[]

[Variables]
  [u]
    family = LAGRANGE
    order = SECOND
  []
  [lambda]
    family = SCALAR
    order = FIRST
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []

  [ffnk]
    type = BodyForce
    variable = u
    function = ffn
  []

  [sk_lm]
    type = ScalarLMKernel
    variable = u
    kappa = lambda
    pp_name = pp
    value = 2.666666666666666
  []
[]

[Problem]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]

[BCs]
  [bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bottom_bc_fn
  []
  [right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_bc_fn
  []
  [top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = top_bc_fn
  []
  [left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = left_bc_fn
  []
[]

[Postprocessors]
  # integrate the volume of domain since original objects set
  # int(phi)=V0, rather than int(phi-V0)=0
  [pp]
    type = FunctionElementIntegral
    function = 1
    execute_on = initial
  []
  [l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Preconditioning]
  [pc]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-9
  l_tol = 1.e-10
  nl_max_its = 10
  # This example builds an indefinite matrix, so &quot;-pc_type hypre -pc_hypre_type boomeramg&quot; cannot
  # be used reliably on this problem
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu       NONZERO&#x27;
  # This is a linear problem, so we don&#x27;t need to recompute the
  # Jacobian. This isn&#x27;t a big deal for a Steady problems, however, as
  # there is only one solve.
  solve_type = &#x27;LINEAR&#x27;
[]

[Outputs]
  exodus = true
  hide = lambda
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="08fee468-c86e-4dff-874a-bffafbe3b820"><div class="modal-content"><h4>(moose/test/tests/kernels/scalar_kernel_constraint/scalar_constraint_kernel.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  xmin = -1
  xmax = 1
  ymin = -1
  ymax = 1
  nx = 2
  ny = 2
  elem_type = QUAD9
[]

[Functions]
  [exact_fn]
    type = ParsedFunction
    value = &#x27;x*x+y*y&#x27;
  []

  [ffn]
    type = ParsedFunction
    value = -4
  []

  [bottom_bc_fn]
    type = ParsedFunction
    value = -2*y
  []

  [right_bc_fn]
    type = ParsedFunction
    value =  2*x
  []

  [top_bc_fn]
    type = ParsedFunction
    value =  2*y
  []

  [left_bc_fn]
    type = ParsedFunction
    value = -2*x
  []
[]

[Variables]
  [u]
    family = LAGRANGE
    order = SECOND
  []
  [lambda]
    family = SCALAR
    order = FIRST
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []

  [ffnk]
    type = BodyForce
    variable = u
    function = ffn
  []

  [sk_lm]
    type = ScalarLMKernel
    variable = u
    kappa = lambda
    pp_name = pp
    value = 2.666666666666666
  []
[]

[Problem]
  kernel_coverage_check = false
  error_on_jacobian_nonzero_reallocation = true
[]

[BCs]
  [bottom]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;bottom&#x27;
    function = bottom_bc_fn
  []
  [right]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;right&#x27;
    function = right_bc_fn
  []
  [top]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;top&#x27;
    function = top_bc_fn
  []
  [left]
    type = FunctionNeumannBC
    variable = u
    boundary = &#x27;left&#x27;
    function = left_bc_fn
  []
[]

[Postprocessors]
  # integrate the volume of domain since original objects set
  # int(phi)=V0, rather than int(phi-V0)=0
  [pp]
    type = FunctionElementIntegral
    function = 1
    execute_on = initial
  []
  [l2_err]
    type = ElementL2Error
    variable = u
    function = exact_fn
    execute_on = &#x27;initial timestep_end&#x27;
  []
[]

[Preconditioning]
  [pc]
    type = SMP
    full = true
    solve_type = &#x27;NEWTON&#x27;
  []
[]

[Executioner]
  type = Steady
  nl_rel_tol = 1e-9
  l_tol = 1.e-10
  nl_max_its = 10
  # This example builds an indefinite matrix, so &quot;-pc_type hypre -pc_hypre_type boomeramg&quot; cannot
  # be used reliably on this problem
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type&#x27;
  petsc_options_value = &#x27;lu       NONZERO&#x27;
  # This is a linear problem, so we don&#x27;t need to recompute the
  # Jacobian. This isn&#x27;t a big deal for a Steady problems, however, as
  # there is only one solve.
  solve_type = &#x27;LINEAR&#x27;
[]

[Outputs]
  exodus = true
  hide = lambda
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#b1224530-c2dd-455e-b731-979ed178c1de" class="tooltipped" data-position="left" data-tooltip="Creation of Kernel Scalar Coupling Classes">Creation of Kernel Scalar Coupling Classes</a></li><li><a href="#23f66e09-3699-49be-a0c0-54ff98109fca" class="tooltipped" data-position="left" data-tooltip="Examples from Source Code">Examples from Source Code</a></li><li><a href="#37bd86a9-9dcb-4de2-a8fe-498c73407ed2" class="tooltipped" data-position="left" data-tooltip="Parameters">Parameters</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>