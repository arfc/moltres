<!DOCTYPE html><head><meta charset="UTF-8"><title>PerfGraph | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="538db598-a344-46e6-b3b0-d7678d8f040e" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="510138a8-b122-46c2-86b5-fb681dd795b5" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="dd650656-c6aa-4d46-9300-48be807728f9" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="6f2ae0a9-68c5-4274-bdcc-ccae8fbaff1a"><i class="material-icons">menu</i></a><ul class="sidenav" id="6f2ae0a9-68c5-4274-bdcc-ccae8fbaff1a"><li><a href="#!" class="dropdown-trigger" data-target="ec829971-f662-4935-98b3-5f72a2431579" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1a8f8cc4-48bf-4918-bce2-4370bbc450af" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1a1d196c-eaf2-40e4-8e0c-e9b9b6bd8696" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="538db598-a344-46e6-b3b0-d7678d8f040e"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="510138a8-b122-46c2-86b5-fb681dd795b5"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="dd650656-c6aa-4d46-9300-48be807728f9"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="ec829971-f662-4935-98b3-5f72a2431579"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="1a8f8cc4-48bf-4918-bce2-4370bbc450af"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="1a1d196c-eaf2-40e4-8e0c-e9b9b6bd8696"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">utils</span><a href="#" class="breadcrumb">PerfGraph</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="60de5e79-a5ce-47a5-b6ae-8e93ffba73a2" data-section-level="1" data-section-text="PerfGraph"><h1 id="perfgraph">PerfGraph</h1><section class="scrollspy" id="46a4606f-9026-4a21-bf57-ba6fb5e32d58" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>Note: this is API/developer documentation intended for those developing code using MOOSE.  For end-user focused documentation see <a href="../outputs/PerfGraphOutput.html">PerfGraphOutput</a>.</p><p>The <code>PerfGraph</code> object holds timing data for MOOSE.  The idea behind the design is to create a nested set of timing data that faithfully represents the call structure in MOOSE.</p><p>The performance graph is part of an ecosystem of objects:</p><ul class="browser-default"><li><p><code>PerfGraph</code>: Holds the full graph and the routines for printing it out </p></li><li><p><code>PerfNode</code>: Makes up each node in the graph and holds timing information for each section of code </p></li><li><p><code>PerfGuard</code>: Scope guard used to active and deactivate timers </p></li><li><p><code>PerfGraphInterface</code>: An interface class for gaining access to the <code>PerfGraph</code> for adding timers and pulling timing data </p></li><li><p><a href="../outputs/PerfGraphOutput.html">PerfGraphOutput</a>: Responsible for printing out the graph </p></li><li><p><a href="../postprocessors/PerfGraphData.html">PerfGraphData</a>: <code>Postprocessor</code> for outputting time from the graph </p></li><li><p><a href="PerfGraphLivePrint.html">PerfGraphLivePrint</a>: Object responsible for printing performance information duruing the run</p></li></ul><p>The <code>PerfGraph</code> works by utilizing the <code>TIME_SECTION</code> macro to specify that the current scope should be timed (see below for more information).  The timed sections are placed in an execution tree and the current &quot;stack&quot; of sections is kept up to date.  When timing starts, a snapshot of both the memory and current time are taken then these are compared when the current scope ends in order to tally time for that section of code.  The <code>PerfGraphLivePrint</code> object is watching the stream of what is executing and possibly printing out what is happening if it takes too long (or uses too much memory).  At the end of the run the <code>PerfGraphOutput</code> object is responsible for dumping out the relevant information.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning</span></div><div class="card-content"><div class="moose-alert-content"><p><code>PerfGraph</code> based timing should NOT be used inside tight compute loops or anything called inside a tight compute loop (i.e. don&#x27;t use it in <code>computeQpResidual()</code>).  It takes about 1e-6 seconds for the timing itself to happen.  That&#x27;s in the 1 MHz range... meaning that your calculation can&#x27;t run any faster than that wherever this timer is!  As a general rule... that means that you should have &gt;1000 operations going on inside a timed section.</p></div></div></div></section><section class="scrollspy" id="6e157d09-1d71-41e2-85dd-2b73dba28986" data-section-level="2" data-section-text="Inheriting From PerfGraphInterface"><h2 id="inheriting-from">Inheriting From <code>PerfGraphInterface</code></h2><p>To use for timing, make sure that your system inherits from <code>PerfGraphInterface</code>.  There are a couple of different constructors for <code>PerfGraphInterface</code>:</p><p>The first one allows you to pass in a <code>MooseObject*</code> and <em>infer</em> a &quot;prefix&quot; based on the <code>type()</code> of the object (the name of the object).  The &quot;prefix&quot; is prependended to the name of the timed sections to give uniform naming from each object</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  PerfGraphInterface(const MooseObject * moose_object);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#074eb9d2-7adf-4d31-a4dc-d1ab6d382c5e">(moose/framework/include/interfaces/PerfGraphInterface.h)</a><p>The second one allows you to pass in a <code>MooseObject*</code> and explicitly set a <code>prefix</code>:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#29a247c4-1350-4bfa-8b95-f32a7e122ebb">(moose/framework/include/interfaces/PerfGraphInterface.h)</a><p>The final one is for when your object is NOT a <code>MooseObject</code> inherited object.  You explicitly pass in the <code>PerfLog &amp;</code> (usually by retrieving it from the <code>MooseApp</code>) and explicitly set a <code>prefix</code>.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#1d0c4093-9bc0-4d9b-b281-e5dc683b77b4">(moose/framework/include/interfaces/PerfGraphInterface.h)</a></section><section class="scrollspy" id="bd17ec42-17cd-45f4-8235-5496a2e565e6" data-section-level="2" data-section-text="Logging Levels"><h2 id="logging-levels">Logging Levels</h2><p>The <code>PerfGraph</code> relies on loggging &quot;levels&quot; to determine how verbose the output should be.  When timing a section, be sure to set the level appropriately so that users are not inundated with too much noise.  The levels are:</p><ul class="browser-default"><li><p>0: Just the &quot;root&quot; - the whole application time </p></li><li><p>1: Minimal set of the most important routines (residual/jacobian computation, etc.) </p></li><li><p>2: Important initialization routines (setting up the mesh, initializing the systems, etc.) </p></li><li><p>3: More detailed information from levels <code>1</code> and <code>2</code> </p></li><li><p>4: This is where the Actions will start to print </p></li><li><p>5: Fairly unimportant, or less used routines </p></li><li><p>6: Routines that rarely take up much time</p></li></ul></section><section class="scrollspy" id="bcf9a36e-af58-4fc0-8a8b-7b94b0dc19e1" data-section-level="2" data-section-text="Performance Data Types"><h2 id="performance-data-types">Performance Data Types</h2><p>The data provided in regards to a section or a node in the <code>PerfGraph</code> is as follows:</p><ul class="browser-default"><li><p><code>SELF</code>: The time taken (not including children) in seconds </p></li><li><p><code>CHILDREN</code>: The time taken by children in seconds </p></li><li><p><code>TOTAL</code> The total (self plus children) time taken in seconds </p></li><li><p><code>SELF_AVG</code>: The average time taken (not including children) in seconds over all calls </p></li><li><p><code>CHILDREN_AVG</code>: The average time taken by children in seconds over all calls </p></li><li><p><code>TOTAL_AVG</code>: The total time taken (self plus children) in seconds over all calls </p></li><li><p><code>SELF_PERCENT</code>: The percentage of time taken (not including children) relative to the total application time </p></li><li><p><code>CHILDREN_PERCENT</code>: The percentage of time taken by children relative to the total application time </p></li><li><p><code>TOTAL_PERCENT</code>: The percentage of time taken (self plus children) relative to the total application time </p></li><li><p><code>SELF_MEMORY</code>: The memory added (not including children) in Megabytes </p></li><li><p><code>CHILDREN_MEMORY</code>: The memory added by children in Megabytes </p></li><li><p><code>TOTAL_MEMORY</code>: The total memory added (self plus children) in Megabytes </p></li><li><p><code>CALLS</code>: The number of calls</p></li></ul></section><section class="scrollspy" id="ff440964-84e1-49cc-8b66-29c898eefadb" data-section-level="2" data-section-text="Timing a Section"><h2 id="timing-a-section">Timing a Section</h2><p>There are two different methods for timing: on-the-fly registration and pre-registration.  On-the-fly registration is the preferred method and should be used whenever possible.</p><section id="a1e7bdcf-5002-4b05-8ddf-4435b22cd6e7" data-section-level="3" data-section-text="On - The - Fly Section Timing"><h3 id="on-the-fly-section-timing">On-The-Fly Section Timing</h3><p>Timing a section is as simple as using the <code>TIME_SECTION</code> macro within a C++ scope.  <code>TIME_SECTION</code> can take between one and four arguments.  The single argument version is used when doing pre-registration of sections.  For on-the-fly you invoke <code>TIME_SECTION</code> like so:</p><p><code>TIME_SECTION(section_name, level, live_message=&quot;&quot;, print_dots=true)</code></p><ul class="browser-default"><li><p><code>section_name</code>: The short name of the section.  This is the name used in the final table.  It is normally the function name or some other short name. </p></li><li><p><code>level</code>: The logging level </p></li><li><p><code>live_message</code>: OPTIONAL - but highly recommended.  This is the message <code>PerfGraphLivePrint</code> will print to the screen (if necessary).  It should be descriptive, title-cased, and written in an active way, e.g. &quot;Calculating Lama Heights&quot; </p></li><li><p><code>print_dots</code>: OPTIONAL - defaults to true.  This controls whether or not progress dots will be printed for this section.  Only turn this off if printing dots would intermingle with some screen output that is out of MOOSE&#x27;s control (for instance, in a library that you are calling into).</p></li></ul><p>An example showing the most-often use-case for <code>TIME_SECTION</code>:</p><pre class="moose-pre"><code class="language-c++">
void
Dog::clean()
{
  TIME_SECTION(&quot;clean&quot;, 2, &quot;Cleaning the Dog&quot;);
  ...

  {
    TIME_SECTION(&quot;soap&quot;, 3, &quot;Soaping the Dog&quot;);
    ...
  }

  {
    TIME_SECTION(&quot;rinse&quot;, 3, &quot;Rinsing the Dog&quot;);
    ...
  }
  ...
}
</code></pre><p>What <code>TIME_SECTION</code> is doing is creating a static variable to hold a <code>PerfID</code> that is initialized by registering the section with the <code>PerfGraphRegistry</code>.  Since this is a static variable the registration only happens the very first time that line of code is hit .  Every time after that it simply creates <code>PerfGuard</code> object using the passed in <code>PerfID</code>.  The <code>PerfGuard</code> tells the <code>PerfGraph</code> about the new scope and the timing is then started for that section.  At the end of the function the <code>PerfGuard</code> dies and in the destructor it tells the <code>PerfGraph</code> to remove that scope.  Timing this way means that it is exception safe and impossible to &quot;foul up&quot; because there are no &quot;push/pop&quot; methods to match.</p><section id="28d28414-c608-40fe-b678-382467819b78" data-section-level="4" data-section-text="Early Retrieval"><h4 id="early-retrieval">Early Retrieval</h4><p>Sections that are registered using the on-the-fly timing method described above (which are the overwhelming majority of sections in the MOOSE framework and modules) are not registered in the <code>PerfGraph</code> until the moment they are ran.</p><p>This poses a challenge when obtaining data pertaining to said sections: error checking on whether or not a section exists is dependent on whether or not the section has ran yet. The default behavior for obtaining <code>PerfGraph</code> section data via <code>PerfGraph::sectionData()</code> is to error if a section with that name has not been found.</p><p>Let&#x27;s say you are trying to time Jacobian evaluation time after every timestep, which is stored in the section <code>FEProblem::computeJacobianInternal</code>. But, your system only evaluates the Jacobian after the second timestep. If you try to pull section data on <code>FEProblem::computeJacobianInternal</code> on <code>TIMESTEP_END</code>, the system will error by default after the first evaluation because such a section has not ran (even though it is a valid section). With this, <code>Perfgraph::sectionData()</code> takes an optional boolean argument <code>must_exist</code> (which defaults to <code>true</code>). Setting <code>must_exist = false</code> will return zero if the section is not found.</p></section></section><section id="1e6713e2-ecb8-4663-bc5f-3303ab3b57b1" data-section-level="3" data-section-text="Pre - registered Timing"><h3 id="pre-registered-timing">Pre-registered Timing</h3><p>This type of timing should _only_ be utilized when absolutely necessary.  The main case where this comes up is timing in base classes that main get instantiated multiple times through different derived classes.  An example is the <code>Action</code> base class.</p><p>Timing a section using pre-registration is a two part process:</p><ol class="browser-default" start="1"><li><p> Register the section and save off the <code>PerfID</code> </p></li><li><p> Using the <code>TIME_SECTION</code> macro to start timing a <code>PerfID</code></p></li></ol><section id="63834250-9e0b-46d4-87ec-145e088d208c" data-section-level="4" data-section-text="Registration"><h4 id="registration">Registration</h4><p>Registering the section of code to be timed is accomplished by calling:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  PerfID registerTimedSection(const std::string &amp; section_name,
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#02015e4c-92ae-4a02-b6f5-a544c2927927">(moose/framework/include/interfaces/PerfGraphInterface.h)</a><p>The <code>section_name</code> names the section of code.  The <code>prefix + section_name</code> must be globally unique.  <code>level</code> is the &quot;log level&quot; of the section.  A higher number represents a more detailed log level.  Here are some quick guidelines for selecting <code>level</code>:</p><p><code>registerTimedSection()</code> returns a <code>PerfID</code> that is a unique identifier that identifies that code section.  This <code>PerfID</code> should typically get saved as a member variable of the class that is registering the section... this is normally done by initializing a <code>PerfID</code> member variable using <code>registerTimedSection()</code> in the initialization list of a constructor like so:</p><pre class="moose-pre"><code class="language-c++">
MyClass::MyClass() : _slow_function_timer(registerTimedSection(&quot;slowFunction&quot;)) {}
</code></pre></section><section id="d1c2831f-1962-4437-bb37-75139ad4722c" data-section-level="4" data-section-text="Timing"><h4 id="timing">Timing</h4><p>Once a timed section is registered and a <code>PerfID</code> is captured the section can be timed using the <code>TIME_SECTION</code> macro like so:</p><pre class="moose-pre"><code class="language-c++">

void slowFunction()
{
  TIME_SECTION(_slow_function_timer);

  // do all the things
}
</code></pre><p>What <code>TIME_SECTION</code> is doing is creating a <code>PerfGuard</code> object using the passed in <code>PerfID</code>.  The <code>PerfGuard</code> tells the <code>PerfGraph</code> about the new scope and the timing is then started for that section.  At the end of the function the <code>PerfGuard</code> dies and in the destructor it tells the <code>PerfGraph</code> to remove that scope.  Timing this way means that it is exception safe and impossible to &quot;foul up&quot; because there are no &quot;push/pop&quot; methods to match.</p></section></section><section class="scrollspy" id="ad2b489a-458d-4de4-9191-9553dc8694f2" data-section-level="2" data-section-text="Retrieving Section Data"><h2 id="retrieving-section-data">Retrieving Section Data</h2><p>An object that inherits from <code>PerfGraphInterface</code> can retrieve the data pertaining to a registered section by calling <code>perfGraph().sectionData()</code>. Note the various available data types in <a href="PerfGraph.html#performance-data-types">Performance Data Types</a>.</p></section><section class="scrollspy" id="dddd1dd2-8fcd-4765-b3be-a5cc94800432" data-section-level="2" data-section-text="The Internals PerfGraph"><h2 id="the-internals">The <code>PerfGraph</code> Internals</h2><p>The <code>PerfGraph</code> object&#x27;s main purpose is to store the complete call-graph of <code>PerfNode</code>s and the current call-stack of <code>PerfNode</code>s.  The graph is held by holding onto the <code>_root_node</code>.  All other scopes that are pushed into the graph are then children/descendants of the <code>_root_node</code>.</p><p>The call-stack is held within the <code>_stack</code> variable.  The <code>_stack</code> is statically allocated to <code>MAX_STACK_SIZE</code> and <code>_current_position</code> is used to point at the most recent node on the stack.  When a <code>PerfGuard</code> tells the <code>PerfStack</code> about a new scope, the new scope is added a child to the <code>PerfNode</code> that is in the <code>_current_position</code>.  <code>_current_position</code> is then incremented and the new <code>PerfNode</code> is put there. When a scope is removed by the <code>PerfGuard</code> the <code>_current_position</code> is simply decremented - with no other action being necessary.</p><p>In addition, the <code>_execution_list</code> is keeping a running list of every section that executes.  This is utilized by <code>PerfGraphLivePrint</code> to print messages out that are multiple levels deep.</p></section><section class="scrollspy" id="f65f59c4-2dd8-48e2-ba6c-35cada003ac6" data-section-level="2" data-section-text="Printing"><h2 id="printing">Printing</h2><p>Some other capability the <code>PerfGraph</code> has is the ability to print formatted tables displaying the values held in the graph.  These normally shouldn&#x27;t be called directly, but instead should be accessed using a <a href="../outputs/PerfGraphOutput.html">PerfGraphOutput</a> output object.</p><p>The <code>print()</code> method prints out an indented set of section names and shows their timing like so:</p><pre class="moose-pre"><code class="language-text">
Performance Graph:
----------------------------------------------------------------------------------------------------------------------------------------------
|                  Section                 | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |
----------------------------------------------------------------------------------------------------------------------------------------------
| MooseTestApp (main)                      |     1 |      0.008 |      0.008 |   0.66 |       1 |      1.259 |      1.259 | 100.00 |      67 |
|   FEProblem::outputStep                  |     2 |      0.001 |      0.000 |   0.04 |       0 |      0.064 |      0.032 |   5.09 |       8 |
|   Steady::PicardSolve                    |     1 |      0.000 |      0.000 |   0.01 |       0 |      0.717 |      0.717 |  56.92 |      32 |
|     FEProblem::solve                     |     1 |      0.134 |      0.134 |  10.61 |      29 |      0.716 |      0.716 |  56.89 |      32 |
|       FEProblem::computeResidualInternal |    14 |      0.000 |      0.000 |   0.01 |       0 |      0.458 |      0.033 |  36.34 |       1 |
|       FEProblem::computeJacobianInternal |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.125 |      0.062 |   9.91 |       2 |
|     FEProblem::outputStep                |     1 |      0.000 |      0.000 |   0.02 |       0 |      0.000 |      0.000 |   0.02 |       0 |
|   Steady::final                          |     1 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.02 |       0 |
|     FEProblem::outputStep                |     1 |      0.000 |      0.000 |   0.01 |       0 |      0.000 |      0.000 |   0.02 |       0 |
----------------------------------------------------------------------------------------------------------------------------------------------
</code></pre><p><code>Calls</code> is the number of times that section was run. <code>Self</code> time is the time actually taken by the section while <code>Children</code> time is the cumulative time of all of the sub-sections below that section and <code>Total</code> is the sum of the two.  The <code>Avg</code> and <code>%</code> columns represent the average and percent of the total run-time of the app for the number in the column to the left. <code>Mem</code> is the memory (in Megabytes) for the column to the left (Self or Total).</p><p>There are also two other ways to print information out about the graph using <code>printHeaviestBranch()</code> and <code>printHeaviestSections()</code>.  These are described well over on the <a href="../outputs/PerfGraphOutput.html">PerfGraphOutput</a> page. </p></section></section></section><div class="moose-modal modal" id="074eb9d2-7adf-4d31-a4dc-d1ab6d382c5e"><div class="modal-content"><h4>(moose/framework/include/interfaces/PerfGraphInterface.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Moose.h&quot;
#include &quot;PerfGuard.h&quot;

#ifndef MOOSE_NO_PERF_GRAPH
#define TIME_SECTION1(id)                                                                          \
  mooseAssert(!Threads::in_threads, &quot;PerfGraph timing cannot be used within threaded sections&quot;);   \
  PerfGuard time_guard(this-&gt;_pg_moose_app.perfGraph(), id);
#define CHECK_TIME_SECTION(id, section_name)                                                       \
  mooseAssert(moose::internal::getPerfGraphRegistry().sectionInfo(id)._name ==                     \
                  timedSectionName(section_name),                                                  \
              &quot;PerfGraph section &#x27;&quot; + timedSectionName(section_name) +                             \
                  &quot;&#x27; is already registered with name &#x27;&quot; +                                          \
                  moose::internal::getPerfGraphRegistry().sectionInfo(id)._name + &quot;&#x27;&quot;);
#else
#define TIME_SECTION1(id)
#define CHECK_TIME_SECTION(id, section_name)
#endif

#define TIME_SECTION2(section_name, level)                                                         \
  const PerfID __perf_id = this-&gt;registerTimedSection(section_name, level);                        \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

#define TIME_SECTION3(section_name, level, live_message)                                           \
  const PerfID __perf_id = this-&gt;registerTimedSection(section_name, level, live_message);          \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

#define TIME_SECTION4(section_name, level, live_message, print_dots)                               \
  const PerfID __perf_id =                                                                         \
      this-&gt;registerTimedSection(section_name, level, live_message, print_dots);                   \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

// Overloading solution from https://stackoverflow.com/a/11763277
#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME
#define TIME_SECTION(...)                                                                          \
  GET_MACRO(__VA_ARGS__, TIME_SECTION4, TIME_SECTION3, TIME_SECTION2, TIME_SECTION1, )(__VA_ARGS__)

class InputParameters;
class MooseObject;

/**
 * Interface for objects interacting with the PerfGraph.
 *
 * Enables getting PerfGraph information and registering PerfGraph timed sections.
 */
class PerfGraphInterface
{
public:
  /**
   * For objects that _are_ MooseObjects with a default prefix of type()
   */
  PerfGraphInterface(const MooseObject * moose_object);

  static InputParameters validParams();

  /**
   * For objects that _are_ MooseObjects
   */
  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);

  /**
   * For objects that aren&#x27;t MooseObjects
   */
  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);

  /**
   * For objects that construct the PerfGraphInterface _before_ the PerfGraph
   * is initialized (see MooseApp and OutputWarehouse)
   */
  PerfGraphInterface(MooseApp &amp; moose_app, const std::string prefix = &quot;&quot;);

  virtual ~PerfGraphInterface() = default;

  /**
   * Get the PerfGraph
   */
  PerfGraph &amp; perfGraph();

protected:
  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level) const;

  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @param live_message The message to be printed to the screen during execution
   * @param print_dots Whether or not progress dots should be printed for this section
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name,
                              const unsigned int level,
                              const std::string &amp; live_message,
                              const bool print_dots = true) const;

  /**
   * @returns The name of the timed section with the name \p section_name.
   *
   * Optionally adds a prefix if one is defined.
   */
  std::string timedSectionName(const std::string &amp; section_name) const;

  /// The MooseApp that owns the PerfGraph
  MooseApp &amp; _pg_moose_app;

  /// A prefix to use for all sections
  const std::string _prefix;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="29a247c4-1350-4bfa-8b95-f32a7e122ebb"><div class="modal-content"><h4>(moose/framework/include/interfaces/PerfGraphInterface.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Moose.h&quot;
#include &quot;PerfGuard.h&quot;

#ifndef MOOSE_NO_PERF_GRAPH
#define TIME_SECTION1(id)                                                                          \
  mooseAssert(!Threads::in_threads, &quot;PerfGraph timing cannot be used within threaded sections&quot;);   \
  PerfGuard time_guard(this-&gt;_pg_moose_app.perfGraph(), id);
#define CHECK_TIME_SECTION(id, section_name)                                                       \
  mooseAssert(moose::internal::getPerfGraphRegistry().sectionInfo(id)._name ==                     \
                  timedSectionName(section_name),                                                  \
              &quot;PerfGraph section &#x27;&quot; + timedSectionName(section_name) +                             \
                  &quot;&#x27; is already registered with name &#x27;&quot; +                                          \
                  moose::internal::getPerfGraphRegistry().sectionInfo(id)._name + &quot;&#x27;&quot;);
#else
#define TIME_SECTION1(id)
#define CHECK_TIME_SECTION(id, section_name)
#endif

#define TIME_SECTION2(section_name, level)                                                         \
  const PerfID __perf_id = this-&gt;registerTimedSection(section_name, level);                        \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

#define TIME_SECTION3(section_name, level, live_message)                                           \
  const PerfID __perf_id = this-&gt;registerTimedSection(section_name, level, live_message);          \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

#define TIME_SECTION4(section_name, level, live_message, print_dots)                               \
  const PerfID __perf_id =                                                                         \
      this-&gt;registerTimedSection(section_name, level, live_message, print_dots);                   \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

// Overloading solution from https://stackoverflow.com/a/11763277
#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME
#define TIME_SECTION(...)                                                                          \
  GET_MACRO(__VA_ARGS__, TIME_SECTION4, TIME_SECTION3, TIME_SECTION2, TIME_SECTION1, )(__VA_ARGS__)

class InputParameters;
class MooseObject;

/**
 * Interface for objects interacting with the PerfGraph.
 *
 * Enables getting PerfGraph information and registering PerfGraph timed sections.
 */
class PerfGraphInterface
{
public:
  /**
   * For objects that _are_ MooseObjects with a default prefix of type()
   */
  PerfGraphInterface(const MooseObject * moose_object);

  static InputParameters validParams();

  /**
   * For objects that _are_ MooseObjects
   */
  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);

  /**
   * For objects that aren&#x27;t MooseObjects
   */
  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);

  /**
   * For objects that construct the PerfGraphInterface _before_ the PerfGraph
   * is initialized (see MooseApp and OutputWarehouse)
   */
  PerfGraphInterface(MooseApp &amp; moose_app, const std::string prefix = &quot;&quot;);

  virtual ~PerfGraphInterface() = default;

  /**
   * Get the PerfGraph
   */
  PerfGraph &amp; perfGraph();

protected:
  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level) const;

  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @param live_message The message to be printed to the screen during execution
   * @param print_dots Whether or not progress dots should be printed for this section
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name,
                              const unsigned int level,
                              const std::string &amp; live_message,
                              const bool print_dots = true) const;

  /**
   * @returns The name of the timed section with the name \p section_name.
   *
   * Optionally adds a prefix if one is defined.
   */
  std::string timedSectionName(const std::string &amp; section_name) const;

  /// The MooseApp that owns the PerfGraph
  MooseApp &amp; _pg_moose_app;

  /// A prefix to use for all sections
  const std::string _prefix;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="1d0c4093-9bc0-4d9b-b281-e5dc683b77b4"><div class="modal-content"><h4>(moose/framework/include/interfaces/PerfGraphInterface.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Moose.h&quot;
#include &quot;PerfGuard.h&quot;

#ifndef MOOSE_NO_PERF_GRAPH
#define TIME_SECTION1(id)                                                                          \
  mooseAssert(!Threads::in_threads, &quot;PerfGraph timing cannot be used within threaded sections&quot;);   \
  PerfGuard time_guard(this-&gt;_pg_moose_app.perfGraph(), id);
#define CHECK_TIME_SECTION(id, section_name)                                                       \
  mooseAssert(moose::internal::getPerfGraphRegistry().sectionInfo(id)._name ==                     \
                  timedSectionName(section_name),                                                  \
              &quot;PerfGraph section &#x27;&quot; + timedSectionName(section_name) +                             \
                  &quot;&#x27; is already registered with name &#x27;&quot; +                                          \
                  moose::internal::getPerfGraphRegistry().sectionInfo(id)._name + &quot;&#x27;&quot;);
#else
#define TIME_SECTION1(id)
#define CHECK_TIME_SECTION(id, section_name)
#endif

#define TIME_SECTION2(section_name, level)                                                         \
  const PerfID __perf_id = this-&gt;registerTimedSection(section_name, level);                        \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

#define TIME_SECTION3(section_name, level, live_message)                                           \
  const PerfID __perf_id = this-&gt;registerTimedSection(section_name, level, live_message);          \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

#define TIME_SECTION4(section_name, level, live_message, print_dots)                               \
  const PerfID __perf_id =                                                                         \
      this-&gt;registerTimedSection(section_name, level, live_message, print_dots);                   \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

// Overloading solution from https://stackoverflow.com/a/11763277
#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME
#define TIME_SECTION(...)                                                                          \
  GET_MACRO(__VA_ARGS__, TIME_SECTION4, TIME_SECTION3, TIME_SECTION2, TIME_SECTION1, )(__VA_ARGS__)

class InputParameters;
class MooseObject;

/**
 * Interface for objects interacting with the PerfGraph.
 *
 * Enables getting PerfGraph information and registering PerfGraph timed sections.
 */
class PerfGraphInterface
{
public:
  /**
   * For objects that _are_ MooseObjects with a default prefix of type()
   */
  PerfGraphInterface(const MooseObject * moose_object);

  static InputParameters validParams();

  /**
   * For objects that _are_ MooseObjects
   */
  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);

  /**
   * For objects that aren&#x27;t MooseObjects
   */
  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);

  /**
   * For objects that construct the PerfGraphInterface _before_ the PerfGraph
   * is initialized (see MooseApp and OutputWarehouse)
   */
  PerfGraphInterface(MooseApp &amp; moose_app, const std::string prefix = &quot;&quot;);

  virtual ~PerfGraphInterface() = default;

  /**
   * Get the PerfGraph
   */
  PerfGraph &amp; perfGraph();

protected:
  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level) const;

  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @param live_message The message to be printed to the screen during execution
   * @param print_dots Whether or not progress dots should be printed for this section
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name,
                              const unsigned int level,
                              const std::string &amp; live_message,
                              const bool print_dots = true) const;

  /**
   * @returns The name of the timed section with the name \p section_name.
   *
   * Optionally adds a prefix if one is defined.
   */
  std::string timedSectionName(const std::string &amp; section_name) const;

  /// The MooseApp that owns the PerfGraph
  MooseApp &amp; _pg_moose_app;

  /// A prefix to use for all sections
  const std::string _prefix;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="02015e4c-92ae-4a02-b6f5-a544c2927927"><div class="modal-content"><h4>(moose/framework/include/interfaces/PerfGraphInterface.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Moose.h&quot;
#include &quot;PerfGuard.h&quot;

#ifndef MOOSE_NO_PERF_GRAPH
#define TIME_SECTION1(id)                                                                          \
  mooseAssert(!Threads::in_threads, &quot;PerfGraph timing cannot be used within threaded sections&quot;);   \
  PerfGuard time_guard(this-&gt;_pg_moose_app.perfGraph(), id);
#define CHECK_TIME_SECTION(id, section_name)                                                       \
  mooseAssert(moose::internal::getPerfGraphRegistry().sectionInfo(id)._name ==                     \
                  timedSectionName(section_name),                                                  \
              &quot;PerfGraph section &#x27;&quot; + timedSectionName(section_name) +                             \
                  &quot;&#x27; is already registered with name &#x27;&quot; +                                          \
                  moose::internal::getPerfGraphRegistry().sectionInfo(id)._name + &quot;&#x27;&quot;);
#else
#define TIME_SECTION1(id)
#define CHECK_TIME_SECTION(id, section_name)
#endif

#define TIME_SECTION2(section_name, level)                                                         \
  const PerfID __perf_id = this-&gt;registerTimedSection(section_name, level);                        \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

#define TIME_SECTION3(section_name, level, live_message)                                           \
  const PerfID __perf_id = this-&gt;registerTimedSection(section_name, level, live_message);          \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

#define TIME_SECTION4(section_name, level, live_message, print_dots)                               \
  const PerfID __perf_id =                                                                         \
      this-&gt;registerTimedSection(section_name, level, live_message, print_dots);                   \
  CHECK_TIME_SECTION(__perf_id, section_name);                                                     \
  TIME_SECTION1(__perf_id);

// Overloading solution from https://stackoverflow.com/a/11763277
#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME
#define TIME_SECTION(...)                                                                          \
  GET_MACRO(__VA_ARGS__, TIME_SECTION4, TIME_SECTION3, TIME_SECTION2, TIME_SECTION1, )(__VA_ARGS__)

class InputParameters;
class MooseObject;

/**
 * Interface for objects interacting with the PerfGraph.
 *
 * Enables getting PerfGraph information and registering PerfGraph timed sections.
 */
class PerfGraphInterface
{
public:
  /**
   * For objects that _are_ MooseObjects with a default prefix of type()
   */
  PerfGraphInterface(const MooseObject * moose_object);

  static InputParameters validParams();

  /**
   * For objects that _are_ MooseObjects
   */
  PerfGraphInterface(const MooseObject * moose_object, const std::string prefix);

  /**
   * For objects that aren&#x27;t MooseObjects
   */
  PerfGraphInterface(PerfGraph &amp; perf_graph, const std::string prefix = &quot;&quot;);

  /**
   * For objects that construct the PerfGraphInterface _before_ the PerfGraph
   * is initialized (see MooseApp and OutputWarehouse)
   */
  PerfGraphInterface(MooseApp &amp; moose_app, const std::string prefix = &quot;&quot;);

  virtual ~PerfGraphInterface() = default;

  /**
   * Get the PerfGraph
   */
  PerfGraph &amp; perfGraph();

protected:
  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name, const unsigned int level) const;

  /**
   * Call to register a named section for timing.
   *
   * @param section_name The name of the code section to be timed
   * @param level The importance of the timer - lower is more important (0 will always come out)
   * @param live_message The message to be printed to the screen during execution
   * @param print_dots Whether or not progress dots should be printed for this section
   * @return The ID of the section - use when starting timing
   */
  PerfID registerTimedSection(const std::string &amp; section_name,
                              const unsigned int level,
                              const std::string &amp; live_message,
                              const bool print_dots = true) const;

  /**
   * @returns The name of the timed section with the name \p section_name.
   *
   * Optionally adds a prefix if one is defined.
   */
  std::string timedSectionName(const std::string &amp; section_name) const;

  /// The MooseApp that owns the PerfGraph
  MooseApp &amp; _pg_moose_app;

  /// A prefix to use for all sections
  const std::string _prefix;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#46a4606f-9026-4a21-bf57-ba6fb5e32d58" class="tooltipped" data-position="left" data-tooltip="Overview">Overview</a></li><li><a href="#6e157d09-1d71-41e2-85dd-2b73dba28986" class="tooltipped" data-position="left" data-tooltip="Inheriting From PerfGraphInterface">Inheriting From PerfGraphInterface</a></li><li><a href="#bd17ec42-17cd-45f4-8235-5496a2e565e6" class="tooltipped" data-position="left" data-tooltip="Logging Levels">Logging Levels</a></li><li><a href="#bcf9a36e-af58-4fc0-8a8b-7b94b0dc19e1" class="tooltipped" data-position="left" data-tooltip="Performance Data Types">Performance Data Types</a></li><li><a href="#ff440964-84e1-49cc-8b66-29c898eefadb" class="tooltipped" data-position="left" data-tooltip="Timing a Section">Timing a Section</a></li><li><a href="#ad2b489a-458d-4de4-9191-9553dc8694f2" class="tooltipped" data-position="left" data-tooltip="Retrieving Section Data">Retrieving Section Data</a></li><li><a href="#dddd1dd2-8fcd-4765-b3be-a5cc94800432" class="tooltipped" data-position="left" data-tooltip="The Internals PerfGraph">The Internals PerfGraph</a></li><li><a href="#f65f59c4-2dd8-48e2-ba6c-35cada003ac6" class="tooltipped" data-position="left" data-tooltip="Printing">Printing</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>