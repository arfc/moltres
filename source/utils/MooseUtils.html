<!DOCTYPE html><head><meta charset="UTF-8"><title>MooseUtils Namespace | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="37f092e4-a67e-48eb-90e4-a89b14ca945d" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8cb7ca02-f48f-4927-9c1e-458fa8fa6013" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="bfc66cb4-fa13-4933-bde0-32b36a4c07d1" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="a0d5a6ab-8912-4ad2-938e-267201954207"><i class="material-icons">menu</i></a><ul class="sidenav" id="a0d5a6ab-8912-4ad2-938e-267201954207"><li><a href="#!" class="dropdown-trigger" data-target="b9618531-5b39-4346-a41a-e572e1bb3b15" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d919bad5-5169-4228-8967-7aad2e7a59db" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d8975c33-a137-471b-930b-43d1488f21f7" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="37f092e4-a67e-48eb-90e4-a89b14ca945d"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="8cb7ca02-f48f-4927-9c1e-458fa8fa6013"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="bfc66cb4-fa13-4933-bde0-32b36a4c07d1"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="b9618531-5b39-4346-a41a-e572e1bb3b15"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="d919bad5-5169-4228-8967-7aad2e7a59db"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="d8975c33-a137-471b-930b-43d1488f21f7"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">utils</span><a href="#" class="breadcrumb">MooseUtils</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="66c7013a-0f8a-403f-a438-723e515c8fdb" data-section-level="1" data-section-text="MooseUtils Namespace"><h1 id="mooseutils-namespace">MooseUtils Namespace</h1><p>MOOSE includes a number of C++ utility classes and functions that may be useful for developing applications. These utilities are within the MooseUtils C++ namespace. The following summarized some of the available items.</p><section class="scrollspy" id="ba6f4e5e-4c85-4309-9f63-1943c40963ce" data-section-level="2" data-section-text="DelimitedFileReader"><h2 id="delimitedfilereader">DelimitedFileReader</h2><p>It is often necessary to read data from files during a simulation and often this data is in a delimited format such as <a href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a>. The DelimitedFileReader is designed for reading this data into application objects.</p><p>The DelimitedFileReader can read data organized into columns or rows. It assumes that all data, outside of the header, is numeric and can be converted to a C++ double. Additionally, it is also assumed that the first row or column defines the number of columns for the entire file, if the number of columns differs from the first row an error will be produced.</p><p>Within MOOSE this utility is utilized by the <a href="../vectorpostprocessors/CSVReader.html">CSVReader</a>, which is part of the <a href="/VectorPostprocessors/index.md">VectorPostprocessors</a> system. This object will be used to explain the use of the utility.</p><p>Using the DelimitedFileReader is very simple and requires three steps. First, include the utility header file with <code>#include &quot;DelimitedFileReader.h&quot;</code>. Then the object is instantiated and read method is called, as shown in the unit test snippet below.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
reader.read();
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#262a4b2b-55d3-4fcd-a560-3b872d7e8218">(moose/unit/src/DelimitedFileReaderTest.C)</a><p>This class is required to include the filename upon construction. Optionally, a second argument providing a pointer to a <a href="http://libmesh.github.io/">libMesh</a> Communicator object may be provided. This argument should be used when the reader is used within a MooseObject. For example, as shown in <a href="#csv_reader_ctor">Listing 1</a>, the CSVReader object passes a Communicator object to the reader. If not provided the reader will read the data on all processors. If provided it will only read on single processor and broadcast the data to the others.</p><p>It is also possible to configure how file is formatted via the various set methods, as listed below. The set methods must be called prior to the read method.</p><ul class="browser-default"><li><p><strong>setIgnoreEmptyLines</strong>&lt;br&gt; By default this all empty lines are ignored, when set to <code>false</code> the presence of an empty line will cause an error.</p><p></p></li><li><p><strong>setFormat</strong>&lt;br&gt; The reader is capable of reading data organized into columns or rows, this method allows for the format to be changed.</p><p></p></li><li><p><strong>setDelimiter</strong>&lt;br&gt; By default the reader will attempt to infer the delimiter from the file; however, the detection is fairly rudimentary. It inspects the file for a comma, if a comma exists then a comma is the delimiter. If it does not exist then space is the delimiter. The setDelimiter method can be used to explicitly set string to use for a delimiter.</p><p></p></li><li><p><strong>setHeader</strong>&lt;br&gt; By default the reader will attempt to detect the presence of header strings for both the row and column data formats. The setHeader method can be used to explicitly control whether header data exists. If headers exist the each data row or column will be labeled using the header and it will be accessible via the getData method by name. If no headers exist the header names are generated as &quot;column_0&quot;, &quot;column_1&quot;, etc. or &quot;row_0&quot;, &quot;row_1&quot;, etc. depending on the format settings.</p><p></p></li><li><p><strong>setComment</strong>&lt;br&gt; The string provided to this method marks content that will be ignored. Any line beginning with the character(s) will be ignored and all characters on a line that follow the character(s) will also be ignored.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 1: </span><span class="moose-caption-text" id="csv_reader_ctor">Construction of DelimitedFileReader object within a MooseObject initialization list.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">CSVReader::validParams()
{
  InputParameters params = GeneralVectorPostprocessor::validParams();
  params.addClassDescription(
      &quot;Converts columns of a CSV file into vectors of a VectorPostprocessor.&quot;);
  params.addRequiredParam&lt;FileName&gt;(&quot;csv_file&quot;,
                                    &quot;The name of the CSV file to read. Currently, with &quot;
                                    &quot;the exception of the header row, only numeric &quot;
                                    &quot;values are supported.&quot;);
  params.addParam&lt;bool&gt;(&quot;header&quot;,
                        &quot;When true it is assumed that the first row contains column headers, these &quot;
                        &quot;headers are used as the VectorPostprocessor vector names. If false the &quot;
                        &quot;file is assumed to contain only numbers and the vectors are named &quot;
                        &quot;automatically based on the column number (e.g., &#x27;column_0000&#x27;, &quot;
                        &quot;&#x27;column_0001&#x27;). If not supplied the reader attempts to auto detect the &quot;
                        &quot;headers.&quot;);
  params.addParam&lt;std::string&gt;(&quot;delimiter&quot;,
                               &quot;The column delimiter. Despite the name this can read files &quot;
                               &quot;separated by delimiter other than a comma. If this options is &quot;
                               &quot;omitted it will read comma or space separated files.&quot;);
  params.addParam&lt;bool&gt;(
      &quot;ignore_empty_lines&quot;, true, &quot;When true new empty lines in the file are ignored.&quot;);
  params.set&lt;bool&gt;(&quot;contains_complete_history&quot;) = true;
  params.suppressParameter&lt;bool&gt;(&quot;contains_complete_history&quot;);
  params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true) = EXEC_NONE;
  params.suppressParameter&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);

  // The value from this VPP is naturally already on every processor
  // TODO: Make this not the case!  See #11415
  params.set&lt;bool&gt;(&quot;_auto_broadcast&quot;) = false;

  return params;
}

CSVReader::CSVReader(const InputParameters &amp; params) : GeneralVectorPostprocessor(params)
{
  /// The MOOSE delimited file reader.
  MooseUtils::DelimitedFileReader csv_reader(getParam&lt;FileName&gt;(&quot;csv_file&quot;), &amp;_communicator);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#2b3f4496-4f4b-4bea-b7c5-90bd652df33f">(moose/framework/src/vectorpostprocessors/CSVReader.C)</a></div></div></li></ul><p>After the data is read using the &quot;read&quot; method, there are two methods used for accessing the data:</p><ul class="browser-default"><li><p><code>getNames</code>: This method returns a vector of the column names as read from the header or generated based on the number of columns when a header-less file is being examined. </p></li><li><p><code>getData</code>: There are three overloaded versions of this method. One returns a reference to the </p></li><li><p>entire data set as a vector of vectors. The others access a single vector by name or index.</p></li></ul></section><section class="scrollspy" id="4a4b1047-afbf-4162-a46a-cb9199e3820c" data-section-level="2" data-section-text="Tensor Operators"><h2 id="tensor-operators">Tensor Operators</h2><section id="0b511dea-3f7c-41c3-acae-b5cb2e89c684" data-section-level="3" data-section-text="RankTwoTensor Operators"><h3 id="ranktwotensor-operators">RankTwoTensor Operators</h3><p>The following operators are available for RankTwoTensor, with the values in parentheses indicating what the type of the other object to be subject to the operation.</p><pre class="moose-pre"><code class="language-text">
=
+= (RankTwoTensor)
-= (RankTwoTensor)
*= (Real, RankTwoTensor)
/= (Real)
+ (RankTwoTensor)
- (RankTwoTensor)
* (Real, RankTwoTensor, TypeTensor&lt;Real&gt;)
/ (Real)
</code></pre><p>In addition, many methods are available for additional matrix operations:</p><ul class="browser-default"><li><p><code>zero()</code> </p></li><li><p><code>print()</code> </p></li><li><p><code>transpose()</code> </p></li><li><p><code>L2norm()</code> </p></li><li><p><code>row(int)</code> returns a TypeVector&lt;Real&gt; </p></li><li><p><code>rotate(RealTensorValue)</code> </p></li><li><p><code>rotate(RankTwoTensor)</code> </p></li><li><p><code>rotateXyPlane(Real)</code> </p></li><li><p><code>doubleContraction()</code> </p></li><li><p><code>deviatoric()</code> traceless part </p></li><li><p><code>trace()</code> </p></li><li><p><code>dtrace()</code> derivatives of <code>trace()</code> wrt tensor entries </p></li><li><p><code>secondInvariant()</code> second invariant of the symmetric part of <code>deviatoric()</code> </p></li><li><p><code>dsecondInvariant()</code>  derivatives of <code>secondInvariant()</code> wrt tensor entries </p></li><li><p><code>d2secondInvariant()</code>  second derivatives of <code>secondInvariant()</code> wrt tensor entries </p></li><li><p><code>thirdInvariant()</code> third invariant of the symmetric part of deviatoric, i.e. <code>((deviatoric() + deviatoric().transpose())/2).det()</code> </p></li><li><p><code>dthirdInvariant()</code>  derivatives of <code>thirdInvariant()</code> wrt tensor entries </p></li><li><p><code>d2thirdInvariant()</code>  second derivatives of <code>thirdInvariant()</code> wrt tensor entries </p></li><li><p><code>sin3Lode()</code>  sine of three times the Lode angle </p></li><li><p><code>dsin3Lode()</code>  derivatives of <code>sin3Lode()</code> wrt tensor entries </p></li><li><p><code>d2sin3Lode()</code>  second derivatives of <code>sin3Lode()</code> wrt tensor entries </p></li><li><p><code>det()</code> determinant </p></li><li><p><code>ddet()</code> derivatives of <code>det()</code> wrt tensor entries </p></li><li><p><code>inverse()</code> </p></li><li><p><code>symmetricEigenvalues()</code>  eigenvalues of symmetric part of tensor </p></li><li><p><code>dsymmetricEigenvalues()</code>  derivatives of symmetricEigenvalues wrt the tensor entries </p></li><li><p><code>d2symmetricEigenvalues()</code> second derivatives of symmetricEigenvalues wrt the tensor entries</p></li></ul><p>These methods are thoroughly tested using CPPUNIT.</p></section><section id="aced9d86-bfbd-4225-bbf6-e69ca4f69c25" data-section-level="3" data-section-text="RankThreeTensor Operators"><h3 id="rankthreetensor-operators">RankThreeTensor Operators</h3><p>The following operators are available for RankThreeTensor, with the values in parentheses indicating what the type of the other object to be subject to the operation.</p><pre class="moose-pre"><code class="language-text">
=
+= (RankThreeTensor)
-= (RankThreeTensor)
*= (Real)
/= (Real)
+ (RankThreeTensor)
- (RankThreeTensor)
* (RankThreeTensor, RankTwoTensor, Real)
/ (Real)
</code></pre><p>In addition, many methods are available for additional matrix operations:</p><ul class="browser-default"><li><p><code>zero()</code> </p></li><li><p><code>print()</code> </p></li><li><p><code>L2norm()</code> </p></li><li><p><code>rotate(Real)</code> </p></li><li><p><code>rotate(RealTensorValue)</code> </p></li><li><p><code>rotate(RankTwoTensor)</code> </p></li><li><p>fillFromInputVector(TypeVector&lt;Real&gt;) </p></li><li><p><code>fillFromPlaneNormal(TypeVector&lt;Real&gt;)</code> </p></li><li><p><code>mixedProjectRankFour(RankTwoTensor)</code> creates a Rank-4 tensor from the contraction <span class="moose-katex-inline-equation" id="moose-equation-6371edab-1484-42aa-a107-9cad9ca602ad"><script>var element = document.getElementById("moose-equation-6371edab-1484-42aa-a107-9cad9ca602ad");katex.render("D_{ijkl} = T_{mij}b_{mn}T_{nkl}", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p><code>doubleContraction(RankTwoTensor)</code> creates a vector from the contraction <span class="moose-katex-inline-equation" id="moose-equation-bf1e09e8-1b6e-4947-b093-6b09bf102e0e"><script>var element = document.getElementById("moose-equation-bf1e09e8-1b6e-4947-b093-6b09bf102e0e");katex.render("v_i = T_{ijk}b_{jk}", element, {displayMode:false,throwOnError:false});</script></span></p></li></ul></section><section id="47669f14-93ab-4a1c-9911-0b564bf487da" data-section-level="3" data-section-text="RankFourTensor Operators"><h3 id="rankfourtensor-operators">RankFourTensor Operators</h3><p>The following operators are available for RankFourTensor, with the values in parentheses indicating what the type of the other object to be subject to the operation.</p><pre class="moose-pre"><code class="language-text">
=
+= (RankFourTensor)
-= (RankFourTensor)
*= (Real)
/= (Real)
+ (RankFourTensor)
- (RankFourTensor)
* (RankFourTensor, RankTwoTensor, RealTensorValue, Real)
/ (Real)
</code></pre><p>In addition, many methods are available for additional matrix operations:</p><ul class="browser-default"><li><p><code>zero()</code> </p></li><li><p><code>print()</code> </p></li><li><p><code>L2norm()</code> </p></li><li><p><code>invSymm()</code> returns A<span class="moose-katex-inline-equation" id="moose-equation-29a4b9ab-c008-4d96-a935-bbc4ddff3d27"><script>var element = document.getElementById("moose-equation-29a4b9ab-c008-4d96-a935-bbc4ddff3d27");katex.render("_{ijkl}", element, {displayMode:false,throwOnError:false});</script></span> from the input C<span class="moose-katex-inline-equation" id="moose-equation-6988b801-0cf8-4dce-9160-c81b50b74259"><script>var element = document.getElementById("moose-equation-6988b801-0cf8-4dce-9160-c81b50b74259");katex.render("_{ijkl}", element, {displayMode:false,throwOnError:false});</script></span> such that <span class="moose-katex-inline-equation" id="moose-equation-0064c22a-cee3-4f05-a322-c67ce5135ad2"><script>var element = document.getElementById("moose-equation-0064c22a-cee3-4f05-a322-c67ce5135ad2");katex.render("C_{ijkl} \\cdot A_{ijkl} = 0.5 \\left( \\delta_{im} \\delta_{jn} + \\delta_{in} \\delta_{jm} \\right)", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p><code>rotate(RealTensorValue)</code> </p></li><li><p><code>rotate(RankTwoTensor)</code> </p></li><li><p><code>transposeMajor()</code> witch first pair and second pair of indices </p></li><li><p><code>surfaceFillFromInputVector(TypeVector&lt;Real&gt;)</code> Fills tensor entries by ignoring the last dimension </p></li><li><p><code>fillFromInputVector(TypeVector&lt;Real&gt;, FillMethod)</code> used to build elasticity tensors </p></li><li><p><code>fillGeneralIsotropic(TypeVector&lt;Real&gt;)</code> </p></li><li><p><code>fillAntisymmetricIsotropic(Real)</code> </p></li><li><p><code>fillSymmetricIsotropic(Real, Real)</code> </p></li><li><p><code>fillSymmetricIsotropicEandNu(Real, Real)</code> </p></li><li><p><code>innerProductTranspose</code> </p></li><li><p><code>sum3x3()</code> calculates the sum of C<span class="moose-katex-inline-equation" id="moose-equation-a8174041-c068-4ae2-9ead-052dc4a590fa"><script>var element = document.getElementById("moose-equation-a8174041-c068-4ae2-9ead-052dc4a590fa");katex.render("_{iijj}", element, {displayMode:false,throwOnError:false});</script></span> over <span class="moose-katex-inline-equation" id="moose-equation-04be5b27-bdd2-425f-9e8b-e360ed783029"><script>var element = document.getElementById("moose-equation-04be5b27-bdd2-425f-9e8b-e360ed783029");katex.render("i", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-deac6a7a-cf2a-44a6-845b-802ba69cc9b5"><script>var element = document.getElementById("moose-equation-deac6a7a-cf2a-44a6-845b-802ba69cc9b5");katex.render("j", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p><code>sum1x3()</code> calculates the vector from summing over <span class="moose-katex-inline-equation" id="moose-equation-1368799a-64ba-4990-91cb-18989cb634ff"><script>var element = document.getElementById("moose-equation-1368799a-64ba-4990-91cb-18989cb634ff");katex.render("j", element, {displayMode:false,throwOnError:false});</script></span> in C<span class="moose-katex-inline-equation" id="moose-equation-f60add32-1b22-46fe-bd8c-3a62cb664318"><script>var element = document.getElementById("moose-equation-f60add32-1b22-46fe-bd8c-3a62cb664318");katex.render("_{iijj}", element, {displayMode:false,throwOnError:false});</script></span> </p></li><li><p><code>isSymmetric()</code> </p></li><li><p><code>isIsotropic()</code></p></li></ul></section></section></section><div class="moose-modal modal" id="262a4b2b-55d3-4fcd-a560-3b872d7e8218"><div class="modal-content"><h4>(moose/unit/src/DelimitedFileReaderTest.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;gtest/gtest.h&quot;

// MOOSE includes
#include &quot;DelimitedFileReader.h&quot;
#include &quot;MooseException.h&quot;
#include &quot;libmesh/point.h&quot;

TEST(DelimitedFileReader, BadFilename)
{
  try
  {
    MooseUtils::DelimitedFileReader reader(&quot;not/a/valid/file.csv&quot;);
    reader.read();
    FAIL();
  }
  catch (const std::exception &amp; err)
  {
    std::size_t pos = std::string(err.what()).find(&quot;Unable to open file \&quot;not/a/valid/file.csv\&quot;&quot;);
    ASSERT_TRUE(pos != std::string::npos);
  }
}

TEST(DelimitedFileReader, BadHeaderName)
{
  try
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
    reader.read();
    reader.getData(&quot;second&quot;);
    FAIL();
  }
  catch (const std::exception &amp; err)
  {
    std::size_t pos = std::string(err.what())
                          .find(&quot;Could not find &#x27;second&#x27; in header of file &quot;
                                &quot;data/csv/example.csv.&quot;);
    ASSERT_TRUE(pos != std::string::npos);
  }
}

TEST(DelimitedFileReader, BadIndex)
{
  try
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
    reader.read();
    reader.getData(12345);
    FAIL();
  }
  catch (const std::exception &amp; err)
  {
    std::size_t pos = std::string(err.what()).find(&quot;The supplied index 12345 is out-of-range&quot;);
    ASSERT_TRUE(pos != std::string::npos);
  }
}

TEST(DelimitedFileReader, Headers)
{
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
    reader.read();
    const std::vector&lt;std::string&gt; &amp; cols = reader.getNames();
    std::vector&lt;std::string&gt; gold = {&quot;year&quot;, &quot;month&quot;, &quot;day&quot;};
    EXPECT_EQ(cols, gold);
  }
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_no_header.csv&quot;);
    reader.read();
    const std::vector&lt;std::string&gt; &amp; cols = reader.getNames();
    std::vector&lt;std::string&gt; gold = {&quot;column_0&quot;, &quot;column_1&quot;, &quot;column_2&quot;};
    EXPECT_EQ(cols, gold);
  }
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_padding_test.csv&quot;);
    reader.read();
    const std::vector&lt;std::string&gt; &amp; cols = reader.getNames();
    std::vector&lt;std::string&gt; gold = {&quot;column_00&quot;,
                                     &quot;column_01&quot;,
                                     &quot;column_02&quot;,
                                     &quot;column_03&quot;,
                                     &quot;column_04&quot;,
                                     &quot;column_05&quot;,
                                     &quot;column_06&quot;,
                                     &quot;column_07&quot;,
                                     &quot;column_08&quot;,
                                     &quot;column_09&quot;,
                                     &quot;column_10&quot;,
                                     &quot;column_11&quot;,
                                     &quot;column_12&quot;,
                                     &quot;column_13&quot;};
    EXPECT_EQ(cols, gold);
  }
}

TEST(DelimitedFileReader, Data)
{
  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {{1980, 1980, 2011, 2013}, {6, 10, 5, 5}, {24, 9, 1, 15}};

  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
    reader.read();
    const std::vector&lt;std::vector&lt;double&gt;&gt; &amp; data = reader.getData();
    EXPECT_EQ(data, gold);
  }
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
    reader.read();
    EXPECT_EQ(reader.getData(&quot;day&quot;), gold[2]);
    EXPECT_EQ(reader.getData(2), gold[2]);
  }
}

TEST(DelimitedFileReader, DataChangeDelimiter)
{
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.txt&quot;);
    reader.setDelimiter(&quot;$&quot;);
    reader.read();
    const std::vector&lt;std::vector&lt;double&gt;&gt; &amp; data = reader.getData();
    std::vector&lt;std::vector&lt;double&gt;&gt; gold = {
        {1980, 1980, 2011, 2013}, {6, 10, 5, 5}, {24, 9, 1, 15}};
    EXPECT_EQ(data, gold);
  }
}

TEST(DelimitedFileReader, WrongPointSize)
{
  try
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_bad_points.csv&quot;);
    reader.read();
    const std::vector&lt;Point&gt; pts = reader.getDataAsPoints();
    FAIL();
  }
  catch (const std::exception &amp; err)
  {
    std::string gold = &quot;Each point in file data/csv/example_bad_points.csv must have 3 entries&quot;;
    std::size_t pos = std::string(err.what()).find(gold);
    ASSERT_TRUE(pos != std::string::npos);
  }
}

TEST(DelimitedFileReader, WrongRowSize)
{
  try
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_bad_row.csv&quot;);
    reader.read();
    FAIL();
  }
  catch (const std::exception &amp; err)
  {
    std::string gold = &quot;The number of columns read (4) does not match the number of columns &quot;
                       &quot;expected (3) based on the first row of the file when reading row 4 in file &quot;
                       &quot;data/csv/example_bad_row.csv.&quot;;
    std::size_t pos = std::string(err.what()).find(gold);
    ASSERT_TRUE(pos != std::string::npos);
  }
}

TEST(DelimitedFileReader, BadRowValue)
{
  try
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_bad_value.csv&quot;);
    reader.read();
    FAIL();
  }
  catch (const std::exception &amp; err)
  {
    std::string gold = &quot;Failed to convert a delimited data into double when reading line 4 in file &quot;
                       &quot;data/csv/example_bad_value.csv.&quot;;
    std::size_t pos = std::string(err.what()).find(gold);
    ASSERT_TRUE(pos != std::string::npos);
  }
}

TEST(DelimitedFileReader, EmptyLine)
{
  // Read file with empty lines
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_empty_lines.csv&quot;);
  reader.read();

  // Disable empty lines
  try
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_empty_lines.csv&quot;);
    reader.setIgnoreEmptyLines(false);
    reader.read();
    FAIL();
  }
  catch (const std::exception &amp; err)
  {
    std::string gold =
        &quot;Failed to read line 4 in file data/csv/example_empty_lines.csv. The line is empty.&quot;;
    std::size_t pos = std::string(err.what()).find(gold);
    ASSERT_TRUE(pos != std::string::npos);
  }
}

TEST(DelimitedFileReader, RowData)
{
  // Read file with empty lines
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/row_example.csv&quot;);
  reader.setFormatFlag(MooseUtils::DelimitedFileReader::FormatFlag::ROWS);
  reader.read();

  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {{1, 2, 3, 4}, {10, 20, 30, 40, 50}};
  std::vector&lt;std::string&gt; names = {&quot;foo&quot;, &quot;bar&quot;};
  EXPECT_EQ(reader.getData(), gold);
  EXPECT_EQ(reader.getData(&quot;foo&quot;), gold[0]);
  EXPECT_EQ(reader.getData(&quot;bar&quot;), gold[1]);
  EXPECT_EQ(reader.getNames(), names);
}

TEST(DelimitedFileReader, RowDataNoHeader)
{
  // Read file with empty lines
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/row_example_no_header.csv&quot;);
  reader.setFormatFlag(MooseUtils::DelimitedFileReader::FormatFlag::ROWS);
  reader.read();

  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {{1, 2, 3, 4},
                                           {10, 20, 30, 40, 50},
                                           {300, 301},
                                           {300, 301},
                                           {300, 301},
                                           {300, 301},
                                           {300, 301},
                                           {300, 301},
                                           {300, 301},
                                           {300, 301},
                                           {300, 301}};
  std::vector&lt;std::string&gt; names = {&quot;row_00&quot;,
                                    &quot;row_01&quot;,
                                    &quot;row_02&quot;,
                                    &quot;row_03&quot;,
                                    &quot;row_04&quot;,
                                    &quot;row_05&quot;,
                                    &quot;row_06&quot;,
                                    &quot;row_07&quot;,
                                    &quot;row_08&quot;,
                                    &quot;row_09&quot;,
                                    &quot;row_10&quot;};
  EXPECT_EQ(reader.getData(), gold);
  EXPECT_EQ(reader.getNames(), names);
  EXPECT_EQ(reader.getData(&quot;row_00&quot;), gold[0]);
  EXPECT_EQ(reader.getData(&quot;row_01&quot;), gold[1]);
  EXPECT_EQ(reader.getData(&quot;row_02&quot;), gold[2]);
}

TEST(DelimitedFileReader, RowDataComment)
{
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/row_example_comment.csv&quot;);
  reader.setFormatFlag(MooseUtils::DelimitedFileReader::FormatFlag::ROWS);
  reader.setComment(&quot;#&quot;);
  reader.read();

  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {
      {0, 1, 2, 3}, {1, 4, 2, 1, 113, 31}, {2, 4, 5, 6}, {3, 5, 4, 3, 2, 1}};
  EXPECT_EQ(reader.getData(), gold);
  EXPECT_EQ(reader.getData(&quot;row_0&quot;), gold[0]);
  EXPECT_EQ(reader.getData(&quot;row_1&quot;), gold[1]);
  EXPECT_EQ(reader.getData(&quot;row_2&quot;), gold[2]);
  EXPECT_EQ(reader.getData(&quot;row_3&quot;), gold[3]);
}

TEST(DelimitedFileReader, Comment)
{
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/row_example_line_comment.csv&quot;);
  reader.setDelimiter(&quot;,&quot;);
  reader.setComment(&quot;#&quot;);
  reader.read();

  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {{0, 0}, {1, 4}, {2, 5}, {3, 6}};
  EXPECT_EQ(reader.getData(), gold);
  EXPECT_EQ(reader.getData(&quot;column_0&quot;), gold[0]);
  EXPECT_EQ(reader.getData(&quot;column_1&quot;), gold[1]);
  EXPECT_EQ(reader.getData(&quot;column_2&quot;), gold[2]);
  EXPECT_EQ(reader.getData(&quot;column_3&quot;), gold[3]);
}

TEST(DelimitedFileReader, AutoDelimiter)
{
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_space.csv&quot;);
  reader.read();

  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {{1980, 1980, 2011, 2013}, {6, 10, 5, 5}, {24, 9, 1, 15}};
  EXPECT_EQ(reader.getData(), gold);
  EXPECT_EQ(reader.getData(&quot;year&quot;), gold[0]);
  EXPECT_EQ(reader.getData(&quot;month&quot;), gold[1]);
  EXPECT_EQ(reader.getData(&quot;day&quot;), gold[2]);
}

TEST(DelimitedFileReader, AutoDelimiterComment)
{
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_space_comment.csv&quot;);
  reader.setFormatFlag(MooseUtils::DelimitedFileReader::FormatFlag::ROWS);
  reader.setComment(&quot;#&quot;);
  reader.read();

  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {{0, 1, 2, 3}, {0, 4, 5, 6}};
  EXPECT_EQ(reader.getData(), gold);
  EXPECT_EQ(reader.getData(&quot;row_0&quot;), gold[0]);
  EXPECT_EQ(reader.getData(&quot;row_1&quot;), gold[1]);
}

TEST(DelimitedFileReader, AutoHeader)
{
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
    // Set the header flag to &quot;AUTO&quot;, which is the default, but this is what is being tested
    reader.setHeaderFlag(MooseUtils::DelimitedFileReader::HeaderFlag::AUTO);
    reader.read();

    std::vector&lt;std::vector&lt;double&gt;&gt; gold = {
        {1980, 1980, 2011, 2013}, {6, 10, 5, 5}, {24, 9, 1, 15}};
    EXPECT_EQ(reader.getData(), gold);
    EXPECT_EQ(reader.getData(&quot;year&quot;), gold[0]);
    EXPECT_EQ(reader.getData(&quot;month&quot;), gold[1]);
    EXPECT_EQ(reader.getData(&quot;day&quot;), gold[2]);
  }

  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
    reader.setHeaderFlag(MooseUtils::DelimitedFileReader::HeaderFlag::ON);
    reader.read();

    std::vector&lt;std::vector&lt;double&gt;&gt; gold = {
        {1980, 1980, 2011, 2013}, {6, 10, 5, 5}, {24, 9, 1, 15}};
    EXPECT_EQ(reader.getData(), gold);
    EXPECT_EQ(reader.getData(&quot;year&quot;), gold[0]);
    EXPECT_EQ(reader.getData(&quot;month&quot;), gold[1]);
    EXPECT_EQ(reader.getData(&quot;day&quot;), gold[2]);
  }

  try
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example.csv&quot;);
    reader.setHeaderFlag(MooseUtils::DelimitedFileReader::HeaderFlag::OFF);
    reader.read();
    FAIL();
  }
  catch (const std::exception &amp; err)
  {
    std::string gold = &quot;Failed to convert a delimited data into double when reading line 1&quot;;
    std::size_t pos = std::string(err.what()).find(gold);
    ASSERT_TRUE(pos != std::string::npos);
  }
}

TEST(DelimitedFileReader, AutoNoHeader)
{
  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_no_header.csv&quot;);
    // Set the header flag to &quot;AUTO&quot;, which is the default, but this is what is being tested
    reader.setHeaderFlag(MooseUtils::DelimitedFileReader::HeaderFlag::AUTO);
    reader.read();

    std::vector&lt;std::vector&lt;double&gt;&gt; gold = {
        {1980, 1980, 2011, 2013}, {6, 10, 5, 5}, {24, 9, 1, 15}};
    EXPECT_EQ(reader.getData(), gold);
    EXPECT_EQ(reader.getData(&quot;column_0&quot;), gold[0]);
    EXPECT_EQ(reader.getData(&quot;column_1&quot;), gold[1]);
    EXPECT_EQ(reader.getData(&quot;column_2&quot;), gold[2]);
  }

  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_no_header.csv&quot;);
    reader.setHeaderFlag(MooseUtils::DelimitedFileReader::HeaderFlag::OFF);
    reader.read();

    std::vector&lt;std::vector&lt;double&gt;&gt; gold = {
        {1980, 1980, 2011, 2013}, {6, 10, 5, 5}, {24, 9, 1, 15}};
    EXPECT_EQ(reader.getData(), gold);
    EXPECT_EQ(reader.getData(&quot;column_0&quot;), gold[0]);
    EXPECT_EQ(reader.getData(&quot;column_1&quot;), gold[1]);
    EXPECT_EQ(reader.getData(&quot;column_2&quot;), gold[2]);
  }

  {
    MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_no_header.csv&quot;);
    reader.setHeaderFlag(MooseUtils::DelimitedFileReader::HeaderFlag::ON);
    reader.read();

    std::vector&lt;std::vector&lt;double&gt;&gt; gold = {{1980, 2011, 2013}, {10, 5, 5}, {9, 1, 15}};
    EXPECT_EQ(reader.getData(), gold);
    EXPECT_EQ(reader.getData(&quot;1980&quot;), gold[0]);
    EXPECT_EQ(reader.getData(&quot;6&quot;), gold[1]);
    EXPECT_EQ(reader.getData(&quot;24&quot;), gold[2]);
    EXPECT_EQ(reader.getNames(), std::vector&lt;std::string&gt;({&quot;1980&quot;, &quot;6&quot;, &quot;24&quot;}));
  }
}

TEST(DelimitedFileReader, ExtraSpace)
{
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_extra_space.csv&quot;);
  reader.read();

  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {
      {0, 10, 100, 1000}, {1, 11, 101, 1001}, {2, 12, 102, 1002}};
  EXPECT_EQ(reader.getData(), gold);
  EXPECT_EQ(reader.getData(&quot;column_0&quot;), gold[0]);
  EXPECT_EQ(reader.getData(&quot;column_1&quot;), gold[1]);
  EXPECT_EQ(reader.getData(&quot;column_2&quot;), gold[2]);
}

TEST(DelimitedFileReader, Tabs)
{
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_tab.csv&quot;);
  reader.read();
  EXPECT_EQ(reader.getData(), std::vector&lt;std::vector&lt;double&gt;&gt;({{-500, -499}, {0.023, 0.024}}));
}

TEST(DelimitedFileReader, Scientific)
{
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_sci.csv&quot;);
  reader.read();
  std::vector&lt;std::vector&lt;double&gt;&gt; gold = {{0, 1000, 2000, 5000, 5100},
                                           {0, 20000, 0, 20000, 30000}};
  EXPECT_EQ(reader.getData(), gold);
}

TEST(DelimitedFileReader, Empty)
{
  MooseUtils::DelimitedFileReader reader(&quot;data/csv/example_empty.csv&quot;);
  reader.read();
  EXPECT_EQ(reader.getData(), std::vector&lt;std::vector&lt;double&gt;&gt;());
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="2b3f4496-4f4b-4bea-b7c5-90bd652df33f"><div class="modal-content"><h4>(moose/framework/src/vectorpostprocessors/CSVReader.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// STL includes
#include &lt;fstream&gt;

// MOOSE includes
#include &quot;CSVReader.h&quot;
#include &quot;MooseUtils.h&quot;

registerMooseObject(&quot;MooseApp&quot;, CSVReader);

InputParameters
CSVReader::validParams()
{
  InputParameters params = GeneralVectorPostprocessor::validParams();
  params.addClassDescription(
      &quot;Converts columns of a CSV file into vectors of a VectorPostprocessor.&quot;);
  params.addRequiredParam&lt;FileName&gt;(&quot;csv_file&quot;,
                                    &quot;The name of the CSV file to read. Currently, with &quot;
                                    &quot;the exception of the header row, only numeric &quot;
                                    &quot;values are supported.&quot;);
  params.addParam&lt;bool&gt;(&quot;header&quot;,
                        &quot;When true it is assumed that the first row contains column headers, these &quot;
                        &quot;headers are used as the VectorPostprocessor vector names. If false the &quot;
                        &quot;file is assumed to contain only numbers and the vectors are named &quot;
                        &quot;automatically based on the column number (e.g., &#x27;column_0000&#x27;, &quot;
                        &quot;&#x27;column_0001&#x27;). If not supplied the reader attempts to auto detect the &quot;
                        &quot;headers.&quot;);
  params.addParam&lt;std::string&gt;(&quot;delimiter&quot;,
                               &quot;The column delimiter. Despite the name this can read files &quot;
                               &quot;separated by delimiter other than a comma. If this options is &quot;
                               &quot;omitted it will read comma or space separated files.&quot;);
  params.addParam&lt;bool&gt;(
      &quot;ignore_empty_lines&quot;, true, &quot;When true new empty lines in the file are ignored.&quot;);
  params.set&lt;bool&gt;(&quot;contains_complete_history&quot;) = true;
  params.suppressParameter&lt;bool&gt;(&quot;contains_complete_history&quot;);
  params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true) = EXEC_NONE;
  params.suppressParameter&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);

  // The value from this VPP is naturally already on every processor
  // TODO: Make this not the case!  See #11415
  params.set&lt;bool&gt;(&quot;_auto_broadcast&quot;) = false;

  return params;
}

CSVReader::CSVReader(const InputParameters &amp; params) : GeneralVectorPostprocessor(params)
{
  /// The MOOSE delimited file reader.
  MooseUtils::DelimitedFileReader csv_reader(getParam&lt;FileName&gt;(&quot;csv_file&quot;), &amp;_communicator);
  csv_reader.setIgnoreEmptyLines(getParam&lt;bool&gt;(&quot;ignore_empty_lines&quot;));
  if (isParamValid(&quot;header&quot;))
    csv_reader.setHeaderFlag(getParam&lt;bool&gt;(&quot;header&quot;)
                                 ? MooseUtils::DelimitedFileReader::HeaderFlag::ON
                                 : MooseUtils::DelimitedFileReader::HeaderFlag::OFF);
  if (isParamValid(&quot;delimiter&quot;))
    csv_reader.setDelimiter(getParam&lt;std::string&gt;(&quot;delimiter&quot;));

  csv_reader.read();
  const std::vector&lt;std::string&gt; &amp; names = csv_reader.getNames();
  const std::vector&lt;std::vector&lt;double&gt;&gt; &amp; data = csv_reader.getData();
  for (std::size_t i = 0; i &lt; data.size(); ++i)
  {
    _column_data[names[i]] = &amp;declareVector(names[i]);
    _column_data[names[i]]-&gt;assign(data[i].begin(), data[i].end());
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#ba6f4e5e-4c85-4309-9f63-1943c40963ce" class="tooltipped" data-position="left" data-tooltip="DelimitedFileReader">DelimitedFileReader</a></li><li><a href="#4a4b1047-afbf-4162-a46a-cb9199e3820c" class="tooltipped" data-position="left" data-tooltip="Tensor Operators">Tensor Operators</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>