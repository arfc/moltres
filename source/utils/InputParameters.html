<!DOCTYPE html><head><meta charset="UTF-8"><title>InputParameters | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="46b91aa3-9079-4df7-a375-7071ca1c4900" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="93013f06-131b-4a0c-ab74-6f29e8373556" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b2e4edcc-cda1-43be-b419-6b970717c802" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="444e4dc1-4a7f-4ceb-9216-3fcb55703e84"><i class="material-icons">menu</i></a><ul class="sidenav" id="444e4dc1-4a7f-4ceb-9216-3fcb55703e84"><li><a href="#!" class="dropdown-trigger" data-target="6f5e7cce-fa16-4991-86e7-dd4788d0caca" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="6f3293de-93e7-45ca-ba09-3ce1683eb0d1" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="60901b18-6f0b-4758-b5ff-4952207d368c" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="46b91aa3-9079-4df7-a375-7071ca1c4900"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="93013f06-131b-4a0c-ab74-6f29e8373556"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="b2e4edcc-cda1-43be-b419-6b970717c802"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="6f5e7cce-fa16-4991-86e7-dd4788d0caca"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="6f3293de-93e7-45ca-ba09-3ce1683eb0d1"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="60901b18-6f0b-4758-b5ff-4952207d368c"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">utils</span><a href="#" class="breadcrumb">InputParameters</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="08b032be-bfc1-4393-8b6a-17e355a577d9" data-section-level="1" data-section-text="InputParameters"><h1 id="inputparameters">InputParameters</h1><p>To simplify and unify the creation of all simulation objects in MOOSE, all input parameters must be declared and populated through a single &quot;InputParameters&quot; object. This ensures that every constructor in MOOSE is uniform and ensures that every object can be created through MOOSE&#x27;s Factory pattern. The InputParameters object is a collection of parameters, each one with seperate attributes that can be used to finely control the behavior of the underlying object. For example, parameters can be marked as required or optional, be provided with a default or not, and be used to enhance GUI interfaces that may be used to programmatically generate input files for MOOSE.</p><p>The complete list of attributes for each input parameter:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  struct Metadata
  {
    std::string _doc_string;
    /// The custom type that will be printed in the YAML dump for a parameter if supplied
    std::string _custom_type;
    std::vector&lt;std::string&gt; _cli_flag_names;
    /// The names of the parameters organized into groups
    std::string _group;
    /// The map of functions used for range checked parameters
    std::string _range_function;
    /// directions for auto build vectors (base_, 5) -&gt; &quot;base_0 base_1 base_2 base_3 base_4&quot;)
    std::pair&lt;std::string, std::string&gt; _autobuild_vecs;
    /// True for parameters that are required (i.e. will cause an abort if not supplied)
    bool _required = false;
    /**
     * Whether the parameter is either explicitly set or provided a default value when added
     * Note: We do not store MooseEnum names in valid params, instead we ask MooseEnums whether
     *       they are valid or not.
     */
    bool _valid = false;
    /// The set of parameters that will NOT appear in the the dump of the parser tree
    bool _is_private = false;
    bool _have_coupled_default = false;
    /// The default value for optionally coupled variables
    std::vector&lt;Real&gt; _coupled_default = {0};
    /// True if a parameters value was set by addParam, and not set again.
    bool _set_by_add_param = false;
    /// The reserved option names for a parameter
    std::set&lt;std::string&gt; _reserved_values;
    /// If non-empty, this parameter is deprecated.
    std::string _deprecation_message;
    /// original location of parameter (i.e. filename,linenum) - used for nice error messages.
    std::string _input_location;
    /// full HIT path of the parameter from the input file - used for nice error messages.
    std::string _param_fullpath;
    /// raw token text for a parameter - usually only set for filepath type params.
    std::string _raw_val;
    /// True if the parameters is controllable
    bool _controllable = false;
    /// Controllable execute flag restriction
    std::set&lt;ExecFlagType&gt; _controllable_flags;
    /// whether user setting of this parameter should be ignored
    bool _ignore = false;
  };
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#0848085c-ae59-4764-ae81-1f08fea1e03b">(moose/framework/include/utils/InputParameters.h)</a><section class="scrollspy" id="93205266-a7ac-4d86-9186-3bfa617710a5" data-section-level="2" data-section-text="Applying or Transferring Common Parameters"><h2 id="applying-or-transferring-common-parameters">Applying or Transferring Common Parameters</h2><p>When building a custom Action, it is often useful to read in several parameters that will be used to directly set parameters on objects being built by the custom Action. The <code>InputParameters</code> object contains a few useful methods for applying or transferring common parameters to avoid several manual lines for setting these parameters. See the utility methods and corresponding documentation here:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  // BEGIN APPLY PARAMETER METHODS
  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param exclude A vector of parameters to exclude
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applyParameters(const InputParameters &amp; common,
                       std::vector&lt;std::string&gt; exclude = std::vector&lt;std::string&gt;());

  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param include A vector of parameters to apply
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applySpecificParameters(const InputParameters &amp; common,
                               const std::vector&lt;std::string&gt; &amp; include,
                               bool allow_private = false);

  /**
   * Apply values from a single parameter in common, to a single parameter stored in this object
   * @param common The set of InputParameters from which to extract parameters from
   * @param common_name The name within common from which to get the parameter values
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   */
  void applyParameter(const InputParameters &amp; common,
                      const std::string &amp; common_name,
                      bool allow_private = false);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#8f5e857f-26ca-458c-b583-06e373c7a85b">(moose/framework/include/utils/InputParameters.h)</a></section><section class="scrollspy" id="9f58781f-7d0b-4122-b63f-98b23b1b9c52" data-section-level="2" data-section-text="Range Checked Parameters"><h2 id="range-checked-parameters">Range Checked Parameters</h2><p>The InputParameters object supports parsed expressions for various bounds checking of the user input so that custom logic does not need to be implemented in every end-user object. The range checking expression is always the second to last paramter right before the doc string.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  // BEGIN RANGE CHECKED PARAMETER METHODS
  /**
   * These methods add an range checked parameters. A lower and upper bound can be supplied and the
   * supplied parameter will be checked to fall within that range.
   */
  template &lt;typename T&gt;
  void addRequiredRangeCheckedParam(const std::string &amp; name,
                                    const std::string &amp; parsed_function,
                                    const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const T &amp; value,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ba51003c-5852-4958-ab55-5ce0b18b7491">(moose/framework/include/utils/InputParameters.h)</a></section><section class="scrollspy" id="2c1209bb-f948-4c98-8b01-bc74498c9181" data-section-level="2" data-section-text="Deprecating coupled variables"><h2 id="deprecating-coupled-variables">Deprecating coupled variables</h2><p>The <code>InputParameters</code> class provides a convenient method for deprecating coupled variable names called <code>addDeprecatedCoupledVar</code>. The method takes three arguments. The first corresponds to the deprecated name; the second argument is the new, blessed name that users should use. This name should have a corresponding <code>params.addCoupledVar(&#x27;blessed_name&#x27;, &#x27;blessed_name_doc_string&#x27;)</code> in the relevant <code>Class::validParams()</code> block. The final optional argument is the date that the deprecated variable name will be removed. </p></section></section><div class="moose-modal modal" id="0848085c-ae59-4764-ae81-1f08fea1e03b"><div class="modal-content"><h4>(moose/framework/include/utils/InputParameters.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;MooseUtils.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;MultiMooseEnum.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;Conversion.h&quot;

#include &quot;libmesh/parameters.h&quot;

#ifdef LIBMESH_HAVE_FPARSER
#include &quot;libmesh/fparser.hh&quot;
#else
template &lt;typename T&gt;
class FunctionParserBase
{
}
#endif

#include &lt;tuple&gt;
#include &lt;unordered_map&gt;

// Forward declarations
class Action;
class InputParameters;
class MooseEnum;
class MooseObject;
class MultiMooseEnum;
class Problem;

/**
 * The main MOOSE class responsible for handling user-defined
 * parameters in almost every MOOSE system.
 */
class InputParameters : public Parameters
{
public:
  InputParameters(const InputParameters &amp; rhs);
  InputParameters(const Parameters &amp; rhs);

  virtual ~InputParameters() = default;

  virtual void clear() override;

  /**
   * This method adds a description of the class that will be displayed
   * in the input file syntax dump
   */
  void addClassDescription(const std::string &amp; doc_string);

  /**
   * Returns the class description
   */
  std::string getClassDescription() const;

  /**
   * Override from libMesh to set user-defined attributes on our parameter
   */
  virtual void set_attributes(const std::string &amp; name, bool inserted_only) override;

  /// This functions is called in set as a &#x27;callback&#x27; to avoid code duplication
  template &lt;typename T&gt;
  void setHelper(const std::string &amp; name);

  /**
   * Returns a writable reference to the named parameters.  Note: This is not a virtual
   * function! Use caution when comparing to the parent class implementation
   * @param name The name of the parameter to set
   * @param quiet_mode When true the parameter is kept with set_by_add_param=true,
   * this is generally not needed.
   *
   * &quot;quite_mode&quot; returns a writable reference to the named parameter, without setting
   * set_by_add_param to false. Using this method of set will make the parameter to continue to
   * behave if its value where set ONLY by addParam and not by any other method.
   *
   * This was added for handling parameters in the Output objects that have behavior dependent
   * on whether the user modified the parameters.
   *
   */
  template &lt;typename T&gt;
  T &amp; set(const std::string &amp; name, bool quiet_mode = false);

  /**
   * Given a series of parameters names and values, sets each name to
   * the corresponding value.  Any number of name, value pairs can be
   * supplied.
   *
   * Note that each \p value must be of the correct type for the
   * parameter of that name, not merely of a type convertible to the
   * correct type.
   *
   * @param name The name of the first parameter to set
   */
  template &lt;typename T, typename... Ts&gt;
  void setParameters(const std::string &amp; name, const T &amp; value, Ts... extra_input_parameters);

  /**
   * Runs a range on the supplied parameter if it exists and throws an error if that check fails.
   * @returns Boolean indicating whether range check exists
   */
  template &lt;typename T, typename UP_T&gt;
  void rangeCheck(const std::string &amp; full_name,
                  const std::string &amp; short_name,
                  InputParameters::Parameter&lt;T&gt; * param,
                  std::ostream &amp; oss = Moose::out);
  template &lt;typename T, typename UP_T&gt;
  void rangeCheck(const std::string &amp; full_name,
                  const std::string &amp; short_name,
                  InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; * param,
                  std::ostream &amp; oss = Moose::out);

  /**
   * Verifies that the requested parameter exists and is not NULL and returns it to the caller.
   * The template parameter must be a pointer or an error will be thrown.
   */
  template &lt;typename T&gt;
  T getCheckedPointerParam(const std::string &amp; name, const std::string &amp; error_string = &quot;&quot;) const;

  /**
   * This method adds a parameter and documentation string to the InputParameters
   * object that will be extracted from the input file.  If the parameter is
   * missing in the input file, and error will be thrown
   */
  template &lt;typename T&gt;
  void addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This version of addRequiredParam is here for a consistent use with MooseEnums.  Use of
   * this function for any other type will throw an error.
   */
  template &lt;typename T&gt;
  void
  addRequiredParam(const std::string &amp; name, const T &amp; moose_enum, const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add an option parameter and a documentation string to the InputParameters object.
   * The first version of this function takes a default value which is used if the parameter is not
   * found in the input file. The second method will leave the parameter uninitialized but can be
   * checked with &quot;isParamValid&quot; before use.
   */
  template &lt;typename T, typename S&gt;
  void addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name, const std::string &amp; doc_string);
  ///@}

  ///@{
  // BEGIN RANGE CHECKED PARAMETER METHODS
  /**
   * These methods add an range checked parameters. A lower and upper bound can be supplied and the
   * supplied parameter will be checked to fall within that range.
   */
  template &lt;typename T&gt;
  void addRequiredRangeCheckedParam(const std::string &amp; name,
                                    const std::string &amp; parsed_function,
                                    const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const T &amp; value,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  // END RANGE CHECKED PARAMETER METHODS
  ///@}

  /**
   * These methods add an option parameter and with a customer type to the InputParameters object.
   * The custom
   * type will be output in YAML dumps and can be used within the GUI application.
   */
  template &lt;typename T&gt;
  void addRequiredCustomTypeParam(const std::string &amp; name,
                                  const std::string &amp; custom_type,
                                  const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);

  /**
   * These method add a parameter to the InputParameters object which can be retrieved like any
   * other parameter. This parameter however is not printed in the Input file syntax dump or web
   * page dump so does not take a documentation string.  The first version of this function takes an
   * optional default value.
   */
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name, const T &amp; value);
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name);

  /**
   * Add parameters for retrieval from the command line.
   *
   * NOTE: This ONLY works for App objects!  This is not valid for normal MOOSE objects!
   *
   * @param name The name of the parameter
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addRequiredCommandLineParam(const std::string &amp; name,
                                   const std::string &amp; syntax,
                                   const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const T &amp; value,
                           const std::string &amp; doc_string);

  /**
   * @param name The name of the parameter
   * @param value The default value of this parameter if it requires one
   * @param doc_string Documentation.  This will be shown for --help
   * @param deprecation_message The message that will will print about why this param was
   * deprecated.  It might mention the &quot;new way&quot;.
   */
  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  /**
   * This method checks to make sure that we aren&#x27;t adding a parameter with the same name but a
   * different type.  It
   * throws a MooseError if an inconsistent type is detected. While this state is supported by
   * libMesh it brings
   * nothing but blood and tears for those who try ;)
   *
   * @param name the name of the parameter
   */
  template &lt;typename T&gt;
  void checkConsistentType(const std::string &amp; name) const;

  /**
   * Get the syntax for a command-line parameter
   */
  std::vector&lt;std::string&gt; getSyntax(const std::string &amp; name) const;

  /**
   * Get the documentation string for a parameter
   */
  const std::string &amp; getDescription(const std::string &amp; name) const;

  /**
   * This method takes a space delimited list of parameter names and adds them to the specified
   * group name.
   * This information is used in the GUI to group parameters into logical sections.
   */
  void addParamNamesToGroup(const std::string &amp; space_delim_names, const std::string group_name);

  /**
   * This method retrieves the group name for the passed parameter name if one exists.  Otherwise an
   * empty string is returned.
   */
  std::string getGroupName(const std::string &amp; param_name) const;

  /**
   * This method suppresses an inherited parameter so that it isn&#x27;t required or valid
   * in the derived class. The parameter is added to the private parameter list.
   * Suppressing a parameter can have dire consequences.
   * Use at your own risk!
   */
  template &lt;typename T&gt;
  void suppressParameter(const std::string &amp; name);

  /**
   * Changes the parameter to be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamRequired(const std::string &amp; name);

  /**
   * Changes the parameter to not be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   */
  void addCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This method adds a deprecated coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found. The doc string for the deprecated variable will be
   * constructed from the doc string for the new variable. A deprecation message will also be
   * automatically generated
   */
  void addDeprecatedCoupledVar(const std::string &amp; old_name,
                               const std::string &amp; new_name,
                               const std::string &amp; removal_date = &quot;&quot;);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a default value for this variable in the case that an actual variable is
   * not provided.
   */
  void addCoupledVar(const std::string &amp; name, const Real value, const std::string &amp; doc_string);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a vector of values for this variable in the case that an actual variable
   * is not provided.
   */
  void addCoupledVar(const std::string &amp; name,
                     const std::vector&lt;Real&gt; &amp; value,
                     const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add a coupled variable name pair. The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found.
   *
   * This version of the method will build a vector if the given the base_name and num_name
   * parameters exist
   * in the input file:
   *   e.g.
   *   [./foo]
   *     ...
   *     some_base = base_
   *     some_num  = 5
   *   [../]
   *
   *   # The coupling parameter will be passed this vector: &quot;base_0 base_1 base_2 base_3 base_4&quot;
   */
  void addCoupledVarWithAutoBuild(const std::string &amp; name,
                                  const std::string &amp; base_name,
                                  const std::string &amp; num_name,
                                  const std::string &amp; doc_string);
  void addRequiredCoupledVarWithAutoBuild(const std::string &amp; name,
                                          const std::string &amp; base_name,
                                          const std::string &amp; num_name,
                                          const std::string &amp; doc_string);
  ///@}

  /**
   * Utility functions for retrieving one of the MooseTypes variables into the common &quot;string&quot; base
   * class.
   * Scalar and Vector versions are supplied
   */
  std::string getMooseType(const std::string &amp; name) const;
  std::vector&lt;std::string&gt; getVecMooseType(const std::string &amp; name) const;

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable.  If the coupled variable is not supplied in the input
   * file, and error is thrown.
   *
   * Version 2: An auto built vector will be built from the base_name and num_name param. See
   * addCoupledVar for an example
   */
  void addRequiredCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * Returns the documentation string for the specified parameter name
   */
  std::string getDocString(const std::string &amp; name) const;

  /**
   * Set the doc string of a parameter.
   *
   * This method is generally used from within the validParams function to modify the documentation
   * for an
   * existing parameter, such as a parameter that is supplied from an interface class.
   */
  void setDocString(const std::string &amp; name, const std::string &amp; doc);

  /**
   * Returns a boolean indicating whether the specified parameter is required or not
   */
  bool isParamRequired(const std::string &amp; name) const;

  /**
   * This method returns parameters that have been initialized in one fashion or another,
   * i.e. The value was supplied as a default argument or read and properly converted from
   * the input file
   */
  bool isParamValid(const std::string &amp; name) const;

  /**
   * Returns whether or not the parameter was set due to addParam. If not then it was either set
   * programmatically
   * or was read through the input file.
   */
  bool isParamSetByAddParam(const std::string &amp; name) const;

  /**
   * Returns True if the parameters is deprecated.
   */
  bool isParamDeprecated(const std::string &amp; name) const;

  /**
   * This method returns true if all of the parameters in this object are valid
   * (i.e. isParamValid(name) == true - for all parameters)
   */
  bool areAllRequiredParamsValid() const;

  /**
   * Prints the type of the requested parameter by name
   */
  std::string type(const std::string &amp; name) const;

  /**
   * Returns a Boolean indicating whether the specified parameter is private or not
   */
  bool isPrivate(const std::string &amp; name) const;

  /**
   * Declare the given parameters as controllable
   */
  void declareControllable(const std::string &amp; name, std::set&lt;ExecFlagType&gt; execute_flags = {});

  /**
   * Marker a parameter that has been changed by the Control system (this is for output purposes)
   */
  void markControlled(const std::string &amp; name);

  /**
   * Returns a Boolean indicating whether the specified parameter is controllable
   */
  bool isControllable(const std::string &amp; name) const;

  /**
   * Return the allowed execute flags for a controllable parameter
   */
  const std::set&lt;ExecFlagType&gt; &amp; getControllableExecuteOnTypes(const std::string &amp; name) const;

  /**
   * This method must be called from every base &quot;Moose System&quot; to create linkage with the Action
   * System.
   * See &quot;Moose.C&quot; for the registerMooseObjectTask() calls.
   */
  void registerBase(const std::string &amp; value);

  /**
   * This method is used to define the MOOSE system name that is used by the TheWarehouse object
   * for storing objects to be retrieved for execution. The base class of every object class
   * that will be called for execution (e.g., UserObject objects) should call this method.
   *
   * This is different from registerBase because the name supplied to registerBase is used to
   * associate syntax, but the objects created often go to the same objects for execution, as is
   * the case for Postprocessor object which are executed with UserObjects.
   *
   * See the AttribSystem object for use Attribute.h/C.
   */
  void registerSystemAttributeName(const std::string &amp; value);

  /**
   * This method is here to indicate which Moose types a particular Action may build. It takes a
   * space delimited list of registered MooseObjects.  TODO: For now we aren&#x27;t actually checking
   * this list when we build objects. Since individual actions can do whatever they want it&#x27;s not
   * exactly trivial to check this without changing the user API.  This function properly restricts
   * the syntax and YAML dumps.
   */
  void registerBuildableTypes(const std::string &amp; names);

  /**
   * Tells MOOSE about a RelationshipManager that this object needs.  RelationshipManagers
   * handle element &quot;ghosting&quot;, &quot;non-local DOF access&quot; and &quot;sparsity pattern&quot; relationships.
   *
   * Basically: if this object needs non-local (ie non-current-element) data access then you
   * probably need a relationship manager
   *
   * @param name The name of the RelationshipManager type
   * @param rm_type The type (GEOMETRIC/ALGEBRAIC) of the RelationshipManger.  Note: You can use
   * boolean logic to to &quot;or&quot; RelationshipManagerTypes together to make a RelationshipManager that
   * is multi-typed.
   * @param input_parameter_callback This is a function pointer that will get called to fill in the
   * RelationShipManager&#x27;s InputParameters.  See MooseTypes.h for the signature of this function.
   */
  void addRelationshipManager(
      const std::string &amp; name,
      Moose::RelationshipManagerType rm_type,
      Moose::RelationshipManagerInputParameterCallback input_parameter_callback = nullptr);

  /**
   * Clears all currently registered RelationshipManagers
   */
  void clearRelationshipManagers() { _buildable_rm_types.clear(); }

  /**
   * Returns the list of buildable types as a std::vector&lt;std::string&gt;
   */
  const std::vector&lt;std::string&gt; &amp; getBuildableTypes() const;

  /**
   * Returns the list of buildable (or required) RelationshipManager object types for this object.
   */
  const std::vector&lt;std::tuple&lt;std::string,
                               Moose::RelationshipManagerType,
                               Moose::RelationshipManagerInputParameterCallback&gt;&gt; &amp;
  getBuildableRelationshipManagerTypes() const;

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void collapseSyntaxNesting(bool collapse);
  bool collapseSyntaxNesting() const;
  ///@}

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void mooseObjectSyntaxVisibility(bool visibility);
  bool mooseObjectSyntaxVisibility() const;
  ///@}

  ///@{
  /**
   * Copy and Copy/Add operators for the InputParameters object
   */
  using Parameters::operator=;
  using Parameters::operator+=;
  InputParameters &amp; operator=(const InputParameters &amp; rhs);
  InputParameters &amp; operator+=(const InputParameters &amp; rhs);
  ///@}

  /**
   * This function checks parameters stored in the object to make sure they are in the correct
   * state as the user expects:
   *   Required parameters are verified as valid meaning that they were either initialized when
   *   they were created, or were read from an input file or some other valid source
   */
  void checkParams(const std::string &amp; parsing_syntax);

  /**
   * Methods returning iterators to the coupled variables names stored in this
   * InputParameters object
   */
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsBegin() const
  {
    return _coupled_vars.begin();
  }
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsEnd() const
  {
    return _coupled_vars.end();
  }

  /**
   * Return the coupled variable parameter names.
   */
  const std::set&lt;std::string&gt; &amp; getCoupledVariableParamNames() const { return _coupled_vars; }

  /**
   * Return the new to deprecated variable name map
   */
  const std::unordered_map&lt;std::string, std::string&gt; &amp; getNewToDeprecatedVarMap() const
  {
    return _new_to_deprecated_coupled_vars;
  }

  /**
   * Return whether or not the coupled variable exists
   * @param coupling_name The name of the coupled variable to test for
   * @return True if the variable exists in the coupled variables for this InputParameters object
   */
  bool hasCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Return whether or not the requested parameter has a default coupled value.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  bool hasDefaultCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Get the default value for an optionally coupled variable.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  Real defaultCoupledValue(const std::string &amp; coupling_name, unsigned int i = 0) const;

  /**
   * Get the number of defaulted coupled value entries
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  unsigned int numberDefaultCoupledValues(const std::string &amp; coupling_name) const;

  /**
   * Set the default value for an optionally coupled variable (called by the Parser).
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param value Default value to set.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  void defaultCoupledValue(const std::string &amp; coupling_name, Real value, unsigned int i = 0);

  /**
   * Returns the auto build vectors for all parameters.
   */
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; getAutoBuildVectors() const;

  // BEGIN APPLY PARAMETER METHODS
  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param exclude A vector of parameters to exclude
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applyParameters(const InputParameters &amp; common,
                       std::vector&lt;std::string&gt; exclude = std::vector&lt;std::string&gt;());

  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param include A vector of parameters to apply
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applySpecificParameters(const InputParameters &amp; common,
                               const std::vector&lt;std::string&gt; &amp; include,
                               bool allow_private = false);

  /**
   * Apply values from a single parameter in common, to a single parameter stored in this object
   * @param common The set of InputParameters from which to extract parameters from
   * @param common_name The name within common from which to get the parameter values
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   */
  void applyParameter(const InputParameters &amp; common,
                      const std::string &amp; common_name,
                      bool allow_private = false);
  // END APPLY PARAMETER METHODS

  /**
   * Apply properties of a single coupled variable in common, to a single coupled variable stored in
   * this object
   * @param common The set of InputParameters from which to extract the coupled variable&#x27;s
   * properties
   * @param var_name The name of the coupled variable whose properties are to be applied
   *
   * In order to apply the properties, both the local parameters and the common parameters must
   * have a coupled variable with name var_name
   */
  void applyCoupledVar(const InputParameters &amp; common, const std::string &amp; var_name);

  /**
   * Deprecated method.  Use isParamSetByUser() instead.
   */
  bool paramSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter was by the user
   * @param name The parameter name
   */
  bool isParamSetByUser(const std::string &amp; name) const;

  ///@{
  /*
   * These methods are here to retrieve parameters for scalar and vector types respectively. We will
   * throw errors
   * when returning most scalar types, but will allow retrieving empty vectors.
   */
  template &lt;typename T&gt;
  static const T &amp;
  getParamHelper(const std::string &amp; name, const InputParameters &amp; pars, const T * the_type);

  template &lt;typename T&gt;
  static const std::vector&lt;T&gt; &amp; getParamHelper(const std::string &amp; name,
                                               const InputParameters &amp; pars,
                                               const std::vector&lt;T&gt; * the_type);
  ///@}

  using Parameters::get;

  /// Combine two vector parameters into a single vector of pairs
  template &lt;typename R1,
            typename R2,
            typename V1 = typename std::conditional&lt;std::is_same&lt;R1, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R1&gt;&gt;::type,
            typename V2 = typename std::conditional&lt;std::is_same&lt;R2, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R2&gt;&gt;::type&gt;
  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; get(const std::string &amp; param1, const std::string &amp; param2) const;

  /**
   * Return list of controllable parameters
   */
  std::set&lt;std::string&gt; getControllableParameters() const;

  /**
   * Return names of parameters within a group.
   */
  std::set&lt;std::string&gt; getGroupParameters(const std::string &amp; group) const;

  /**
   * Provide a set of reserved values for a parameter. These are values that are in addition
   * to the normal set of values the parameter can take.
   */
  void setReservedValues(const std::string &amp; name, const std::set&lt;std::string&gt; &amp; reserved);

  /**
   * Get a set of reserved parameter values.
   * Returns a set by value since we can return an empty set.
   */
  std::set&lt;std::string&gt; reservedValues(const std::string &amp; name) const;

  ///@{
  /**
   * Get/set a string representing the location (i.e. filename,linenum) in the input text for the
   * block containing parameters for this object.
   */
  std::string &amp; blockLocation() { return _block_location; }
  const std::string &amp; blockLocation() const { return _block_location; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo&quot;) for the block containing parameters for this object.
   */
  std::string &amp; blockFullpath() { return _block_fullpath; }
  const std::string &amp; blockFullpath() const { return _block_fullpath; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the location in the input text the parameter originated from
   * (i.e. filename,linenum) for the given param.
   */
  const std::string &amp; inputLocation(const std::string &amp; param) const
  {
    return at(param)._input_location;
  }
  std::string &amp; inputLocation(const std::string &amp; param) { return at(param)._input_location; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo/bar&quot; for param &quot;bar&quot;) for the given param.
   */
  const std::string &amp; paramFullpath(const std::string &amp; param) const
  {
    return at(param)._param_fullpath;
  }
  std::string &amp; paramFullpath(const std::string &amp; param) { return at(param)._param_fullpath; }
  ///@}

  /// generate error message prefix with parameter name and location (if available)
  std::string errorPrefix(const std::string &amp; param) const;

  /**
   * Get/set a string representing the raw, unmodified token text for the given param.  This is
   * usually only set/useable for file-path type parameters.
   */
  std::string &amp; rawParamVal(const std::string &amp; param) { return _params[param]._raw_val; }
  const std::string &amp; rawParamVal(const std::string &amp; param) const
  {
    return _params.at(param)._raw_val;
  }

  /**
   * Informs this object that values for this parameter set from the input file or from the command
   * line should be ignored
   */
  template &lt;typename T&gt;
  void ignoreParameter(const std::string &amp; name);

  /**
   * Whether to ignore the value of an input parameter set in the input file or from the command
   * line.
   */
  bool shouldIgnore(const std::string &amp; name);

  /**
   * @returns True if the parameter with name \p name is of type T.
   */
  template &lt;typename T&gt;
  bool isType(const std::string &amp; name) const;

  /**
   * @returns True if these parameters were constructed using the legacy method.
   **/
  bool fromLegacyConstruction() const { return _from_legacy_construction; }

  /**
   * Determine the actual variable name from the given variable \emph parameter name
   * @param var_param_name the name of the variable parameter, e.g. &#x27;variable&#x27;
   * @param moose_object_with_var_param_name the name of the moose object holding the variable
   * parameter. Used for potential error messaging
   */
  std::string varName(const std::string &amp; var_param_name,
                      const std::string &amp; moose_object_with_var_param_name) const;

private:
  // Private constructor so that InputParameters can only be created in certain places.
  InputParameters();

  /**
   * Method to terminate the recursive setParameters definition
   */
  void setParameters() {}

  /**
   * Helper that uses overloading to distinguish adding commandline parameters of
   * a scalar and a vector kind. Vector parameters are options that may appear multiple
   * times on the command line (like -i).
   */
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const std::string &amp; doc_string,
                                 T *);
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const std::string &amp; doc_string,
                                 std::vector&lt;T&gt; *);

  /**
   * Private method for setting deprecated coupled variable documentation strings
   */
  void setDeprecatedVarDocString(const std::string &amp; new_name, const std::string &amp; doc_string);

  struct Metadata
  {
    std::string _doc_string;
    /// The custom type that will be printed in the YAML dump for a parameter if supplied
    std::string _custom_type;
    std::vector&lt;std::string&gt; _cli_flag_names;
    /// The names of the parameters organized into groups
    std::string _group;
    /// The map of functions used for range checked parameters
    std::string _range_function;
    /// directions for auto build vectors (base_, 5) -&gt; &quot;base_0 base_1 base_2 base_3 base_4&quot;)
    std::pair&lt;std::string, std::string&gt; _autobuild_vecs;
    /// True for parameters that are required (i.e. will cause an abort if not supplied)
    bool _required = false;
    /**
     * Whether the parameter is either explicitly set or provided a default value when added
     * Note: We do not store MooseEnum names in valid params, instead we ask MooseEnums whether
     *       they are valid or not.
     */
    bool _valid = false;
    /// The set of parameters that will NOT appear in the the dump of the parser tree
    bool _is_private = false;
    bool _have_coupled_default = false;
    /// The default value for optionally coupled variables
    std::vector&lt;Real&gt; _coupled_default = {0};
    /// True if a parameters value was set by addParam, and not set again.
    bool _set_by_add_param = false;
    /// The reserved option names for a parameter
    std::set&lt;std::string&gt; _reserved_values;
    /// If non-empty, this parameter is deprecated.
    std::string _deprecation_message;
    /// original location of parameter (i.e. filename,linenum) - used for nice error messages.
    std::string _input_location;
    /// full HIT path of the parameter from the input file - used for nice error messages.
    std::string _param_fullpath;
    /// raw token text for a parameter - usually only set for filepath type params.
    std::string _raw_val;
    /// True if the parameters is controllable
    bool _controllable = false;
    /// Controllable execute flag restriction
    std::set&lt;ExecFlagType&gt; _controllable_flags;
    /// whether user setting of this parameter should be ignored
    bool _ignore = false;
  };

  Metadata &amp; at(const std::string &amp; param)
  {
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params[param];
  }
  const Metadata &amp; at(const std::string &amp; param) const
  {
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params.at(param);
  }

  /**
   * Toggle the availability of the copy constructor
   *
   * When MooseObject is created via the Factory this flag is set to false, so when a MooseObject is
   * created if
   * the constructor is not a const reference an error is produced. This method allows the
   * InputParameterWarehouse
   * to disable copying.
   */
  void allowCopy(bool status) { _allow_copy = status; }

  /**
   * Make sure the parameter name doesn&#x27;t have any invalid characters.
   */
  void checkParamName(const std::string &amp; name) const;

  /**
   * This method is called when adding a Parameter with a default value, can be specialized for
   * non-matching types.
   */
  template &lt;typename T, typename S&gt;
  void setParamHelper(const std::string &amp; name, T &amp; l_value, const S &amp; r_value);

  /// original location of input block (i.e. filename,linenum) - used for nice error messages.
  std::string _block_location;

  /// full HIT path of the block from the input file - used for nice error messages.
  std::string _block_fullpath;

  /// The actual parameter data. Each Metadata object contains attributes for the corresponding
  /// parameter.
  std::map&lt;std::string, Metadata&gt; _params;

  /// The coupled variables set
  std::set&lt;std::string&gt; _coupled_vars;

  /// The class description for the owning object. This string is used in many places including
  /// mouse-over events, and external documentation produced from the source code.
  std::string _class_description;

  /// The parameter is used to restrict types that can be built.  Typically this is used for
  /// MooseObjectAction derived Actions.
  std::vector&lt;std::string&gt; _buildable_types;

  /// The RelationshipManagers that this object may either build or require.
  /// The optional second argument may be supplied to &quot;downgrade&quot; the functionality of the corresponding
  /// relationship manager (e.g. An AlgebraicRelationshipManager could be only used as a
  /// GeometricRelationshipManager for a given simulation).
  std::vector&lt;std::tuple&lt;std::string,
                         Moose::RelationshipManagerType,
                         Moose::RelationshipManagerInputParameterCallback&gt;&gt;
      _buildable_rm_types;

  /// This parameter collapses one level of nesting in the syntax blocks.  It is used
  /// in conjunction with MooseObjectAction derived Actions.
  bool _collapse_nesting;

  /// This parameter hides derived MOOSE object types from appearing in syntax dumps
  bool _moose_object_syntax_visibility;

  /// Flag for disabling deprecated parameters message, this is used by applyParameters to avoid
  /// dumping messages.
  bool _show_deprecated_message;

  /// A flag for toggling the error message in the copy constructor.
  bool _allow_copy;

  /// Whether or not these parameters were constructed using legacy contruction (remove with #19440)
  bool _from_legacy_construction;

  /// A map from deprecated coupled variable names to the new blessed name
  std::unordered_map&lt;std::string, std::string&gt; _new_to_deprecated_coupled_vars;

  // These are the only objects allowed to _create_ InputParameters
  friend InputParameters emptyInputParameters();
  friend class InputParameterWarehouse;
  friend class Parser;
  // for the printInputFile function in the action warehouse
  friend class ActionWarehouse;

  // For setting _from_legacy_construction (remove with #19440)
  template &lt;typename T&gt;
  friend InputParameters validParams();
};

template &lt;typename T&gt;
void
InputParameters::setHelper(const std::string &amp; /*name*/)
{
}

// Template and inline function implementations
template &lt;typename T&gt;
T &amp;
InputParameters::set(const std::string &amp; name, bool quiet_mode)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; result = this-&gt;Parameters::set&lt;T&gt;(name);

  if (quiet_mode)
    _params[name]._set_by_add_param = true;

  setHelper&lt;T&gt;(name);

  return result;
}

template &lt;typename T, typename... Ts&gt;
void
InputParameters::setParameters(const std::string &amp; name,
                               const T &amp; value,
                               Ts... extra_input_parameters)
{
  this-&gt;set&lt;T&gt;(name) = value;
  this-&gt;setParameters(extra_input_parameters...);
}

template &lt;typename T, typename UP_T&gt;
void
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; * param,
                            std::ostream &amp; oss)
{
  mooseAssert(param, &quot;Parameter is NULL&quot;);

  if (!isParamValid(short_name) || _params[short_name]._range_function.empty())
    return;

  /**
   * Automatically detect the variables used in the range checking expression.
   * We allow the following variables (where snam is the short_name of the parameter)
   *
   * snam       : tests every component in the vector
   *              &#x27;snam &gt; 0&#x27;
   * snam_size  : the size of the vector
   *              &#x27;snam_size = 5&#x27;
   * snam_i     : where i is a number from 0 to sname_size-1 tests a specific component
   *              &#x27;snam_0 &gt; snam_1&#x27;
   */
  FunctionParserBase&lt;UP_T&gt; fp;
  std::vector&lt;std::string&gt; vars;
  if (fp.ParseAndDeduceVariables(_params[short_name]._range_function, vars) != -1) // -1 for success
  {
    oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
    return;
  }

  // Fparser parameter buffer
  std::vector&lt;UP_T&gt; parbuf(vars.size());

  // parameter vector
  const std::vector&lt;T&gt; &amp; value = param-&gt;set();

  // iterate over all vector values (maybe ;)
  bool need_to_iterate = false;
  unsigned int i = 0;
  do
  {
    // set parameters
    for (unsigned int j = 0; j &lt; vars.size(); j++)
    {
      if (vars[j] == short_name)
      {
        if (value.size() == 0)
        {
          oss &lt;&lt; &quot;Range checking empty vector: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
          return;
        }

        parbuf[j] = value[i];
        need_to_iterate = true;
      }
      else if (vars[j] == short_name + &quot;_size&quot;)
        parbuf[j] = value.size();
      else
      {
        if (vars[j].substr(0, short_name.size() + 1) != short_name + &quot;_&quot;)
        {
          oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
          return;
        }
        std::istringstream iss(vars[j]);
        iss.seekg(short_name.size() + 1);

        size_t index;
        if (iss &gt;&gt; index &amp;&amp; iss.eof())
        {
          if (index &gt;= value.size())
          {
            oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function
                &lt;&lt; &quot;\nOut of range variable &quot; &lt;&lt; vars[j] &lt;&lt; &#x27;\n&#x27;;
            return;
          }
          parbuf[j] = value[index];
        }
        else
        {
          oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function
              &lt;&lt; &quot;\nInvalid variable &quot; &lt;&lt; vars[j] &lt;&lt; &#x27;\n&#x27;;
          return;
        }
      }
    }

    // ensure range-checked input file parameter comparison functions
    // do absolute floating point comparisons instead of using a default epsilon.
    auto tmp_eps = fp.epsilon();
    fp.setEpsilon(0);
    UP_T result = fp.Eval(&amp;parbuf[0]);
    fp.setEpsilon(tmp_eps);

    // test function using the parameters determined above
    if (fp.EvalError())
    {
      oss &lt;&lt; &quot;Error evaluating expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
      return;
    }

    if (!result)
    {
      oss &lt;&lt; &quot;Range check failed for parameter &quot; &lt;&lt; full_name
          &lt;&lt; &quot;\n\tExpression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &quot;\n&quot;;
      if (need_to_iterate)
        oss &lt;&lt; &quot;\t Component: &quot; &lt;&lt; i &lt;&lt; &#x27;\n&#x27;;
    }

  } while (need_to_iterate &amp;&amp; ++i &lt; value.size());
}

template &lt;typename T, typename UP_T&gt;
void
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            InputParameters::Parameter&lt;T&gt; * param,
                            std::ostream &amp; oss)
{
  mooseAssert(param, &quot;Parameter is NULL&quot;);

  if (!isParamValid(short_name) || _params[short_name]._range_function.empty())
    return;

  // Parse the expression
  FunctionParserBase&lt;UP_T&gt; fp;
  if (fp.Parse(_params[short_name]._range_function, short_name) != -1) // -1 for success
  {
    oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
    return;
  }

  // ensure range-checked input file parameter comparison functions
  // do absolute floating point comparisons instead of using a default epsilon.
  auto tmp_eps = fp.epsilon();
  fp.setEpsilon(0);
  // We require a non-const value for the implicit upscaling of the parameter type
  std::vector&lt;UP_T&gt; value(1, param-&gt;set());
  UP_T result = fp.Eval(&amp;value[0]);
  fp.setEpsilon(tmp_eps);

  if (fp.EvalError())
  {
    oss &lt;&lt; &quot;Error evaluating expression: &quot; &lt;&lt; _params[short_name]._range_function
        &lt;&lt; &quot;\nPerhaps you used the wrong variable name?\n&quot;;
    return;
  }

  if (!result)
    oss &lt;&lt; &quot;Range check failed for parameter &quot; &lt;&lt; full_name
        &lt;&lt; &quot;\n\tExpression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &quot;\n\tValue: &quot; &lt;&lt; value[0]
        &lt;&lt; &#x27;\n&#x27;;
}

template &lt;typename T&gt;
T
InputParameters::getCheckedPointerParam(const std::string &amp; name,
                                        const std::string &amp; error_string) const
{
  T param = this-&gt;get&lt;T&gt;(name);

  // Note: You will receive a compile error on this line if you attempt to pass a non-pointer
  // template type to this method
  if (param == NULL)
    mooseError(&quot;Parameter &quot;, name, &quot; is NULL.\n&quot;, error_string);
  return this-&gt;get&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._required = true;
  _params[name]._doc_string = doc_string;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; /*name*/,
                                  const T &amp; /*value*/,
                                  const std::string &amp; /*doc_string*/)
{
  mooseError(&quot;You cannot call addRequiredParam and supply a default value for this type, please &quot;
             &quot;use addParam instead&quot;);
}

template &lt;typename T, typename S&gt;
void
InputParameters::addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; l_value = InputParameters::set&lt;T&gt;(name);
  _params[name]._doc_string = doc_string;

  // Set the parameter now
  setParamHelper(name, l_value, value);

  /* Indicate the default value, as set via addParam, is being used. The parameter is removed from
     the list whenever
     it changes, see set_attributes */
  _params[name]._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._doc_string = doc_string;
}

template &lt;typename T, typename S&gt;
void
InputParameters::setParamHelper(const std::string &amp; /*name*/, T &amp; l_value, const S &amp; r_value)
{
  l_value = r_value;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredRangeCheckedParam(const std::string &amp; name,
                                              const std::string &amp; parsed_function,
                                              const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const T &amp; value,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCustomTypeParam(const std::string &amp; name,
                                            const std::string &amp; custom_type,
                                            const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._is_private = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name, const T &amp; value)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::set&lt;T&gt;(name) = value;
  _params[name]._is_private = true;
  _params[name]._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCommandLineParam(const std::string &amp; name,
                                             const std::string &amp; syntax,
                                             const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const T &amp; value,
                                     const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::checkConsistentType(const std::string &amp; name) const
{
  // If we don&#x27;t currently have the Parameter, can&#x27;t be any inconsistency
  InputParameters::const_iterator it = _values.find(name);
  if (it == _values.end())
    return;

  // Now, if we already have the Parameter, but it doesn&#x27;t have the
  // right type, throw an error.
  if (!this-&gt;Parameters::have_parameter&lt;T&gt;(name))
    mooseError(&quot;Attempting to set parameter \&quot;&quot;,
               name,
               &quot;\&quot; with type (&quot;,
               demangle(typeid(T).name()),
               &quot;)\nbut the parameter already exists as type (&quot;,
               it-&gt;second-&gt;type(),
               &quot;)&quot;);
}

template &lt;typename T&gt;
void
InputParameters::suppressParameter(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to suppress nonexistent parameter: &quot;, name);

  _params[name]._required = false;
  _params[name]._is_private = true;
  _params[name]._controllable = false;
}

template &lt;typename T&gt;
void
InputParameters::ignoreParameter(const std::string &amp; name)
{
  suppressParameter&lt;T&gt;(name);
  _params[name]._ignore = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamRequired(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to require nonexistent parameter: &quot;, name);

  _params[name]._required = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamNotRequired(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to un-require nonexistent parameter: &quot;, name);

  _params[name]._required = false;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, value, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

// Forward declare MooseEnum specializations for add*Param
template &lt;&gt;
void InputParameters::addRequiredParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                  const MooseEnum &amp; moose_enum,
                                                  const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                       const MultiMooseEnum &amp; moose_enum,
                                                       const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                          const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                       const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                    const std::string &amp; doc_string,
                                                    const std::string &amp; deprecation_message);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                         const std::string &amp; doc_string,
                                                         const std::string &amp; deprecation_message);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::string &amp; doc_string,
    const std::string &amp; deprecation_message);

// Forward declare specializations for setParamHelper
template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, Real&gt;(const std::string &amp; name,
                                                              PostprocessorName &amp; l_value,
                                                              const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, int&gt;(const std::string &amp; name,
                                                             PostprocessorName &amp; l_value,
                                                             const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, Real&gt;(const std::string &amp; /*name*/,
                                                         FunctionName &amp; l_value,
                                                         const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, int&gt;(const std::string &amp; /*name*/,
                                                        FunctionName &amp; l_value,
                                                        const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, Real&gt;(const std::string &amp; /*name*/,
                                                                 MaterialPropertyName &amp; l_value,
                                                                 const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, int&gt;(const std::string &amp; /*name*/,
                                                                MaterialPropertyName &amp; l_value,
                                                                const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, Real&gt;(const std::string &amp; /*name*/,
                                                             MooseFunctorName &amp; l_value,
                                                             const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, int&gt;(const std::string &amp; /*name*/,
                                                            MooseFunctorName &amp; l_value,
                                                            const int &amp; r_value);

template &lt;typename T&gt;
const T &amp;
InputParameters::getParamHelper(const std::string &amp; name, const InputParameters &amp; pars, const T *)
{
  if (!pars.isParamValid(name))
    mooseError(&quot;The parameter \&quot;&quot;, name, &quot;\&quot; is being retrieved before being set.\n&quot;);

  return pars.get&lt;T&gt;(name);
}

// Declare specializations so we don&#x27;t fall back on the generic
// implementation, but the definition will be in InputParameters.C so
// we won&#x27;t need to bring in *MooseEnum header files here.
template &lt;&gt;
const MooseEnum &amp; InputParameters::getParamHelper&lt;MooseEnum&gt;(const std::string &amp; name,
                                                             const InputParameters &amp; pars,
                                                             const MooseEnum *);

template &lt;&gt;
const MultiMooseEnum &amp; InputParameters::getParamHelper&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                                       const InputParameters &amp; pars,
                                                                       const MultiMooseEnum *);

template &lt;typename T&gt;
const std::vector&lt;T&gt; &amp;
InputParameters::getParamHelper(const std::string &amp; name,
                                const InputParameters &amp; pars,
                                const std::vector&lt;T&gt; *)
{
  return pars.get&lt;std::vector&lt;T&gt;&gt;(name);
}

template &lt;typename R1, typename R2, typename V1, typename V2&gt;
std::vector&lt;std::pair&lt;R1, R2&gt;&gt;
InputParameters::get(const std::string &amp; param1, const std::string &amp; param2) const
{
  const auto &amp; v1 = get&lt;V1&gt;(param1);
  const auto &amp; v2 = get&lt;V2&gt;(param2);

  auto controllable = getControllableParameters();
  if (controllable.count(param1) || controllable.count(param2))
    mooseError(errorPrefix(param1),
               &quot; and/or &quot;,
               errorPrefix(param2) +
                   &quot; are controllable parameters and cannot be retireved using &quot;
                   &quot;the MooseObject::getParam/InputParameters::get methods for pairs&quot;);

  if (v1.size() != v2.size())
    mooseError(&quot;Vector parameters &quot;,
               errorPrefix(param1),
               &quot;(size: &quot;,
               v1.size(),
               &quot;) and &quot; + errorPrefix(param2),
               &quot;(size: &quot;,
               v2.size(),
               &quot;) are of different lengths \n&quot;);

  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; parameter_pairs;
  auto i1 = v1.begin();
  auto i2 = v2.begin();
  for (; i1 != v1.end() &amp;&amp; i2 != v2.end(); ++i1, ++i2)
    parameter_pairs.emplace_back(std::make_pair(*i1, *i2));
  return parameter_pairs;
}

InputParameters emptyInputParameters();

template &lt;typename T&gt;
bool
InputParameters::isType(const std::string &amp; name) const
{
  if (!_params.count(name))
    mooseError(&quot;Parameter \&quot;&quot;, name, &quot;\&quot; is not valid.&quot;);
  return have_parameter&lt;T&gt;(name);
}

template &lt;class T&gt;
InputParameters
validParams()
{
  // If users forgot to make their (old) validParams, they screwed up and
  // should get an error - so it is okay for us to try to call the new
  // validParams static function - which will error if they didn&#x27;t implement
  // the new function
  auto params = T::validParams();

  // If calling the static member method worked, we didn&#x27;t build these parameters
  // using the legacy method. Therefore, we won&#x27;t throw an error for this object
  // in CheckLegacyParamsAction. This should be removed with the closure of #19439.
  params._from_legacy_construction = false;

  return params;
}

namespace moose
{
namespace internal
{
/**
 * Calls the valid parameter method for the object of type T.
 *
 * This isn&#x27;t necessary anymore, but is hanging around until we finally
 * get rid of all mention of the legacy parameter construction. Once
 * #19439 is closed, we can replace
 * moose::internal::callValidParams&lt;T&gt;() -&gt; T::validParams(), and we
 * should return T::validParams() here instead.
 */
template &lt;typename T&gt;
InputParameters
callValidParams()
{
  return validParams&lt;T&gt;();
}
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="8f5e857f-26ca-458c-b583-06e373c7a85b"><div class="modal-content"><h4>(moose/framework/include/utils/InputParameters.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;MooseUtils.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;MultiMooseEnum.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;Conversion.h&quot;

#include &quot;libmesh/parameters.h&quot;

#ifdef LIBMESH_HAVE_FPARSER
#include &quot;libmesh/fparser.hh&quot;
#else
template &lt;typename T&gt;
class FunctionParserBase
{
}
#endif

#include &lt;tuple&gt;
#include &lt;unordered_map&gt;

// Forward declarations
class Action;
class InputParameters;
class MooseEnum;
class MooseObject;
class MultiMooseEnum;
class Problem;

/**
 * The main MOOSE class responsible for handling user-defined
 * parameters in almost every MOOSE system.
 */
class InputParameters : public Parameters
{
public:
  InputParameters(const InputParameters &amp; rhs);
  InputParameters(const Parameters &amp; rhs);

  virtual ~InputParameters() = default;

  virtual void clear() override;

  /**
   * This method adds a description of the class that will be displayed
   * in the input file syntax dump
   */
  void addClassDescription(const std::string &amp; doc_string);

  /**
   * Returns the class description
   */
  std::string getClassDescription() const;

  /**
   * Override from libMesh to set user-defined attributes on our parameter
   */
  virtual void set_attributes(const std::string &amp; name, bool inserted_only) override;

  /// This functions is called in set as a &#x27;callback&#x27; to avoid code duplication
  template &lt;typename T&gt;
  void setHelper(const std::string &amp; name);

  /**
   * Returns a writable reference to the named parameters.  Note: This is not a virtual
   * function! Use caution when comparing to the parent class implementation
   * @param name The name of the parameter to set
   * @param quiet_mode When true the parameter is kept with set_by_add_param=true,
   * this is generally not needed.
   *
   * &quot;quite_mode&quot; returns a writable reference to the named parameter, without setting
   * set_by_add_param to false. Using this method of set will make the parameter to continue to
   * behave if its value where set ONLY by addParam and not by any other method.
   *
   * This was added for handling parameters in the Output objects that have behavior dependent
   * on whether the user modified the parameters.
   *
   */
  template &lt;typename T&gt;
  T &amp; set(const std::string &amp; name, bool quiet_mode = false);

  /**
   * Given a series of parameters names and values, sets each name to
   * the corresponding value.  Any number of name, value pairs can be
   * supplied.
   *
   * Note that each \p value must be of the correct type for the
   * parameter of that name, not merely of a type convertible to the
   * correct type.
   *
   * @param name The name of the first parameter to set
   */
  template &lt;typename T, typename... Ts&gt;
  void setParameters(const std::string &amp; name, const T &amp; value, Ts... extra_input_parameters);

  /**
   * Runs a range on the supplied parameter if it exists and throws an error if that check fails.
   * @returns Boolean indicating whether range check exists
   */
  template &lt;typename T, typename UP_T&gt;
  void rangeCheck(const std::string &amp; full_name,
                  const std::string &amp; short_name,
                  InputParameters::Parameter&lt;T&gt; * param,
                  std::ostream &amp; oss = Moose::out);
  template &lt;typename T, typename UP_T&gt;
  void rangeCheck(const std::string &amp; full_name,
                  const std::string &amp; short_name,
                  InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; * param,
                  std::ostream &amp; oss = Moose::out);

  /**
   * Verifies that the requested parameter exists and is not NULL and returns it to the caller.
   * The template parameter must be a pointer or an error will be thrown.
   */
  template &lt;typename T&gt;
  T getCheckedPointerParam(const std::string &amp; name, const std::string &amp; error_string = &quot;&quot;) const;

  /**
   * This method adds a parameter and documentation string to the InputParameters
   * object that will be extracted from the input file.  If the parameter is
   * missing in the input file, and error will be thrown
   */
  template &lt;typename T&gt;
  void addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This version of addRequiredParam is here for a consistent use with MooseEnums.  Use of
   * this function for any other type will throw an error.
   */
  template &lt;typename T&gt;
  void
  addRequiredParam(const std::string &amp; name, const T &amp; moose_enum, const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add an option parameter and a documentation string to the InputParameters object.
   * The first version of this function takes a default value which is used if the parameter is not
   * found in the input file. The second method will leave the parameter uninitialized but can be
   * checked with &quot;isParamValid&quot; before use.
   */
  template &lt;typename T, typename S&gt;
  void addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name, const std::string &amp; doc_string);
  ///@}

  ///@{
  // BEGIN RANGE CHECKED PARAMETER METHODS
  /**
   * These methods add an range checked parameters. A lower and upper bound can be supplied and the
   * supplied parameter will be checked to fall within that range.
   */
  template &lt;typename T&gt;
  void addRequiredRangeCheckedParam(const std::string &amp; name,
                                    const std::string &amp; parsed_function,
                                    const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const T &amp; value,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  // END RANGE CHECKED PARAMETER METHODS
  ///@}

  /**
   * These methods add an option parameter and with a customer type to the InputParameters object.
   * The custom
   * type will be output in YAML dumps and can be used within the GUI application.
   */
  template &lt;typename T&gt;
  void addRequiredCustomTypeParam(const std::string &amp; name,
                                  const std::string &amp; custom_type,
                                  const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);

  /**
   * These method add a parameter to the InputParameters object which can be retrieved like any
   * other parameter. This parameter however is not printed in the Input file syntax dump or web
   * page dump so does not take a documentation string.  The first version of this function takes an
   * optional default value.
   */
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name, const T &amp; value);
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name);

  /**
   * Add parameters for retrieval from the command line.
   *
   * NOTE: This ONLY works for App objects!  This is not valid for normal MOOSE objects!
   *
   * @param name The name of the parameter
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addRequiredCommandLineParam(const std::string &amp; name,
                                   const std::string &amp; syntax,
                                   const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const T &amp; value,
                           const std::string &amp; doc_string);

  /**
   * @param name The name of the parameter
   * @param value The default value of this parameter if it requires one
   * @param doc_string Documentation.  This will be shown for --help
   * @param deprecation_message The message that will will print about why this param was
   * deprecated.  It might mention the &quot;new way&quot;.
   */
  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  /**
   * This method checks to make sure that we aren&#x27;t adding a parameter with the same name but a
   * different type.  It
   * throws a MooseError if an inconsistent type is detected. While this state is supported by
   * libMesh it brings
   * nothing but blood and tears for those who try ;)
   *
   * @param name the name of the parameter
   */
  template &lt;typename T&gt;
  void checkConsistentType(const std::string &amp; name) const;

  /**
   * Get the syntax for a command-line parameter
   */
  std::vector&lt;std::string&gt; getSyntax(const std::string &amp; name) const;

  /**
   * Get the documentation string for a parameter
   */
  const std::string &amp; getDescription(const std::string &amp; name) const;

  /**
   * This method takes a space delimited list of parameter names and adds them to the specified
   * group name.
   * This information is used in the GUI to group parameters into logical sections.
   */
  void addParamNamesToGroup(const std::string &amp; space_delim_names, const std::string group_name);

  /**
   * This method retrieves the group name for the passed parameter name if one exists.  Otherwise an
   * empty string is returned.
   */
  std::string getGroupName(const std::string &amp; param_name) const;

  /**
   * This method suppresses an inherited parameter so that it isn&#x27;t required or valid
   * in the derived class. The parameter is added to the private parameter list.
   * Suppressing a parameter can have dire consequences.
   * Use at your own risk!
   */
  template &lt;typename T&gt;
  void suppressParameter(const std::string &amp; name);

  /**
   * Changes the parameter to be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamRequired(const std::string &amp; name);

  /**
   * Changes the parameter to not be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   */
  void addCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This method adds a deprecated coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found. The doc string for the deprecated variable will be
   * constructed from the doc string for the new variable. A deprecation message will also be
   * automatically generated
   */
  void addDeprecatedCoupledVar(const std::string &amp; old_name,
                               const std::string &amp; new_name,
                               const std::string &amp; removal_date = &quot;&quot;);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a default value for this variable in the case that an actual variable is
   * not provided.
   */
  void addCoupledVar(const std::string &amp; name, const Real value, const std::string &amp; doc_string);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a vector of values for this variable in the case that an actual variable
   * is not provided.
   */
  void addCoupledVar(const std::string &amp; name,
                     const std::vector&lt;Real&gt; &amp; value,
                     const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add a coupled variable name pair. The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found.
   *
   * This version of the method will build a vector if the given the base_name and num_name
   * parameters exist
   * in the input file:
   *   e.g.
   *   [./foo]
   *     ...
   *     some_base = base_
   *     some_num  = 5
   *   [../]
   *
   *   # The coupling parameter will be passed this vector: &quot;base_0 base_1 base_2 base_3 base_4&quot;
   */
  void addCoupledVarWithAutoBuild(const std::string &amp; name,
                                  const std::string &amp; base_name,
                                  const std::string &amp; num_name,
                                  const std::string &amp; doc_string);
  void addRequiredCoupledVarWithAutoBuild(const std::string &amp; name,
                                          const std::string &amp; base_name,
                                          const std::string &amp; num_name,
                                          const std::string &amp; doc_string);
  ///@}

  /**
   * Utility functions for retrieving one of the MooseTypes variables into the common &quot;string&quot; base
   * class.
   * Scalar and Vector versions are supplied
   */
  std::string getMooseType(const std::string &amp; name) const;
  std::vector&lt;std::string&gt; getVecMooseType(const std::string &amp; name) const;

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable.  If the coupled variable is not supplied in the input
   * file, and error is thrown.
   *
   * Version 2: An auto built vector will be built from the base_name and num_name param. See
   * addCoupledVar for an example
   */
  void addRequiredCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * Returns the documentation string for the specified parameter name
   */
  std::string getDocString(const std::string &amp; name) const;

  /**
   * Set the doc string of a parameter.
   *
   * This method is generally used from within the validParams function to modify the documentation
   * for an
   * existing parameter, such as a parameter that is supplied from an interface class.
   */
  void setDocString(const std::string &amp; name, const std::string &amp; doc);

  /**
   * Returns a boolean indicating whether the specified parameter is required or not
   */
  bool isParamRequired(const std::string &amp; name) const;

  /**
   * This method returns parameters that have been initialized in one fashion or another,
   * i.e. The value was supplied as a default argument or read and properly converted from
   * the input file
   */
  bool isParamValid(const std::string &amp; name) const;

  /**
   * Returns whether or not the parameter was set due to addParam. If not then it was either set
   * programmatically
   * or was read through the input file.
   */
  bool isParamSetByAddParam(const std::string &amp; name) const;

  /**
   * Returns True if the parameters is deprecated.
   */
  bool isParamDeprecated(const std::string &amp; name) const;

  /**
   * This method returns true if all of the parameters in this object are valid
   * (i.e. isParamValid(name) == true - for all parameters)
   */
  bool areAllRequiredParamsValid() const;

  /**
   * Prints the type of the requested parameter by name
   */
  std::string type(const std::string &amp; name) const;

  /**
   * Returns a Boolean indicating whether the specified parameter is private or not
   */
  bool isPrivate(const std::string &amp; name) const;

  /**
   * Declare the given parameters as controllable
   */
  void declareControllable(const std::string &amp; name, std::set&lt;ExecFlagType&gt; execute_flags = {});

  /**
   * Marker a parameter that has been changed by the Control system (this is for output purposes)
   */
  void markControlled(const std::string &amp; name);

  /**
   * Returns a Boolean indicating whether the specified parameter is controllable
   */
  bool isControllable(const std::string &amp; name) const;

  /**
   * Return the allowed execute flags for a controllable parameter
   */
  const std::set&lt;ExecFlagType&gt; &amp; getControllableExecuteOnTypes(const std::string &amp; name) const;

  /**
   * This method must be called from every base &quot;Moose System&quot; to create linkage with the Action
   * System.
   * See &quot;Moose.C&quot; for the registerMooseObjectTask() calls.
   */
  void registerBase(const std::string &amp; value);

  /**
   * This method is used to define the MOOSE system name that is used by the TheWarehouse object
   * for storing objects to be retrieved for execution. The base class of every object class
   * that will be called for execution (e.g., UserObject objects) should call this method.
   *
   * This is different from registerBase because the name supplied to registerBase is used to
   * associate syntax, but the objects created often go to the same objects for execution, as is
   * the case for Postprocessor object which are executed with UserObjects.
   *
   * See the AttribSystem object for use Attribute.h/C.
   */
  void registerSystemAttributeName(const std::string &amp; value);

  /**
   * This method is here to indicate which Moose types a particular Action may build. It takes a
   * space delimited list of registered MooseObjects.  TODO: For now we aren&#x27;t actually checking
   * this list when we build objects. Since individual actions can do whatever they want it&#x27;s not
   * exactly trivial to check this without changing the user API.  This function properly restricts
   * the syntax and YAML dumps.
   */
  void registerBuildableTypes(const std::string &amp; names);

  /**
   * Tells MOOSE about a RelationshipManager that this object needs.  RelationshipManagers
   * handle element &quot;ghosting&quot;, &quot;non-local DOF access&quot; and &quot;sparsity pattern&quot; relationships.
   *
   * Basically: if this object needs non-local (ie non-current-element) data access then you
   * probably need a relationship manager
   *
   * @param name The name of the RelationshipManager type
   * @param rm_type The type (GEOMETRIC/ALGEBRAIC) of the RelationshipManger.  Note: You can use
   * boolean logic to to &quot;or&quot; RelationshipManagerTypes together to make a RelationshipManager that
   * is multi-typed.
   * @param input_parameter_callback This is a function pointer that will get called to fill in the
   * RelationShipManager&#x27;s InputParameters.  See MooseTypes.h for the signature of this function.
   */
  void addRelationshipManager(
      const std::string &amp; name,
      Moose::RelationshipManagerType rm_type,
      Moose::RelationshipManagerInputParameterCallback input_parameter_callback = nullptr);

  /**
   * Clears all currently registered RelationshipManagers
   */
  void clearRelationshipManagers() { _buildable_rm_types.clear(); }

  /**
   * Returns the list of buildable types as a std::vector&lt;std::string&gt;
   */
  const std::vector&lt;std::string&gt; &amp; getBuildableTypes() const;

  /**
   * Returns the list of buildable (or required) RelationshipManager object types for this object.
   */
  const std::vector&lt;std::tuple&lt;std::string,
                               Moose::RelationshipManagerType,
                               Moose::RelationshipManagerInputParameterCallback&gt;&gt; &amp;
  getBuildableRelationshipManagerTypes() const;

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void collapseSyntaxNesting(bool collapse);
  bool collapseSyntaxNesting() const;
  ///@}

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void mooseObjectSyntaxVisibility(bool visibility);
  bool mooseObjectSyntaxVisibility() const;
  ///@}

  ///@{
  /**
   * Copy and Copy/Add operators for the InputParameters object
   */
  using Parameters::operator=;
  using Parameters::operator+=;
  InputParameters &amp; operator=(const InputParameters &amp; rhs);
  InputParameters &amp; operator+=(const InputParameters &amp; rhs);
  ///@}

  /**
   * This function checks parameters stored in the object to make sure they are in the correct
   * state as the user expects:
   *   Required parameters are verified as valid meaning that they were either initialized when
   *   they were created, or were read from an input file or some other valid source
   */
  void checkParams(const std::string &amp; parsing_syntax);

  /**
   * Methods returning iterators to the coupled variables names stored in this
   * InputParameters object
   */
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsBegin() const
  {
    return _coupled_vars.begin();
  }
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsEnd() const
  {
    return _coupled_vars.end();
  }

  /**
   * Return the coupled variable parameter names.
   */
  const std::set&lt;std::string&gt; &amp; getCoupledVariableParamNames() const { return _coupled_vars; }

  /**
   * Return the new to deprecated variable name map
   */
  const std::unordered_map&lt;std::string, std::string&gt; &amp; getNewToDeprecatedVarMap() const
  {
    return _new_to_deprecated_coupled_vars;
  }

  /**
   * Return whether or not the coupled variable exists
   * @param coupling_name The name of the coupled variable to test for
   * @return True if the variable exists in the coupled variables for this InputParameters object
   */
  bool hasCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Return whether or not the requested parameter has a default coupled value.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  bool hasDefaultCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Get the default value for an optionally coupled variable.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  Real defaultCoupledValue(const std::string &amp; coupling_name, unsigned int i = 0) const;

  /**
   * Get the number of defaulted coupled value entries
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  unsigned int numberDefaultCoupledValues(const std::string &amp; coupling_name) const;

  /**
   * Set the default value for an optionally coupled variable (called by the Parser).
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param value Default value to set.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  void defaultCoupledValue(const std::string &amp; coupling_name, Real value, unsigned int i = 0);

  /**
   * Returns the auto build vectors for all parameters.
   */
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; getAutoBuildVectors() const;

  // BEGIN APPLY PARAMETER METHODS
  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param exclude A vector of parameters to exclude
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applyParameters(const InputParameters &amp; common,
                       std::vector&lt;std::string&gt; exclude = std::vector&lt;std::string&gt;());

  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param include A vector of parameters to apply
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applySpecificParameters(const InputParameters &amp; common,
                               const std::vector&lt;std::string&gt; &amp; include,
                               bool allow_private = false);

  /**
   * Apply values from a single parameter in common, to a single parameter stored in this object
   * @param common The set of InputParameters from which to extract parameters from
   * @param common_name The name within common from which to get the parameter values
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   */
  void applyParameter(const InputParameters &amp; common,
                      const std::string &amp; common_name,
                      bool allow_private = false);
  // END APPLY PARAMETER METHODS

  /**
   * Apply properties of a single coupled variable in common, to a single coupled variable stored in
   * this object
   * @param common The set of InputParameters from which to extract the coupled variable&#x27;s
   * properties
   * @param var_name The name of the coupled variable whose properties are to be applied
   *
   * In order to apply the properties, both the local parameters and the common parameters must
   * have a coupled variable with name var_name
   */
  void applyCoupledVar(const InputParameters &amp; common, const std::string &amp; var_name);

  /**
   * Deprecated method.  Use isParamSetByUser() instead.
   */
  bool paramSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter was by the user
   * @param name The parameter name
   */
  bool isParamSetByUser(const std::string &amp; name) const;

  ///@{
  /*
   * These methods are here to retrieve parameters for scalar and vector types respectively. We will
   * throw errors
   * when returning most scalar types, but will allow retrieving empty vectors.
   */
  template &lt;typename T&gt;
  static const T &amp;
  getParamHelper(const std::string &amp; name, const InputParameters &amp; pars, const T * the_type);

  template &lt;typename T&gt;
  static const std::vector&lt;T&gt; &amp; getParamHelper(const std::string &amp; name,
                                               const InputParameters &amp; pars,
                                               const std::vector&lt;T&gt; * the_type);
  ///@}

  using Parameters::get;

  /// Combine two vector parameters into a single vector of pairs
  template &lt;typename R1,
            typename R2,
            typename V1 = typename std::conditional&lt;std::is_same&lt;R1, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R1&gt;&gt;::type,
            typename V2 = typename std::conditional&lt;std::is_same&lt;R2, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R2&gt;&gt;::type&gt;
  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; get(const std::string &amp; param1, const std::string &amp; param2) const;

  /**
   * Return list of controllable parameters
   */
  std::set&lt;std::string&gt; getControllableParameters() const;

  /**
   * Return names of parameters within a group.
   */
  std::set&lt;std::string&gt; getGroupParameters(const std::string &amp; group) const;

  /**
   * Provide a set of reserved values for a parameter. These are values that are in addition
   * to the normal set of values the parameter can take.
   */
  void setReservedValues(const std::string &amp; name, const std::set&lt;std::string&gt; &amp; reserved);

  /**
   * Get a set of reserved parameter values.
   * Returns a set by value since we can return an empty set.
   */
  std::set&lt;std::string&gt; reservedValues(const std::string &amp; name) const;

  ///@{
  /**
   * Get/set a string representing the location (i.e. filename,linenum) in the input text for the
   * block containing parameters for this object.
   */
  std::string &amp; blockLocation() { return _block_location; }
  const std::string &amp; blockLocation() const { return _block_location; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo&quot;) for the block containing parameters for this object.
   */
  std::string &amp; blockFullpath() { return _block_fullpath; }
  const std::string &amp; blockFullpath() const { return _block_fullpath; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the location in the input text the parameter originated from
   * (i.e. filename,linenum) for the given param.
   */
  const std::string &amp; inputLocation(const std::string &amp; param) const
  {
    return at(param)._input_location;
  }
  std::string &amp; inputLocation(const std::string &amp; param) { return at(param)._input_location; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo/bar&quot; for param &quot;bar&quot;) for the given param.
   */
  const std::string &amp; paramFullpath(const std::string &amp; param) const
  {
    return at(param)._param_fullpath;
  }
  std::string &amp; paramFullpath(const std::string &amp; param) { return at(param)._param_fullpath; }
  ///@}

  /// generate error message prefix with parameter name and location (if available)
  std::string errorPrefix(const std::string &amp; param) const;

  /**
   * Get/set a string representing the raw, unmodified token text for the given param.  This is
   * usually only set/useable for file-path type parameters.
   */
  std::string &amp; rawParamVal(const std::string &amp; param) { return _params[param]._raw_val; }
  const std::string &amp; rawParamVal(const std::string &amp; param) const
  {
    return _params.at(param)._raw_val;
  }

  /**
   * Informs this object that values for this parameter set from the input file or from the command
   * line should be ignored
   */
  template &lt;typename T&gt;
  void ignoreParameter(const std::string &amp; name);

  /**
   * Whether to ignore the value of an input parameter set in the input file or from the command
   * line.
   */
  bool shouldIgnore(const std::string &amp; name);

  /**
   * @returns True if the parameter with name \p name is of type T.
   */
  template &lt;typename T&gt;
  bool isType(const std::string &amp; name) const;

  /**
   * @returns True if these parameters were constructed using the legacy method.
   **/
  bool fromLegacyConstruction() const { return _from_legacy_construction; }

  /**
   * Determine the actual variable name from the given variable \emph parameter name
   * @param var_param_name the name of the variable parameter, e.g. &#x27;variable&#x27;
   * @param moose_object_with_var_param_name the name of the moose object holding the variable
   * parameter. Used for potential error messaging
   */
  std::string varName(const std::string &amp; var_param_name,
                      const std::string &amp; moose_object_with_var_param_name) const;

private:
  // Private constructor so that InputParameters can only be created in certain places.
  InputParameters();

  /**
   * Method to terminate the recursive setParameters definition
   */
  void setParameters() {}

  /**
   * Helper that uses overloading to distinguish adding commandline parameters of
   * a scalar and a vector kind. Vector parameters are options that may appear multiple
   * times on the command line (like -i).
   */
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const std::string &amp; doc_string,
                                 T *);
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const std::string &amp; doc_string,
                                 std::vector&lt;T&gt; *);

  /**
   * Private method for setting deprecated coupled variable documentation strings
   */
  void setDeprecatedVarDocString(const std::string &amp; new_name, const std::string &amp; doc_string);

  struct Metadata
  {
    std::string _doc_string;
    /// The custom type that will be printed in the YAML dump for a parameter if supplied
    std::string _custom_type;
    std::vector&lt;std::string&gt; _cli_flag_names;
    /// The names of the parameters organized into groups
    std::string _group;
    /// The map of functions used for range checked parameters
    std::string _range_function;
    /// directions for auto build vectors (base_, 5) -&gt; &quot;base_0 base_1 base_2 base_3 base_4&quot;)
    std::pair&lt;std::string, std::string&gt; _autobuild_vecs;
    /// True for parameters that are required (i.e. will cause an abort if not supplied)
    bool _required = false;
    /**
     * Whether the parameter is either explicitly set or provided a default value when added
     * Note: We do not store MooseEnum names in valid params, instead we ask MooseEnums whether
     *       they are valid or not.
     */
    bool _valid = false;
    /// The set of parameters that will NOT appear in the the dump of the parser tree
    bool _is_private = false;
    bool _have_coupled_default = false;
    /// The default value for optionally coupled variables
    std::vector&lt;Real&gt; _coupled_default = {0};
    /// True if a parameters value was set by addParam, and not set again.
    bool _set_by_add_param = false;
    /// The reserved option names for a parameter
    std::set&lt;std::string&gt; _reserved_values;
    /// If non-empty, this parameter is deprecated.
    std::string _deprecation_message;
    /// original location of parameter (i.e. filename,linenum) - used for nice error messages.
    std::string _input_location;
    /// full HIT path of the parameter from the input file - used for nice error messages.
    std::string _param_fullpath;
    /// raw token text for a parameter - usually only set for filepath type params.
    std::string _raw_val;
    /// True if the parameters is controllable
    bool _controllable = false;
    /// Controllable execute flag restriction
    std::set&lt;ExecFlagType&gt; _controllable_flags;
    /// whether user setting of this parameter should be ignored
    bool _ignore = false;
  };

  Metadata &amp; at(const std::string &amp; param)
  {
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params[param];
  }
  const Metadata &amp; at(const std::string &amp; param) const
  {
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params.at(param);
  }

  /**
   * Toggle the availability of the copy constructor
   *
   * When MooseObject is created via the Factory this flag is set to false, so when a MooseObject is
   * created if
   * the constructor is not a const reference an error is produced. This method allows the
   * InputParameterWarehouse
   * to disable copying.
   */
  void allowCopy(bool status) { _allow_copy = status; }

  /**
   * Make sure the parameter name doesn&#x27;t have any invalid characters.
   */
  void checkParamName(const std::string &amp; name) const;

  /**
   * This method is called when adding a Parameter with a default value, can be specialized for
   * non-matching types.
   */
  template &lt;typename T, typename S&gt;
  void setParamHelper(const std::string &amp; name, T &amp; l_value, const S &amp; r_value);

  /// original location of input block (i.e. filename,linenum) - used for nice error messages.
  std::string _block_location;

  /// full HIT path of the block from the input file - used for nice error messages.
  std::string _block_fullpath;

  /// The actual parameter data. Each Metadata object contains attributes for the corresponding
  /// parameter.
  std::map&lt;std::string, Metadata&gt; _params;

  /// The coupled variables set
  std::set&lt;std::string&gt; _coupled_vars;

  /// The class description for the owning object. This string is used in many places including
  /// mouse-over events, and external documentation produced from the source code.
  std::string _class_description;

  /// The parameter is used to restrict types that can be built.  Typically this is used for
  /// MooseObjectAction derived Actions.
  std::vector&lt;std::string&gt; _buildable_types;

  /// The RelationshipManagers that this object may either build or require.
  /// The optional second argument may be supplied to &quot;downgrade&quot; the functionality of the corresponding
  /// relationship manager (e.g. An AlgebraicRelationshipManager could be only used as a
  /// GeometricRelationshipManager for a given simulation).
  std::vector&lt;std::tuple&lt;std::string,
                         Moose::RelationshipManagerType,
                         Moose::RelationshipManagerInputParameterCallback&gt;&gt;
      _buildable_rm_types;

  /// This parameter collapses one level of nesting in the syntax blocks.  It is used
  /// in conjunction with MooseObjectAction derived Actions.
  bool _collapse_nesting;

  /// This parameter hides derived MOOSE object types from appearing in syntax dumps
  bool _moose_object_syntax_visibility;

  /// Flag for disabling deprecated parameters message, this is used by applyParameters to avoid
  /// dumping messages.
  bool _show_deprecated_message;

  /// A flag for toggling the error message in the copy constructor.
  bool _allow_copy;

  /// Whether or not these parameters were constructed using legacy contruction (remove with #19440)
  bool _from_legacy_construction;

  /// A map from deprecated coupled variable names to the new blessed name
  std::unordered_map&lt;std::string, std::string&gt; _new_to_deprecated_coupled_vars;

  // These are the only objects allowed to _create_ InputParameters
  friend InputParameters emptyInputParameters();
  friend class InputParameterWarehouse;
  friend class Parser;
  // for the printInputFile function in the action warehouse
  friend class ActionWarehouse;

  // For setting _from_legacy_construction (remove with #19440)
  template &lt;typename T&gt;
  friend InputParameters validParams();
};

template &lt;typename T&gt;
void
InputParameters::setHelper(const std::string &amp; /*name*/)
{
}

// Template and inline function implementations
template &lt;typename T&gt;
T &amp;
InputParameters::set(const std::string &amp; name, bool quiet_mode)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; result = this-&gt;Parameters::set&lt;T&gt;(name);

  if (quiet_mode)
    _params[name]._set_by_add_param = true;

  setHelper&lt;T&gt;(name);

  return result;
}

template &lt;typename T, typename... Ts&gt;
void
InputParameters::setParameters(const std::string &amp; name,
                               const T &amp; value,
                               Ts... extra_input_parameters)
{
  this-&gt;set&lt;T&gt;(name) = value;
  this-&gt;setParameters(extra_input_parameters...);
}

template &lt;typename T, typename UP_T&gt;
void
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; * param,
                            std::ostream &amp; oss)
{
  mooseAssert(param, &quot;Parameter is NULL&quot;);

  if (!isParamValid(short_name) || _params[short_name]._range_function.empty())
    return;

  /**
   * Automatically detect the variables used in the range checking expression.
   * We allow the following variables (where snam is the short_name of the parameter)
   *
   * snam       : tests every component in the vector
   *              &#x27;snam &gt; 0&#x27;
   * snam_size  : the size of the vector
   *              &#x27;snam_size = 5&#x27;
   * snam_i     : where i is a number from 0 to sname_size-1 tests a specific component
   *              &#x27;snam_0 &gt; snam_1&#x27;
   */
  FunctionParserBase&lt;UP_T&gt; fp;
  std::vector&lt;std::string&gt; vars;
  if (fp.ParseAndDeduceVariables(_params[short_name]._range_function, vars) != -1) // -1 for success
  {
    oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
    return;
  }

  // Fparser parameter buffer
  std::vector&lt;UP_T&gt; parbuf(vars.size());

  // parameter vector
  const std::vector&lt;T&gt; &amp; value = param-&gt;set();

  // iterate over all vector values (maybe ;)
  bool need_to_iterate = false;
  unsigned int i = 0;
  do
  {
    // set parameters
    for (unsigned int j = 0; j &lt; vars.size(); j++)
    {
      if (vars[j] == short_name)
      {
        if (value.size() == 0)
        {
          oss &lt;&lt; &quot;Range checking empty vector: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
          return;
        }

        parbuf[j] = value[i];
        need_to_iterate = true;
      }
      else if (vars[j] == short_name + &quot;_size&quot;)
        parbuf[j] = value.size();
      else
      {
        if (vars[j].substr(0, short_name.size() + 1) != short_name + &quot;_&quot;)
        {
          oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
          return;
        }
        std::istringstream iss(vars[j]);
        iss.seekg(short_name.size() + 1);

        size_t index;
        if (iss &gt;&gt; index &amp;&amp; iss.eof())
        {
          if (index &gt;= value.size())
          {
            oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function
                &lt;&lt; &quot;\nOut of range variable &quot; &lt;&lt; vars[j] &lt;&lt; &#x27;\n&#x27;;
            return;
          }
          parbuf[j] = value[index];
        }
        else
        {
          oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function
              &lt;&lt; &quot;\nInvalid variable &quot; &lt;&lt; vars[j] &lt;&lt; &#x27;\n&#x27;;
          return;
        }
      }
    }

    // ensure range-checked input file parameter comparison functions
    // do absolute floating point comparisons instead of using a default epsilon.
    auto tmp_eps = fp.epsilon();
    fp.setEpsilon(0);
    UP_T result = fp.Eval(&amp;parbuf[0]);
    fp.setEpsilon(tmp_eps);

    // test function using the parameters determined above
    if (fp.EvalError())
    {
      oss &lt;&lt; &quot;Error evaluating expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
      return;
    }

    if (!result)
    {
      oss &lt;&lt; &quot;Range check failed for parameter &quot; &lt;&lt; full_name
          &lt;&lt; &quot;\n\tExpression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &quot;\n&quot;;
      if (need_to_iterate)
        oss &lt;&lt; &quot;\t Component: &quot; &lt;&lt; i &lt;&lt; &#x27;\n&#x27;;
    }

  } while (need_to_iterate &amp;&amp; ++i &lt; value.size());
}

template &lt;typename T, typename UP_T&gt;
void
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            InputParameters::Parameter&lt;T&gt; * param,
                            std::ostream &amp; oss)
{
  mooseAssert(param, &quot;Parameter is NULL&quot;);

  if (!isParamValid(short_name) || _params[short_name]._range_function.empty())
    return;

  // Parse the expression
  FunctionParserBase&lt;UP_T&gt; fp;
  if (fp.Parse(_params[short_name]._range_function, short_name) != -1) // -1 for success
  {
    oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
    return;
  }

  // ensure range-checked input file parameter comparison functions
  // do absolute floating point comparisons instead of using a default epsilon.
  auto tmp_eps = fp.epsilon();
  fp.setEpsilon(0);
  // We require a non-const value for the implicit upscaling of the parameter type
  std::vector&lt;UP_T&gt; value(1, param-&gt;set());
  UP_T result = fp.Eval(&amp;value[0]);
  fp.setEpsilon(tmp_eps);

  if (fp.EvalError())
  {
    oss &lt;&lt; &quot;Error evaluating expression: &quot; &lt;&lt; _params[short_name]._range_function
        &lt;&lt; &quot;\nPerhaps you used the wrong variable name?\n&quot;;
    return;
  }

  if (!result)
    oss &lt;&lt; &quot;Range check failed for parameter &quot; &lt;&lt; full_name
        &lt;&lt; &quot;\n\tExpression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &quot;\n\tValue: &quot; &lt;&lt; value[0]
        &lt;&lt; &#x27;\n&#x27;;
}

template &lt;typename T&gt;
T
InputParameters::getCheckedPointerParam(const std::string &amp; name,
                                        const std::string &amp; error_string) const
{
  T param = this-&gt;get&lt;T&gt;(name);

  // Note: You will receive a compile error on this line if you attempt to pass a non-pointer
  // template type to this method
  if (param == NULL)
    mooseError(&quot;Parameter &quot;, name, &quot; is NULL.\n&quot;, error_string);
  return this-&gt;get&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._required = true;
  _params[name]._doc_string = doc_string;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; /*name*/,
                                  const T &amp; /*value*/,
                                  const std::string &amp; /*doc_string*/)
{
  mooseError(&quot;You cannot call addRequiredParam and supply a default value for this type, please &quot;
             &quot;use addParam instead&quot;);
}

template &lt;typename T, typename S&gt;
void
InputParameters::addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; l_value = InputParameters::set&lt;T&gt;(name);
  _params[name]._doc_string = doc_string;

  // Set the parameter now
  setParamHelper(name, l_value, value);

  /* Indicate the default value, as set via addParam, is being used. The parameter is removed from
     the list whenever
     it changes, see set_attributes */
  _params[name]._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._doc_string = doc_string;
}

template &lt;typename T, typename S&gt;
void
InputParameters::setParamHelper(const std::string &amp; /*name*/, T &amp; l_value, const S &amp; r_value)
{
  l_value = r_value;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredRangeCheckedParam(const std::string &amp; name,
                                              const std::string &amp; parsed_function,
                                              const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const T &amp; value,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCustomTypeParam(const std::string &amp; name,
                                            const std::string &amp; custom_type,
                                            const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._is_private = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name, const T &amp; value)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::set&lt;T&gt;(name) = value;
  _params[name]._is_private = true;
  _params[name]._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCommandLineParam(const std::string &amp; name,
                                             const std::string &amp; syntax,
                                             const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const T &amp; value,
                                     const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::checkConsistentType(const std::string &amp; name) const
{
  // If we don&#x27;t currently have the Parameter, can&#x27;t be any inconsistency
  InputParameters::const_iterator it = _values.find(name);
  if (it == _values.end())
    return;

  // Now, if we already have the Parameter, but it doesn&#x27;t have the
  // right type, throw an error.
  if (!this-&gt;Parameters::have_parameter&lt;T&gt;(name))
    mooseError(&quot;Attempting to set parameter \&quot;&quot;,
               name,
               &quot;\&quot; with type (&quot;,
               demangle(typeid(T).name()),
               &quot;)\nbut the parameter already exists as type (&quot;,
               it-&gt;second-&gt;type(),
               &quot;)&quot;);
}

template &lt;typename T&gt;
void
InputParameters::suppressParameter(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to suppress nonexistent parameter: &quot;, name);

  _params[name]._required = false;
  _params[name]._is_private = true;
  _params[name]._controllable = false;
}

template &lt;typename T&gt;
void
InputParameters::ignoreParameter(const std::string &amp; name)
{
  suppressParameter&lt;T&gt;(name);
  _params[name]._ignore = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamRequired(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to require nonexistent parameter: &quot;, name);

  _params[name]._required = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamNotRequired(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to un-require nonexistent parameter: &quot;, name);

  _params[name]._required = false;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, value, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

// Forward declare MooseEnum specializations for add*Param
template &lt;&gt;
void InputParameters::addRequiredParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                  const MooseEnum &amp; moose_enum,
                                                  const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                       const MultiMooseEnum &amp; moose_enum,
                                                       const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                          const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                       const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                    const std::string &amp; doc_string,
                                                    const std::string &amp; deprecation_message);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                         const std::string &amp; doc_string,
                                                         const std::string &amp; deprecation_message);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::string &amp; doc_string,
    const std::string &amp; deprecation_message);

// Forward declare specializations for setParamHelper
template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, Real&gt;(const std::string &amp; name,
                                                              PostprocessorName &amp; l_value,
                                                              const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, int&gt;(const std::string &amp; name,
                                                             PostprocessorName &amp; l_value,
                                                             const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, Real&gt;(const std::string &amp; /*name*/,
                                                         FunctionName &amp; l_value,
                                                         const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, int&gt;(const std::string &amp; /*name*/,
                                                        FunctionName &amp; l_value,
                                                        const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, Real&gt;(const std::string &amp; /*name*/,
                                                                 MaterialPropertyName &amp; l_value,
                                                                 const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, int&gt;(const std::string &amp; /*name*/,
                                                                MaterialPropertyName &amp; l_value,
                                                                const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, Real&gt;(const std::string &amp; /*name*/,
                                                             MooseFunctorName &amp; l_value,
                                                             const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, int&gt;(const std::string &amp; /*name*/,
                                                            MooseFunctorName &amp; l_value,
                                                            const int &amp; r_value);

template &lt;typename T&gt;
const T &amp;
InputParameters::getParamHelper(const std::string &amp; name, const InputParameters &amp; pars, const T *)
{
  if (!pars.isParamValid(name))
    mooseError(&quot;The parameter \&quot;&quot;, name, &quot;\&quot; is being retrieved before being set.\n&quot;);

  return pars.get&lt;T&gt;(name);
}

// Declare specializations so we don&#x27;t fall back on the generic
// implementation, but the definition will be in InputParameters.C so
// we won&#x27;t need to bring in *MooseEnum header files here.
template &lt;&gt;
const MooseEnum &amp; InputParameters::getParamHelper&lt;MooseEnum&gt;(const std::string &amp; name,
                                                             const InputParameters &amp; pars,
                                                             const MooseEnum *);

template &lt;&gt;
const MultiMooseEnum &amp; InputParameters::getParamHelper&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                                       const InputParameters &amp; pars,
                                                                       const MultiMooseEnum *);

template &lt;typename T&gt;
const std::vector&lt;T&gt; &amp;
InputParameters::getParamHelper(const std::string &amp; name,
                                const InputParameters &amp; pars,
                                const std::vector&lt;T&gt; *)
{
  return pars.get&lt;std::vector&lt;T&gt;&gt;(name);
}

template &lt;typename R1, typename R2, typename V1, typename V2&gt;
std::vector&lt;std::pair&lt;R1, R2&gt;&gt;
InputParameters::get(const std::string &amp; param1, const std::string &amp; param2) const
{
  const auto &amp; v1 = get&lt;V1&gt;(param1);
  const auto &amp; v2 = get&lt;V2&gt;(param2);

  auto controllable = getControllableParameters();
  if (controllable.count(param1) || controllable.count(param2))
    mooseError(errorPrefix(param1),
               &quot; and/or &quot;,
               errorPrefix(param2) +
                   &quot; are controllable parameters and cannot be retireved using &quot;
                   &quot;the MooseObject::getParam/InputParameters::get methods for pairs&quot;);

  if (v1.size() != v2.size())
    mooseError(&quot;Vector parameters &quot;,
               errorPrefix(param1),
               &quot;(size: &quot;,
               v1.size(),
               &quot;) and &quot; + errorPrefix(param2),
               &quot;(size: &quot;,
               v2.size(),
               &quot;) are of different lengths \n&quot;);

  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; parameter_pairs;
  auto i1 = v1.begin();
  auto i2 = v2.begin();
  for (; i1 != v1.end() &amp;&amp; i2 != v2.end(); ++i1, ++i2)
    parameter_pairs.emplace_back(std::make_pair(*i1, *i2));
  return parameter_pairs;
}

InputParameters emptyInputParameters();

template &lt;typename T&gt;
bool
InputParameters::isType(const std::string &amp; name) const
{
  if (!_params.count(name))
    mooseError(&quot;Parameter \&quot;&quot;, name, &quot;\&quot; is not valid.&quot;);
  return have_parameter&lt;T&gt;(name);
}

template &lt;class T&gt;
InputParameters
validParams()
{
  // If users forgot to make their (old) validParams, they screwed up and
  // should get an error - so it is okay for us to try to call the new
  // validParams static function - which will error if they didn&#x27;t implement
  // the new function
  auto params = T::validParams();

  // If calling the static member method worked, we didn&#x27;t build these parameters
  // using the legacy method. Therefore, we won&#x27;t throw an error for this object
  // in CheckLegacyParamsAction. This should be removed with the closure of #19439.
  params._from_legacy_construction = false;

  return params;
}

namespace moose
{
namespace internal
{
/**
 * Calls the valid parameter method for the object of type T.
 *
 * This isn&#x27;t necessary anymore, but is hanging around until we finally
 * get rid of all mention of the legacy parameter construction. Once
 * #19439 is closed, we can replace
 * moose::internal::callValidParams&lt;T&gt;() -&gt; T::validParams(), and we
 * should return T::validParams() here instead.
 */
template &lt;typename T&gt;
InputParameters
callValidParams()
{
  return validParams&lt;T&gt;();
}
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ba51003c-5852-4958-ab55-5ce0b18b7491"><div class="modal-content"><h4>(moose/framework/include/utils/InputParameters.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

// MOOSE includes
#include &quot;MooseUtils.h&quot;
#include &quot;MooseError.h&quot;
#include &quot;MooseTypes.h&quot;
#include &quot;MultiMooseEnum.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;Conversion.h&quot;

#include &quot;libmesh/parameters.h&quot;

#ifdef LIBMESH_HAVE_FPARSER
#include &quot;libmesh/fparser.hh&quot;
#else
template &lt;typename T&gt;
class FunctionParserBase
{
}
#endif

#include &lt;tuple&gt;
#include &lt;unordered_map&gt;

// Forward declarations
class Action;
class InputParameters;
class MooseEnum;
class MooseObject;
class MultiMooseEnum;
class Problem;

/**
 * The main MOOSE class responsible for handling user-defined
 * parameters in almost every MOOSE system.
 */
class InputParameters : public Parameters
{
public:
  InputParameters(const InputParameters &amp; rhs);
  InputParameters(const Parameters &amp; rhs);

  virtual ~InputParameters() = default;

  virtual void clear() override;

  /**
   * This method adds a description of the class that will be displayed
   * in the input file syntax dump
   */
  void addClassDescription(const std::string &amp; doc_string);

  /**
   * Returns the class description
   */
  std::string getClassDescription() const;

  /**
   * Override from libMesh to set user-defined attributes on our parameter
   */
  virtual void set_attributes(const std::string &amp; name, bool inserted_only) override;

  /// This functions is called in set as a &#x27;callback&#x27; to avoid code duplication
  template &lt;typename T&gt;
  void setHelper(const std::string &amp; name);

  /**
   * Returns a writable reference to the named parameters.  Note: This is not a virtual
   * function! Use caution when comparing to the parent class implementation
   * @param name The name of the parameter to set
   * @param quiet_mode When true the parameter is kept with set_by_add_param=true,
   * this is generally not needed.
   *
   * &quot;quite_mode&quot; returns a writable reference to the named parameter, without setting
   * set_by_add_param to false. Using this method of set will make the parameter to continue to
   * behave if its value where set ONLY by addParam and not by any other method.
   *
   * This was added for handling parameters in the Output objects that have behavior dependent
   * on whether the user modified the parameters.
   *
   */
  template &lt;typename T&gt;
  T &amp; set(const std::string &amp; name, bool quiet_mode = false);

  /**
   * Given a series of parameters names and values, sets each name to
   * the corresponding value.  Any number of name, value pairs can be
   * supplied.
   *
   * Note that each \p value must be of the correct type for the
   * parameter of that name, not merely of a type convertible to the
   * correct type.
   *
   * @param name The name of the first parameter to set
   */
  template &lt;typename T, typename... Ts&gt;
  void setParameters(const std::string &amp; name, const T &amp; value, Ts... extra_input_parameters);

  /**
   * Runs a range on the supplied parameter if it exists and throws an error if that check fails.
   * @returns Boolean indicating whether range check exists
   */
  template &lt;typename T, typename UP_T&gt;
  void rangeCheck(const std::string &amp; full_name,
                  const std::string &amp; short_name,
                  InputParameters::Parameter&lt;T&gt; * param,
                  std::ostream &amp; oss = Moose::out);
  template &lt;typename T, typename UP_T&gt;
  void rangeCheck(const std::string &amp; full_name,
                  const std::string &amp; short_name,
                  InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; * param,
                  std::ostream &amp; oss = Moose::out);

  /**
   * Verifies that the requested parameter exists and is not NULL and returns it to the caller.
   * The template parameter must be a pointer or an error will be thrown.
   */
  template &lt;typename T&gt;
  T getCheckedPointerParam(const std::string &amp; name, const std::string &amp; error_string = &quot;&quot;) const;

  /**
   * This method adds a parameter and documentation string to the InputParameters
   * object that will be extracted from the input file.  If the parameter is
   * missing in the input file, and error will be thrown
   */
  template &lt;typename T&gt;
  void addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This version of addRequiredParam is here for a consistent use with MooseEnums.  Use of
   * this function for any other type will throw an error.
   */
  template &lt;typename T&gt;
  void
  addRequiredParam(const std::string &amp; name, const T &amp; moose_enum, const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add an option parameter and a documentation string to the InputParameters object.
   * The first version of this function takes a default value which is used if the parameter is not
   * found in the input file. The second method will leave the parameter uninitialized but can be
   * checked with &quot;isParamValid&quot; before use.
   */
  template &lt;typename T, typename S&gt;
  void addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addParam(const std::string &amp; name, const std::string &amp; doc_string);
  ///@}

  ///@{
  // BEGIN RANGE CHECKED PARAMETER METHODS
  /**
   * These methods add an range checked parameters. A lower and upper bound can be supplied and the
   * supplied parameter will be checked to fall within that range.
   */
  template &lt;typename T&gt;
  void addRequiredRangeCheckedParam(const std::string &amp; name,
                                    const std::string &amp; parsed_function,
                                    const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const T &amp; value,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addRangeCheckedParam(const std::string &amp; name,
                            const std::string &amp; parsed_function,
                            const std::string &amp; doc_string);
  // END RANGE CHECKED PARAMETER METHODS
  ///@}

  /**
   * These methods add an option parameter and with a customer type to the InputParameters object.
   * The custom
   * type will be output in YAML dumps and can be used within the GUI application.
   */
  template &lt;typename T&gt;
  void addRequiredCustomTypeParam(const std::string &amp; name,
                                  const std::string &amp; custom_type,
                                  const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCustomTypeParam(const std::string &amp; name,
                          const std::string &amp; custom_type,
                          const std::string &amp; doc_string);

  /**
   * These method add a parameter to the InputParameters object which can be retrieved like any
   * other parameter. This parameter however is not printed in the Input file syntax dump or web
   * page dump so does not take a documentation string.  The first version of this function takes an
   * optional default value.
   */
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name, const T &amp; value);
  template &lt;typename T&gt;
  void addPrivateParam(const std::string &amp; name);

  /**
   * Add parameters for retrieval from the command line.
   *
   * NOTE: This ONLY works for App objects!  This is not valid for normal MOOSE objects!
   *
   * @param name The name of the parameter
   * @param syntax Space separated list of command-line switch syntax that can set this option
   * @param doc_string Documentation.  This will be shown for --help
   */
  template &lt;typename T&gt;
  void addRequiredCommandLineParam(const std::string &amp; name,
                                   const std::string &amp; syntax,
                                   const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const std::string &amp; doc_string);
  template &lt;typename T&gt;
  void addCommandLineParam(const std::string &amp; name,
                           const std::string &amp; syntax,
                           const T &amp; value,
                           const std::string &amp; doc_string);

  /**
   * @param name The name of the parameter
   * @param value The default value of this parameter if it requires one
   * @param doc_string Documentation.  This will be shown for --help
   * @param deprecation_message The message that will will print about why this param was
   * deprecated.  It might mention the &quot;new way&quot;.
   */
  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const T &amp; value,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  template &lt;typename T&gt;
  void addDeprecatedParam(const std::string &amp; name,
                          const std::string &amp; doc_string,
                          const std::string &amp; deprecation_message);

  /**
   * This method checks to make sure that we aren&#x27;t adding a parameter with the same name but a
   * different type.  It
   * throws a MooseError if an inconsistent type is detected. While this state is supported by
   * libMesh it brings
   * nothing but blood and tears for those who try ;)
   *
   * @param name the name of the parameter
   */
  template &lt;typename T&gt;
  void checkConsistentType(const std::string &amp; name) const;

  /**
   * Get the syntax for a command-line parameter
   */
  std::vector&lt;std::string&gt; getSyntax(const std::string &amp; name) const;

  /**
   * Get the documentation string for a parameter
   */
  const std::string &amp; getDescription(const std::string &amp; name) const;

  /**
   * This method takes a space delimited list of parameter names and adds them to the specified
   * group name.
   * This information is used in the GUI to group parameters into logical sections.
   */
  void addParamNamesToGroup(const std::string &amp; space_delim_names, const std::string group_name);

  /**
   * This method retrieves the group name for the passed parameter name if one exists.  Otherwise an
   * empty string is returned.
   */
  std::string getGroupName(const std::string &amp; param_name) const;

  /**
   * This method suppresses an inherited parameter so that it isn&#x27;t required or valid
   * in the derived class. The parameter is added to the private parameter list.
   * Suppressing a parameter can have dire consequences.
   * Use at your own risk!
   */
  template &lt;typename T&gt;
  void suppressParameter(const std::string &amp; name);

  /**
   * Changes the parameter to be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamRequired(const std::string &amp; name);

  /**
   * Changes the parameter to not be required.
   * @param name The parameter name
   */
  template &lt;typename T&gt;
  void makeParamNotRequired(const std::string &amp; name);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   */
  void addCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * This method adds a deprecated coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found. The doc string for the deprecated variable will be
   * constructed from the doc string for the new variable. A deprecation message will also be
   * automatically generated
   */
  void addDeprecatedCoupledVar(const std::string &amp; old_name,
                               const std::string &amp; new_name,
                               const std::string &amp; removal_date = &quot;&quot;);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a default value for this variable in the case that an actual variable is
   * not provided.
   */
  void addCoupledVar(const std::string &amp; name, const Real value, const std::string &amp; doc_string);

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found
   *
   * Also - you can provide a vector of values for this variable in the case that an actual variable
   * is not provided.
   */
  void addCoupledVar(const std::string &amp; name,
                     const std::vector&lt;Real&gt; &amp; value,
                     const std::string &amp; doc_string);

  ///@{
  /**
   * These methods add a coupled variable name pair. The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable if found.
   *
   * This version of the method will build a vector if the given the base_name and num_name
   * parameters exist
   * in the input file:
   *   e.g.
   *   [./foo]
   *     ...
   *     some_base = base_
   *     some_num  = 5
   *   [../]
   *
   *   # The coupling parameter will be passed this vector: &quot;base_0 base_1 base_2 base_3 base_4&quot;
   */
  void addCoupledVarWithAutoBuild(const std::string &amp; name,
                                  const std::string &amp; base_name,
                                  const std::string &amp; num_name,
                                  const std::string &amp; doc_string);
  void addRequiredCoupledVarWithAutoBuild(const std::string &amp; name,
                                          const std::string &amp; base_name,
                                          const std::string &amp; num_name,
                                          const std::string &amp; doc_string);
  ///@}

  /**
   * Utility functions for retrieving one of the MooseTypes variables into the common &quot;string&quot; base
   * class.
   * Scalar and Vector versions are supplied
   */
  std::string getMooseType(const std::string &amp; name) const;
  std::vector&lt;std::string&gt; getVecMooseType(const std::string &amp; name) const;

  /**
   * This method adds a coupled variable name pair.  The parser will look for variable
   * name pair in the input file and can return a reference to the storage location
   * for the coupled variable.  If the coupled variable is not supplied in the input
   * file, and error is thrown.
   *
   * Version 2: An auto built vector will be built from the base_name and num_name param. See
   * addCoupledVar for an example
   */
  void addRequiredCoupledVar(const std::string &amp; name, const std::string &amp; doc_string);

  /**
   * Returns the documentation string for the specified parameter name
   */
  std::string getDocString(const std::string &amp; name) const;

  /**
   * Set the doc string of a parameter.
   *
   * This method is generally used from within the validParams function to modify the documentation
   * for an
   * existing parameter, such as a parameter that is supplied from an interface class.
   */
  void setDocString(const std::string &amp; name, const std::string &amp; doc);

  /**
   * Returns a boolean indicating whether the specified parameter is required or not
   */
  bool isParamRequired(const std::string &amp; name) const;

  /**
   * This method returns parameters that have been initialized in one fashion or another,
   * i.e. The value was supplied as a default argument or read and properly converted from
   * the input file
   */
  bool isParamValid(const std::string &amp; name) const;

  /**
   * Returns whether or not the parameter was set due to addParam. If not then it was either set
   * programmatically
   * or was read through the input file.
   */
  bool isParamSetByAddParam(const std::string &amp; name) const;

  /**
   * Returns True if the parameters is deprecated.
   */
  bool isParamDeprecated(const std::string &amp; name) const;

  /**
   * This method returns true if all of the parameters in this object are valid
   * (i.e. isParamValid(name) == true - for all parameters)
   */
  bool areAllRequiredParamsValid() const;

  /**
   * Prints the type of the requested parameter by name
   */
  std::string type(const std::string &amp; name) const;

  /**
   * Returns a Boolean indicating whether the specified parameter is private or not
   */
  bool isPrivate(const std::string &amp; name) const;

  /**
   * Declare the given parameters as controllable
   */
  void declareControllable(const std::string &amp; name, std::set&lt;ExecFlagType&gt; execute_flags = {});

  /**
   * Marker a parameter that has been changed by the Control system (this is for output purposes)
   */
  void markControlled(const std::string &amp; name);

  /**
   * Returns a Boolean indicating whether the specified parameter is controllable
   */
  bool isControllable(const std::string &amp; name) const;

  /**
   * Return the allowed execute flags for a controllable parameter
   */
  const std::set&lt;ExecFlagType&gt; &amp; getControllableExecuteOnTypes(const std::string &amp; name) const;

  /**
   * This method must be called from every base &quot;Moose System&quot; to create linkage with the Action
   * System.
   * See &quot;Moose.C&quot; for the registerMooseObjectTask() calls.
   */
  void registerBase(const std::string &amp; value);

  /**
   * This method is used to define the MOOSE system name that is used by the TheWarehouse object
   * for storing objects to be retrieved for execution. The base class of every object class
   * that will be called for execution (e.g., UserObject objects) should call this method.
   *
   * This is different from registerBase because the name supplied to registerBase is used to
   * associate syntax, but the objects created often go to the same objects for execution, as is
   * the case for Postprocessor object which are executed with UserObjects.
   *
   * See the AttribSystem object for use Attribute.h/C.
   */
  void registerSystemAttributeName(const std::string &amp; value);

  /**
   * This method is here to indicate which Moose types a particular Action may build. It takes a
   * space delimited list of registered MooseObjects.  TODO: For now we aren&#x27;t actually checking
   * this list when we build objects. Since individual actions can do whatever they want it&#x27;s not
   * exactly trivial to check this without changing the user API.  This function properly restricts
   * the syntax and YAML dumps.
   */
  void registerBuildableTypes(const std::string &amp; names);

  /**
   * Tells MOOSE about a RelationshipManager that this object needs.  RelationshipManagers
   * handle element &quot;ghosting&quot;, &quot;non-local DOF access&quot; and &quot;sparsity pattern&quot; relationships.
   *
   * Basically: if this object needs non-local (ie non-current-element) data access then you
   * probably need a relationship manager
   *
   * @param name The name of the RelationshipManager type
   * @param rm_type The type (GEOMETRIC/ALGEBRAIC) of the RelationshipManger.  Note: You can use
   * boolean logic to to &quot;or&quot; RelationshipManagerTypes together to make a RelationshipManager that
   * is multi-typed.
   * @param input_parameter_callback This is a function pointer that will get called to fill in the
   * RelationShipManager&#x27;s InputParameters.  See MooseTypes.h for the signature of this function.
   */
  void addRelationshipManager(
      const std::string &amp; name,
      Moose::RelationshipManagerType rm_type,
      Moose::RelationshipManagerInputParameterCallback input_parameter_callback = nullptr);

  /**
   * Clears all currently registered RelationshipManagers
   */
  void clearRelationshipManagers() { _buildable_rm_types.clear(); }

  /**
   * Returns the list of buildable types as a std::vector&lt;std::string&gt;
   */
  const std::vector&lt;std::string&gt; &amp; getBuildableTypes() const;

  /**
   * Returns the list of buildable (or required) RelationshipManager object types for this object.
   */
  const std::vector&lt;std::tuple&lt;std::string,
                               Moose::RelationshipManagerType,
                               Moose::RelationshipManagerInputParameterCallback&gt;&gt; &amp;
  getBuildableRelationshipManagerTypes() const;

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void collapseSyntaxNesting(bool collapse);
  bool collapseSyntaxNesting() const;
  ///@}

  ///@{
  /**
   * Mutators for controlling whether or not the outermost level of syntax will be collapsed when
   * printed.
   */
  void mooseObjectSyntaxVisibility(bool visibility);
  bool mooseObjectSyntaxVisibility() const;
  ///@}

  ///@{
  /**
   * Copy and Copy/Add operators for the InputParameters object
   */
  using Parameters::operator=;
  using Parameters::operator+=;
  InputParameters &amp; operator=(const InputParameters &amp; rhs);
  InputParameters &amp; operator+=(const InputParameters &amp; rhs);
  ///@}

  /**
   * This function checks parameters stored in the object to make sure they are in the correct
   * state as the user expects:
   *   Required parameters are verified as valid meaning that they were either initialized when
   *   they were created, or were read from an input file or some other valid source
   */
  void checkParams(const std::string &amp; parsing_syntax);

  /**
   * Methods returning iterators to the coupled variables names stored in this
   * InputParameters object
   */
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsBegin() const
  {
    return _coupled_vars.begin();
  }
  inline std::set&lt;std::string&gt;::const_iterator coupledVarsEnd() const
  {
    return _coupled_vars.end();
  }

  /**
   * Return the coupled variable parameter names.
   */
  const std::set&lt;std::string&gt; &amp; getCoupledVariableParamNames() const { return _coupled_vars; }

  /**
   * Return the new to deprecated variable name map
   */
  const std::unordered_map&lt;std::string, std::string&gt; &amp; getNewToDeprecatedVarMap() const
  {
    return _new_to_deprecated_coupled_vars;
  }

  /**
   * Return whether or not the coupled variable exists
   * @param coupling_name The name of the coupled variable to test for
   * @return True if the variable exists in the coupled variables for this InputParameters object
   */
  bool hasCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Return whether or not the requested parameter has a default coupled value.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  bool hasDefaultCoupledValue(const std::string &amp; coupling_name) const;

  /**
   * Get the default value for an optionally coupled variable.
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  Real defaultCoupledValue(const std::string &amp; coupling_name, unsigned int i = 0) const;

  /**
   * Get the number of defaulted coupled value entries
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   */
  unsigned int numberDefaultCoupledValues(const std::string &amp; coupling_name) const;

  /**
   * Set the default value for an optionally coupled variable (called by the Parser).
   *
   * @param coupling_name The name of the coupling parameter to get the default value for.
   * @param value Default value to set.
   * @param i By default 0, in general the index of the requested coupled default value.
   */
  void defaultCoupledValue(const std::string &amp; coupling_name, Real value, unsigned int i = 0);

  /**
   * Returns the auto build vectors for all parameters.
   */
  std::map&lt;std::string, std::pair&lt;std::string, std::string&gt;&gt; getAutoBuildVectors() const;

  // BEGIN APPLY PARAMETER METHODS
  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param exclude A vector of parameters to exclude
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applyParameters(const InputParameters &amp; common,
                       std::vector&lt;std::string&gt; exclude = std::vector&lt;std::string&gt;());

  /**
   * Method for applying common parameters
   * @param common The set of parameters to apply to the parameters stored in this object
   * @param include A vector of parameters to apply
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   *
   * Output objects have a set of common parameters that are passed
   * down to each of the output objects created. This method is used for
   * applying those common parameters.
   *
   * @see CommonOutputAction AddOutputAction
   */
  void applySpecificParameters(const InputParameters &amp; common,
                               const std::vector&lt;std::string&gt; &amp; include,
                               bool allow_private = false);

  /**
   * Apply values from a single parameter in common, to a single parameter stored in this object
   * @param common The set of InputParameters from which to extract parameters from
   * @param common_name The name within common from which to get the parameter values
   *
   * In order to apply common parameter 4 statements must be satisfied
   *   (1) A local parameter must exist with the same name as common parameter
   *   (2) Common parameter must valid
   *   (3) Local parameter must be invalid OR not have been set from its default
   *   (4) Both cannot be private
   */
  void applyParameter(const InputParameters &amp; common,
                      const std::string &amp; common_name,
                      bool allow_private = false);
  // END APPLY PARAMETER METHODS

  /**
   * Apply properties of a single coupled variable in common, to a single coupled variable stored in
   * this object
   * @param common The set of InputParameters from which to extract the coupled variable&#x27;s
   * properties
   * @param var_name The name of the coupled variable whose properties are to be applied
   *
   * In order to apply the properties, both the local parameters and the common parameters must
   * have a coupled variable with name var_name
   */
  void applyCoupledVar(const InputParameters &amp; common, const std::string &amp; var_name);

  /**
   * Deprecated method.  Use isParamSetByUser() instead.
   */
  bool paramSetByUser(const std::string &amp; name) const;

  /**
   * Method returns true if the parameter was by the user
   * @param name The parameter name
   */
  bool isParamSetByUser(const std::string &amp; name) const;

  ///@{
  /*
   * These methods are here to retrieve parameters for scalar and vector types respectively. We will
   * throw errors
   * when returning most scalar types, but will allow retrieving empty vectors.
   */
  template &lt;typename T&gt;
  static const T &amp;
  getParamHelper(const std::string &amp; name, const InputParameters &amp; pars, const T * the_type);

  template &lt;typename T&gt;
  static const std::vector&lt;T&gt; &amp; getParamHelper(const std::string &amp; name,
                                               const InputParameters &amp; pars,
                                               const std::vector&lt;T&gt; * the_type);
  ///@}

  using Parameters::get;

  /// Combine two vector parameters into a single vector of pairs
  template &lt;typename R1,
            typename R2,
            typename V1 = typename std::conditional&lt;std::is_same&lt;R1, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R1&gt;&gt;::type,
            typename V2 = typename std::conditional&lt;std::is_same&lt;R2, MooseEnumItem&gt;::value,
                                                    MultiMooseEnum,
                                                    std::vector&lt;R2&gt;&gt;::type&gt;
  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; get(const std::string &amp; param1, const std::string &amp; param2) const;

  /**
   * Return list of controllable parameters
   */
  std::set&lt;std::string&gt; getControllableParameters() const;

  /**
   * Return names of parameters within a group.
   */
  std::set&lt;std::string&gt; getGroupParameters(const std::string &amp; group) const;

  /**
   * Provide a set of reserved values for a parameter. These are values that are in addition
   * to the normal set of values the parameter can take.
   */
  void setReservedValues(const std::string &amp; name, const std::set&lt;std::string&gt; &amp; reserved);

  /**
   * Get a set of reserved parameter values.
   * Returns a set by value since we can return an empty set.
   */
  std::set&lt;std::string&gt; reservedValues(const std::string &amp; name) const;

  ///@{
  /**
   * Get/set a string representing the location (i.e. filename,linenum) in the input text for the
   * block containing parameters for this object.
   */
  std::string &amp; blockLocation() { return _block_location; }
  const std::string &amp; blockLocation() const { return _block_location; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo&quot;) for the block containing parameters for this object.
   */
  std::string &amp; blockFullpath() { return _block_fullpath; }
  const std::string &amp; blockFullpath() const { return _block_fullpath; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the location in the input text the parameter originated from
   * (i.e. filename,linenum) for the given param.
   */
  const std::string &amp; inputLocation(const std::string &amp; param) const
  {
    return at(param)._input_location;
  }
  std::string &amp; inputLocation(const std::string &amp; param) { return at(param)._input_location; }
  ///@}

  ///@{
  /**
   * Get/set a string representing the full HIT parameter path from the input file (e.g.
   * &quot;Mesh/foo/bar&quot; for param &quot;bar&quot;) for the given param.
   */
  const std::string &amp; paramFullpath(const std::string &amp; param) const
  {
    return at(param)._param_fullpath;
  }
  std::string &amp; paramFullpath(const std::string &amp; param) { return at(param)._param_fullpath; }
  ///@}

  /// generate error message prefix with parameter name and location (if available)
  std::string errorPrefix(const std::string &amp; param) const;

  /**
   * Get/set a string representing the raw, unmodified token text for the given param.  This is
   * usually only set/useable for file-path type parameters.
   */
  std::string &amp; rawParamVal(const std::string &amp; param) { return _params[param]._raw_val; }
  const std::string &amp; rawParamVal(const std::string &amp; param) const
  {
    return _params.at(param)._raw_val;
  }

  /**
   * Informs this object that values for this parameter set from the input file or from the command
   * line should be ignored
   */
  template &lt;typename T&gt;
  void ignoreParameter(const std::string &amp; name);

  /**
   * Whether to ignore the value of an input parameter set in the input file or from the command
   * line.
   */
  bool shouldIgnore(const std::string &amp; name);

  /**
   * @returns True if the parameter with name \p name is of type T.
   */
  template &lt;typename T&gt;
  bool isType(const std::string &amp; name) const;

  /**
   * @returns True if these parameters were constructed using the legacy method.
   **/
  bool fromLegacyConstruction() const { return _from_legacy_construction; }

  /**
   * Determine the actual variable name from the given variable \emph parameter name
   * @param var_param_name the name of the variable parameter, e.g. &#x27;variable&#x27;
   * @param moose_object_with_var_param_name the name of the moose object holding the variable
   * parameter. Used for potential error messaging
   */
  std::string varName(const std::string &amp; var_param_name,
                      const std::string &amp; moose_object_with_var_param_name) const;

private:
  // Private constructor so that InputParameters can only be created in certain places.
  InputParameters();

  /**
   * Method to terminate the recursive setParameters definition
   */
  void setParameters() {}

  /**
   * Helper that uses overloading to distinguish adding commandline parameters of
   * a scalar and a vector kind. Vector parameters are options that may appear multiple
   * times on the command line (like -i).
   */
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const std::string &amp; doc_string,
                                 T *);
  template &lt;typename T&gt;
  void addCommandLineParamHelper(const std::string &amp; name,
                                 const std::string &amp; syntax,
                                 const std::string &amp; doc_string,
                                 std::vector&lt;T&gt; *);

  /**
   * Private method for setting deprecated coupled variable documentation strings
   */
  void setDeprecatedVarDocString(const std::string &amp; new_name, const std::string &amp; doc_string);

  struct Metadata
  {
    std::string _doc_string;
    /// The custom type that will be printed in the YAML dump for a parameter if supplied
    std::string _custom_type;
    std::vector&lt;std::string&gt; _cli_flag_names;
    /// The names of the parameters organized into groups
    std::string _group;
    /// The map of functions used for range checked parameters
    std::string _range_function;
    /// directions for auto build vectors (base_, 5) -&gt; &quot;base_0 base_1 base_2 base_3 base_4&quot;)
    std::pair&lt;std::string, std::string&gt; _autobuild_vecs;
    /// True for parameters that are required (i.e. will cause an abort if not supplied)
    bool _required = false;
    /**
     * Whether the parameter is either explicitly set or provided a default value when added
     * Note: We do not store MooseEnum names in valid params, instead we ask MooseEnums whether
     *       they are valid or not.
     */
    bool _valid = false;
    /// The set of parameters that will NOT appear in the the dump of the parser tree
    bool _is_private = false;
    bool _have_coupled_default = false;
    /// The default value for optionally coupled variables
    std::vector&lt;Real&gt; _coupled_default = {0};
    /// True if a parameters value was set by addParam, and not set again.
    bool _set_by_add_param = false;
    /// The reserved option names for a parameter
    std::set&lt;std::string&gt; _reserved_values;
    /// If non-empty, this parameter is deprecated.
    std::string _deprecation_message;
    /// original location of parameter (i.e. filename,linenum) - used for nice error messages.
    std::string _input_location;
    /// full HIT path of the parameter from the input file - used for nice error messages.
    std::string _param_fullpath;
    /// raw token text for a parameter - usually only set for filepath type params.
    std::string _raw_val;
    /// True if the parameters is controllable
    bool _controllable = false;
    /// Controllable execute flag restriction
    std::set&lt;ExecFlagType&gt; _controllable_flags;
    /// whether user setting of this parameter should be ignored
    bool _ignore = false;
  };

  Metadata &amp; at(const std::string &amp; param)
  {
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params[param];
  }
  const Metadata &amp; at(const std::string &amp; param) const
  {
    if (_params.count(param) == 0)
      mooseError(&quot;param &#x27;&quot;, param, &quot;&#x27; not present in InputParams&quot;);
    return _params.at(param);
  }

  /**
   * Toggle the availability of the copy constructor
   *
   * When MooseObject is created via the Factory this flag is set to false, so when a MooseObject is
   * created if
   * the constructor is not a const reference an error is produced. This method allows the
   * InputParameterWarehouse
   * to disable copying.
   */
  void allowCopy(bool status) { _allow_copy = status; }

  /**
   * Make sure the parameter name doesn&#x27;t have any invalid characters.
   */
  void checkParamName(const std::string &amp; name) const;

  /**
   * This method is called when adding a Parameter with a default value, can be specialized for
   * non-matching types.
   */
  template &lt;typename T, typename S&gt;
  void setParamHelper(const std::string &amp; name, T &amp; l_value, const S &amp; r_value);

  /// original location of input block (i.e. filename,linenum) - used for nice error messages.
  std::string _block_location;

  /// full HIT path of the block from the input file - used for nice error messages.
  std::string _block_fullpath;

  /// The actual parameter data. Each Metadata object contains attributes for the corresponding
  /// parameter.
  std::map&lt;std::string, Metadata&gt; _params;

  /// The coupled variables set
  std::set&lt;std::string&gt; _coupled_vars;

  /// The class description for the owning object. This string is used in many places including
  /// mouse-over events, and external documentation produced from the source code.
  std::string _class_description;

  /// The parameter is used to restrict types that can be built.  Typically this is used for
  /// MooseObjectAction derived Actions.
  std::vector&lt;std::string&gt; _buildable_types;

  /// The RelationshipManagers that this object may either build or require.
  /// The optional second argument may be supplied to &quot;downgrade&quot; the functionality of the corresponding
  /// relationship manager (e.g. An AlgebraicRelationshipManager could be only used as a
  /// GeometricRelationshipManager for a given simulation).
  std::vector&lt;std::tuple&lt;std::string,
                         Moose::RelationshipManagerType,
                         Moose::RelationshipManagerInputParameterCallback&gt;&gt;
      _buildable_rm_types;

  /// This parameter collapses one level of nesting in the syntax blocks.  It is used
  /// in conjunction with MooseObjectAction derived Actions.
  bool _collapse_nesting;

  /// This parameter hides derived MOOSE object types from appearing in syntax dumps
  bool _moose_object_syntax_visibility;

  /// Flag for disabling deprecated parameters message, this is used by applyParameters to avoid
  /// dumping messages.
  bool _show_deprecated_message;

  /// A flag for toggling the error message in the copy constructor.
  bool _allow_copy;

  /// Whether or not these parameters were constructed using legacy contruction (remove with #19440)
  bool _from_legacy_construction;

  /// A map from deprecated coupled variable names to the new blessed name
  std::unordered_map&lt;std::string, std::string&gt; _new_to_deprecated_coupled_vars;

  // These are the only objects allowed to _create_ InputParameters
  friend InputParameters emptyInputParameters();
  friend class InputParameterWarehouse;
  friend class Parser;
  // for the printInputFile function in the action warehouse
  friend class ActionWarehouse;

  // For setting _from_legacy_construction (remove with #19440)
  template &lt;typename T&gt;
  friend InputParameters validParams();
};

template &lt;typename T&gt;
void
InputParameters::setHelper(const std::string &amp; /*name*/)
{
}

// Template and inline function implementations
template &lt;typename T&gt;
T &amp;
InputParameters::set(const std::string &amp; name, bool quiet_mode)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; result = this-&gt;Parameters::set&lt;T&gt;(name);

  if (quiet_mode)
    _params[name]._set_by_add_param = true;

  setHelper&lt;T&gt;(name);

  return result;
}

template &lt;typename T, typename... Ts&gt;
void
InputParameters::setParameters(const std::string &amp; name,
                               const T &amp; value,
                               Ts... extra_input_parameters)
{
  this-&gt;set&lt;T&gt;(name) = value;
  this-&gt;setParameters(extra_input_parameters...);
}

template &lt;typename T, typename UP_T&gt;
void
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            InputParameters::Parameter&lt;std::vector&lt;T&gt;&gt; * param,
                            std::ostream &amp; oss)
{
  mooseAssert(param, &quot;Parameter is NULL&quot;);

  if (!isParamValid(short_name) || _params[short_name]._range_function.empty())
    return;

  /**
   * Automatically detect the variables used in the range checking expression.
   * We allow the following variables (where snam is the short_name of the parameter)
   *
   * snam       : tests every component in the vector
   *              &#x27;snam &gt; 0&#x27;
   * snam_size  : the size of the vector
   *              &#x27;snam_size = 5&#x27;
   * snam_i     : where i is a number from 0 to sname_size-1 tests a specific component
   *              &#x27;snam_0 &gt; snam_1&#x27;
   */
  FunctionParserBase&lt;UP_T&gt; fp;
  std::vector&lt;std::string&gt; vars;
  if (fp.ParseAndDeduceVariables(_params[short_name]._range_function, vars) != -1) // -1 for success
  {
    oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
    return;
  }

  // Fparser parameter buffer
  std::vector&lt;UP_T&gt; parbuf(vars.size());

  // parameter vector
  const std::vector&lt;T&gt; &amp; value = param-&gt;set();

  // iterate over all vector values (maybe ;)
  bool need_to_iterate = false;
  unsigned int i = 0;
  do
  {
    // set parameters
    for (unsigned int j = 0; j &lt; vars.size(); j++)
    {
      if (vars[j] == short_name)
      {
        if (value.size() == 0)
        {
          oss &lt;&lt; &quot;Range checking empty vector: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
          return;
        }

        parbuf[j] = value[i];
        need_to_iterate = true;
      }
      else if (vars[j] == short_name + &quot;_size&quot;)
        parbuf[j] = value.size();
      else
      {
        if (vars[j].substr(0, short_name.size() + 1) != short_name + &quot;_&quot;)
        {
          oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
          return;
        }
        std::istringstream iss(vars[j]);
        iss.seekg(short_name.size() + 1);

        size_t index;
        if (iss &gt;&gt; index &amp;&amp; iss.eof())
        {
          if (index &gt;= value.size())
          {
            oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function
                &lt;&lt; &quot;\nOut of range variable &quot; &lt;&lt; vars[j] &lt;&lt; &#x27;\n&#x27;;
            return;
          }
          parbuf[j] = value[index];
        }
        else
        {
          oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function
              &lt;&lt; &quot;\nInvalid variable &quot; &lt;&lt; vars[j] &lt;&lt; &#x27;\n&#x27;;
          return;
        }
      }
    }

    // ensure range-checked input file parameter comparison functions
    // do absolute floating point comparisons instead of using a default epsilon.
    auto tmp_eps = fp.epsilon();
    fp.setEpsilon(0);
    UP_T result = fp.Eval(&amp;parbuf[0]);
    fp.setEpsilon(tmp_eps);

    // test function using the parameters determined above
    if (fp.EvalError())
    {
      oss &lt;&lt; &quot;Error evaluating expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
      return;
    }

    if (!result)
    {
      oss &lt;&lt; &quot;Range check failed for parameter &quot; &lt;&lt; full_name
          &lt;&lt; &quot;\n\tExpression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &quot;\n&quot;;
      if (need_to_iterate)
        oss &lt;&lt; &quot;\t Component: &quot; &lt;&lt; i &lt;&lt; &#x27;\n&#x27;;
    }

  } while (need_to_iterate &amp;&amp; ++i &lt; value.size());
}

template &lt;typename T, typename UP_T&gt;
void
InputParameters::rangeCheck(const std::string &amp; full_name,
                            const std::string &amp; short_name,
                            InputParameters::Parameter&lt;T&gt; * param,
                            std::ostream &amp; oss)
{
  mooseAssert(param, &quot;Parameter is NULL&quot;);

  if (!isParamValid(short_name) || _params[short_name]._range_function.empty())
    return;

  // Parse the expression
  FunctionParserBase&lt;UP_T&gt; fp;
  if (fp.Parse(_params[short_name]._range_function, short_name) != -1) // -1 for success
  {
    oss &lt;&lt; &quot;Error parsing expression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &#x27;\n&#x27;;
    return;
  }

  // ensure range-checked input file parameter comparison functions
  // do absolute floating point comparisons instead of using a default epsilon.
  auto tmp_eps = fp.epsilon();
  fp.setEpsilon(0);
  // We require a non-const value for the implicit upscaling of the parameter type
  std::vector&lt;UP_T&gt; value(1, param-&gt;set());
  UP_T result = fp.Eval(&amp;value[0]);
  fp.setEpsilon(tmp_eps);

  if (fp.EvalError())
  {
    oss &lt;&lt; &quot;Error evaluating expression: &quot; &lt;&lt; _params[short_name]._range_function
        &lt;&lt; &quot;\nPerhaps you used the wrong variable name?\n&quot;;
    return;
  }

  if (!result)
    oss &lt;&lt; &quot;Range check failed for parameter &quot; &lt;&lt; full_name
        &lt;&lt; &quot;\n\tExpression: &quot; &lt;&lt; _params[short_name]._range_function &lt;&lt; &quot;\n\tValue: &quot; &lt;&lt; value[0]
        &lt;&lt; &#x27;\n&#x27;;
}

template &lt;typename T&gt;
T
InputParameters::getCheckedPointerParam(const std::string &amp; name,
                                        const std::string &amp; error_string) const
{
  T param = this-&gt;get&lt;T&gt;(name);

  // Note: You will receive a compile error on this line if you attempt to pass a non-pointer
  // template type to this method
  if (param == NULL)
    mooseError(&quot;Parameter &quot;, name, &quot; is NULL.\n&quot;, error_string);
  return this-&gt;get&lt;T&gt;(name);
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._required = true;
  _params[name]._doc_string = doc_string;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredParam(const std::string &amp; /*name*/,
                                  const T &amp; /*value*/,
                                  const std::string &amp; /*doc_string*/)
{
  mooseError(&quot;You cannot call addRequiredParam and supply a default value for this type, please &quot;
             &quot;use addParam instead&quot;);
}

template &lt;typename T, typename S&gt;
void
InputParameters::addParam(const std::string &amp; name, const S &amp; value, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  T &amp; l_value = InputParameters::set&lt;T&gt;(name);
  _params[name]._doc_string = doc_string;

  // Set the parameter now
  setParamHelper(name, l_value, value);

  /* Indicate the default value, as set via addParam, is being used. The parameter is removed from
     the list whenever
     it changes, see set_attributes */
  _params[name]._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addParam(const std::string &amp; name, const std::string &amp; doc_string)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._doc_string = doc_string;
}

template &lt;typename T, typename S&gt;
void
InputParameters::setParamHelper(const std::string &amp; /*name*/, T &amp; l_value, const S &amp; r_value)
{
  l_value = r_value;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredRangeCheckedParam(const std::string &amp; name,
                                              const std::string &amp; parsed_function,
                                              const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const T &amp; value,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRangeCheckedParam(const std::string &amp; name,
                                      const std::string &amp; parsed_function,
                                      const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._range_function = parsed_function;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCustomTypeParam(const std::string &amp; name,
                                            const std::string &amp; custom_type,
                                            const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addCustomTypeParam(const std::string &amp; name,
                                    const std::string &amp; custom_type,
                                    const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  _params[name]._custom_type = custom_type;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::insert&lt;T&gt;(name);
  _params[name]._is_private = true;
}

template &lt;typename T&gt;
void
InputParameters::addPrivateParam(const std::string &amp; name, const T &amp; value)
{
  checkParamName(name);
  checkConsistentType&lt;T&gt;(name);

  InputParameters::set&lt;T&gt;(name) = value;
  _params[name]._is_private = true;
  _params[name]._set_by_add_param = true;
}

template &lt;typename T&gt;
void
InputParameters::addRequiredCommandLineParam(const std::string &amp; name,
                                             const std::string &amp; syntax,
                                             const std::string &amp; doc_string)
{
  addRequiredParam&lt;T&gt;(name, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::addCommandLineParam(const std::string &amp; name,
                                     const std::string &amp; syntax,
                                     const T &amp; value,
                                     const std::string &amp; doc_string)
{
  addParam&lt;T&gt;(name, value, doc_string);
  MooseUtils::tokenize(syntax, _params[name]._cli_flag_names, 1, &quot; \t\n\v\f\r&quot;);
}

template &lt;typename T&gt;
void
InputParameters::checkConsistentType(const std::string &amp; name) const
{
  // If we don&#x27;t currently have the Parameter, can&#x27;t be any inconsistency
  InputParameters::const_iterator it = _values.find(name);
  if (it == _values.end())
    return;

  // Now, if we already have the Parameter, but it doesn&#x27;t have the
  // right type, throw an error.
  if (!this-&gt;Parameters::have_parameter&lt;T&gt;(name))
    mooseError(&quot;Attempting to set parameter \&quot;&quot;,
               name,
               &quot;\&quot; with type (&quot;,
               demangle(typeid(T).name()),
               &quot;)\nbut the parameter already exists as type (&quot;,
               it-&gt;second-&gt;type(),
               &quot;)&quot;);
}

template &lt;typename T&gt;
void
InputParameters::suppressParameter(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to suppress nonexistent parameter: &quot;, name);

  _params[name]._required = false;
  _params[name]._is_private = true;
  _params[name]._controllable = false;
}

template &lt;typename T&gt;
void
InputParameters::ignoreParameter(const std::string &amp; name)
{
  suppressParameter&lt;T&gt;(name);
  _params[name]._ignore = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamRequired(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to require nonexistent parameter: &quot;, name);

  _params[name]._required = true;
}

template &lt;typename T&gt;
void
InputParameters::makeParamNotRequired(const std::string &amp; name)
{
  if (!this-&gt;have_parameter&lt;T&gt;(name))
    mooseError(&quot;Unable to un-require nonexistent parameter: &quot;, name);

  _params[name]._required = false;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const T &amp; value,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, value, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

template &lt;typename T&gt;
void
InputParameters::addDeprecatedParam(const std::string &amp; name,
                                    const std::string &amp; doc_string,
                                    const std::string &amp; deprecation_message)
{
  _show_deprecated_message = false;
  addParam&lt;T&gt;(name, doc_string);

  _params[name]._deprecation_message = deprecation_message;
  _show_deprecated_message = true;
}

// Forward declare MooseEnum specializations for add*Param
template &lt;&gt;
void InputParameters::addRequiredParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                  const MooseEnum &amp; moose_enum,
                                                  const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                       const MultiMooseEnum &amp; moose_enum,
                                                       const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addRequiredParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::vector&lt;MooseEnum&gt; &amp; moose_enums,
    const std::string &amp; doc_string);

template &lt;&gt;
void InputParameters::addParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/,
                                          const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/,
                                               const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addParam&lt;std::vector&lt;MooseEnum&gt;&gt;(const std::string &amp; /*name*/,
                                                       const std::string &amp; /*doc_string*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addPrivateParam&lt;MultiMooseEnum&gt;(const std::string &amp; /*name*/);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MooseEnum&gt;(const std::string &amp; name,
                                                    const std::string &amp; doc_string,
                                                    const std::string &amp; deprecation_message);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                         const std::string &amp; doc_string,
                                                         const std::string &amp; deprecation_message);

template &lt;&gt;
void InputParameters::addDeprecatedParam&lt;std::vector&lt;MooseEnum&gt;&gt;(
    const std::string &amp; name,
    const std::string &amp; doc_string,
    const std::string &amp; deprecation_message);

// Forward declare specializations for setParamHelper
template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, Real&gt;(const std::string &amp; name,
                                                              PostprocessorName &amp; l_value,
                                                              const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;PostprocessorName, int&gt;(const std::string &amp; name,
                                                             PostprocessorName &amp; l_value,
                                                             const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, Real&gt;(const std::string &amp; /*name*/,
                                                         FunctionName &amp; l_value,
                                                         const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;FunctionName, int&gt;(const std::string &amp; /*name*/,
                                                        FunctionName &amp; l_value,
                                                        const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, Real&gt;(const std::string &amp; /*name*/,
                                                                 MaterialPropertyName &amp; l_value,
                                                                 const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MaterialPropertyName, int&gt;(const std::string &amp; /*name*/,
                                                                MaterialPropertyName &amp; l_value,
                                                                const int &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, Real&gt;(const std::string &amp; /*name*/,
                                                             MooseFunctorName &amp; l_value,
                                                             const Real &amp; r_value);

template &lt;&gt;
void InputParameters::setParamHelper&lt;MooseFunctorName, int&gt;(const std::string &amp; /*name*/,
                                                            MooseFunctorName &amp; l_value,
                                                            const int &amp; r_value);

template &lt;typename T&gt;
const T &amp;
InputParameters::getParamHelper(const std::string &amp; name, const InputParameters &amp; pars, const T *)
{
  if (!pars.isParamValid(name))
    mooseError(&quot;The parameter \&quot;&quot;, name, &quot;\&quot; is being retrieved before being set.\n&quot;);

  return pars.get&lt;T&gt;(name);
}

// Declare specializations so we don&#x27;t fall back on the generic
// implementation, but the definition will be in InputParameters.C so
// we won&#x27;t need to bring in *MooseEnum header files here.
template &lt;&gt;
const MooseEnum &amp; InputParameters::getParamHelper&lt;MooseEnum&gt;(const std::string &amp; name,
                                                             const InputParameters &amp; pars,
                                                             const MooseEnum *);

template &lt;&gt;
const MultiMooseEnum &amp; InputParameters::getParamHelper&lt;MultiMooseEnum&gt;(const std::string &amp; name,
                                                                       const InputParameters &amp; pars,
                                                                       const MultiMooseEnum *);

template &lt;typename T&gt;
const std::vector&lt;T&gt; &amp;
InputParameters::getParamHelper(const std::string &amp; name,
                                const InputParameters &amp; pars,
                                const std::vector&lt;T&gt; *)
{
  return pars.get&lt;std::vector&lt;T&gt;&gt;(name);
}

template &lt;typename R1, typename R2, typename V1, typename V2&gt;
std::vector&lt;std::pair&lt;R1, R2&gt;&gt;
InputParameters::get(const std::string &amp; param1, const std::string &amp; param2) const
{
  const auto &amp; v1 = get&lt;V1&gt;(param1);
  const auto &amp; v2 = get&lt;V2&gt;(param2);

  auto controllable = getControllableParameters();
  if (controllable.count(param1) || controllable.count(param2))
    mooseError(errorPrefix(param1),
               &quot; and/or &quot;,
               errorPrefix(param2) +
                   &quot; are controllable parameters and cannot be retireved using &quot;
                   &quot;the MooseObject::getParam/InputParameters::get methods for pairs&quot;);

  if (v1.size() != v2.size())
    mooseError(&quot;Vector parameters &quot;,
               errorPrefix(param1),
               &quot;(size: &quot;,
               v1.size(),
               &quot;) and &quot; + errorPrefix(param2),
               &quot;(size: &quot;,
               v2.size(),
               &quot;) are of different lengths \n&quot;);

  std::vector&lt;std::pair&lt;R1, R2&gt;&gt; parameter_pairs;
  auto i1 = v1.begin();
  auto i2 = v2.begin();
  for (; i1 != v1.end() &amp;&amp; i2 != v2.end(); ++i1, ++i2)
    parameter_pairs.emplace_back(std::make_pair(*i1, *i2));
  return parameter_pairs;
}

InputParameters emptyInputParameters();

template &lt;typename T&gt;
bool
InputParameters::isType(const std::string &amp; name) const
{
  if (!_params.count(name))
    mooseError(&quot;Parameter \&quot;&quot;, name, &quot;\&quot; is not valid.&quot;);
  return have_parameter&lt;T&gt;(name);
}

template &lt;class T&gt;
InputParameters
validParams()
{
  // If users forgot to make their (old) validParams, they screwed up and
  // should get an error - so it is okay for us to try to call the new
  // validParams static function - which will error if they didn&#x27;t implement
  // the new function
  auto params = T::validParams();

  // If calling the static member method worked, we didn&#x27;t build these parameters
  // using the legacy method. Therefore, we won&#x27;t throw an error for this object
  // in CheckLegacyParamsAction. This should be removed with the closure of #19439.
  params._from_legacy_construction = false;

  return params;
}

namespace moose
{
namespace internal
{
/**
 * Calls the valid parameter method for the object of type T.
 *
 * This isn&#x27;t necessary anymore, but is hanging around until we finally
 * get rid of all mention of the legacy parameter construction. Once
 * #19439 is closed, we can replace
 * moose::internal::callValidParams&lt;T&gt;() -&gt; T::validParams(), and we
 * should return T::validParams() here instead.
 */
template &lt;typename T&gt;
InputParameters
callValidParams()
{
  return validParams&lt;T&gt;();
}
}
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#93205266-a7ac-4d86-9186-3bfa617710a5" class="tooltipped" data-position="left" data-tooltip="Applying or Transferring Common Parameters">Applying or Transferring Common Parameters</a></li><li><a href="#9f58781f-7d0b-4122-b63f-98b23b1b9c52" class="tooltipped" data-position="left" data-tooltip="Range Checked Parameters">Range Checked Parameters</a></li><li><a href="#2c1209bb-f948-4c98-8b01-bc74498c9181" class="tooltipped" data-position="left" data-tooltip="Deprecating coupled variables">Deprecating coupled variables</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>