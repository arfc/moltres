<!DOCTYPE html><head><meta charset="UTF-8"><title>NestedSolve | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="06c933fe-4583-410a-9c48-23b3331423bf" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="2bc88cfb-ef0e-452b-b0ab-19cb071f3ce9" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="570521ce-32e5-4948-b7ff-5c439083834e" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="c8919f85-4c6b-4eb0-a17b-bfc581e954a3"><i class="material-icons">menu</i></a><ul class="sidenav" id="c8919f85-4c6b-4eb0-a17b-bfc581e954a3"><li><a href="#!" class="dropdown-trigger" data-target="bb2b4124-94f0-47ce-a9f6-6475fb482a15" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="13443f85-446d-4696-b08e-9dc80373ea8a" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="9cc76a0d-f1b8-4758-b1d3-fd900cb791b9" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="06c933fe-4583-410a-9c48-23b3331423bf"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="2bc88cfb-ef0e-452b-b0ab-19cb071f3ce9"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="570521ce-32e5-4948-b7ff-5c439083834e"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="bb2b4124-94f0-47ce-a9f6-6475fb482a15"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="13443f85-446d-4696-b08e-9dc80373ea8a"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="9cc76a0d-f1b8-4758-b1d3-fd900cb791b9"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">utils</span><a href="#" class="breadcrumb">NestedSolve</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="3b06e131-2ba7-49e4-adbc-b180a858d53f" data-section-level="1" data-section-text="NestedSolve"><h1 id="nestedsolve">NestedSolve</h1><section class="scrollspy" id="069e46bc-a174-4191-96fd-ec6d66e97ba2" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>The <code>NestedSolve</code> utility class implements a nonlinear solve for NxN systems. It can be used in Kernels, Materials, and UserObjects to compute quantities given by the solution of a nonlinear equation system rather than a closed form expression.</p><p>Such a nonlinear equation system is defined by a residual function and a Jacobian function. These functions are provided as C++11 lambda expression. A lambda expression can access all local and member variables from the enclosing scope. In this application that mainly refers to coupled variable values and material properties available in the class the NestedSolve is utilized.</p><section id="d4f4ed0f-491b-4df8-b9f3-8bcd12023c16" data-section-level="3" data-section-text="Basic API"><h3 id="basic-api">Basic API</h3><p><code>NestedSolve</code> is a C++ class object needs to be instantiated (constructed) to set up a solver environment. This solver environment can be a local or member variable of the object it is used within.</p><p>The purpose of the solve environment is to store <em>solver options</em>, such as tolerances, and <em>solver state</em>, such as convergence reason or failure state of the previous solve. A solve environment can be reused for multiple solves.</p><p>The main API of <code>NestedSolve</code> is the <code>nonlinear</code> member function, which exists in two flavors:</p><ol class="browser-default" start="1"><li><p><code>NestedSolve::nonlinear(T &amp; guess, L compute)</code>, which takes a writable reference to a variable if type <code>T</code> that contains an initial guess for the solution going into the function, and the solution once the call completes. <code>compute</code> is a lambda expression that takes references to the current solution value, the residual, and the Jacobian, and needs to update the latter two. </p></li><li><p><code>NestedSolve::nonlinear(T &amp; guess, LR computeResidual, LJ computeJacobian)</code> behaves largely similar to the first overload, but it takes two separate lambdas for computing the residual and the Jacobian independently. This enables the efficient use of line search and trust region algorithms internally.</p></li></ol></section><section id="33ebf8fd-4065-45c7-93b9-6daf44a71a85" data-section-level="3" data-section-text="Supported data types"><h3 id="supported-data-types">Supported data types</h3><p>The recommended data types for the solution/residual (<code>T</code>) and Jacobian are Eigen&#x27;s dynamic size Matrix objects. the <code>NestedSolve::Value&lt;&gt;</code> and <code>NestedSolve::Jacobian&lt;&gt;</code> typedefs are available as shortcuts for those types.</p><p>Specializations and overloads exist for the <code>nonlinear</code> solve API to deal with the special cases of 1x1 systems (with the solution,residual, and Jacobians being <code>Real</code> scalars), and for 3x3 systems (with the solution and residual bein <code>RealVectorValues</code> and Jacobians being <code>RankTwoTensor</code> values). The correct overload is picked based on the type <code>T</code> of the initial <code>guess</code> parameter.</p></section><section id="37b5b351-9e15-4fb4-a584-235f6583a0bf" data-section-level="3" data-section-text="Checking convergence state"><h3 id="checking-convergence-state">Checking convergence state</h3><p>The state of a solve can be checked using the <code>getSolve()</code> method. This returns an enumeration describing how the solve converged or if it did not converge. The enumeration can take the following values:</p><ul class="browser-default"><li><p><code>NestedSolve::State::NONE</code>: No solve has begun. This is the initial value. </p></li><li><p><code>NestedSolve::State::CONVERGED_ABS</code>: The solve converged due to meeting an absolute tolerance. </p></li><li><p><code>NestedSolve::State::CONVERGED_REL</code>: The solve converged due to meeting a relative tolerance. </p></li><li><p><code>NestedSolve::State::EXACT_GUESS</code>: The solve converged due to the initial guess giving a zero residual. </p></li><li><p><code>NestedSolve::State::NOT_CONVERGED</code>: The solve did not converge.</p></li></ul><p>Note that in the case that both the absolute and relative tolerances being met simultaneously, the value <code>NestedSolve::State::CONVERGED_REL</code> will be returned.</p></section></section><section class="scrollspy" id="714466dc-ad06-42e6-b18a-a40541fa1765" data-section-level="2" data-section-text="Example"><h2 id="example">Example</h2><section id="f80f228c-fa94-4a82-9001-b1717b84f00e" data-section-level="3" data-section-text="Basic usage"><h3 id="basic-usage">Basic usage</h3><p>We first construct a <code>NestedSolve</code> object. This object can be reused for multiple solves, and could be a member of the class you are using it in.</p><pre class="moose-pre"><code class="language-text">
NestedSolve solver;
</code></pre><p>Next we set the solution (vector) type. <code>NestedSolve::Value&lt;&gt;</code> is a dynamicly sized vector class from the Eigen library. Eigen uses the <code>&lt;&lt;</code> operator to initialize such a vector (two components in this case).</p><pre class="moose-pre"><code class="language-text">
NestedSolve::Value&lt;&gt; solution(2);
solution &lt;&lt; 1.98, 1.02;
</code></pre><p>Next we set a custom relative tolerance. The default value here is 1e-8.</p><pre class="moose-pre"><code class="language-text">
solver.setRelativeTolerance(1e-10);
</code></pre><p>Next we define the residual and Jacobian functions. Here we use a single lambda with three arguments:</p><ol class="browser-default" start="1"><li><p>The first argument is the current guess for the solution and is the _input_ to the functions, it is a vector of length N (or a scalar). </p></li><li><p>Argument two is a writable reference to the residual vector (of the same size as the current guess), the value of which is to be calculated by the lambda. </p></li><li><p>This is followed by the Jacobian matrix of the system, the derivative of the resdual vector with respect to the guess/solution.</p></li></ol><pre class="moose-pre"><code class="language-text">
auto compute = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                   NestedSolve::Value&lt;&gt; &amp; residual,
                   NestedSolve::Jacobian&lt;&gt; &amp; jacobian) {
  residual(0) = guess(0) + guess(0) * guess(1) - 4;
  residual(1) = guess(0) + guess(1) - 3;

  jacobian(0, 0) = 1 + guess(1);
  jacobian(0, 1) = guess(0);
  jacobian(1, 0) = 1;
  jacobian(1, 1) = 1;
};
</code></pre><p>Note that <code>jacobian(i,j)</code> is the derivative of <code>residual(i)</code> with respect to <code>guess(j)</code>.</p><p>Lastly we pass the initial guess along with the residual/Jacobian <code>compute</code> lambda to the <code>NestedSolve::nonlinear</code> method.</p><pre class="moose-pre"><code class="language-text">
solver.nonlinear(solution, compute);
</code></pre><p><code>solution</code> will now be updated from the initial guess to the actual solution of the system.</p><p>Then to check that the solve was successful, one can do the following:</p><pre class="moose-pre"><code class="language-text">
if (solver.getState() == NestedSolve::State::NOT_CONVERGED)
{
  // Take some action for the case of no convergence.
}
</code></pre></section><section id="9e1c78e6-9f33-428c-9335-54b92e7e576b" data-section-level="3" data-section-text="Powell ' s Dogleg method solver"><h3 id="powell-s-dogleg-method-solver">Powell&#x27;s Dogleg method solver</h3><p>While the previous example used a single lambda to compute residual and Jacobian at the same time, we can instead change the code to have sparate lambdas to allow independent calculation of residual and Jacobian. This facilitates the use of solver methods that evaluate the residual more frequantly than the Jacobian, such as line search and trust region strategies.</p><pre class="moose-pre"><code class="language-text">
auto computeResidual = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                           NestedSolve::Value&lt;&gt; &amp; residual) {
  residual(0) = guess(0) + guess(0) * guess(1) - 4;
  residual(1) = guess(0) + guess(1) - 3;
};

auto computeJacobian = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                           NestedSolve::Jacobian&lt;&gt; &amp; jacobian) {
  jacobian(0, 0) = 1 + guess(1);
  jacobian(0, 1) = guess(0);
  jacobian(1, 0) = 1;
  jacobian(1, 1) = 1;
};
</code></pre><p>We then use the three argument version of the <code>nonlinear</code> method</p><pre class="moose-pre"><code class="language-text">
solver.nonlinear(solution, computeResidual, computeJacobian);
</code></pre></section></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#069e46bc-a174-4191-96fd-ec6d66e97ba2" class="tooltipped" data-position="left" data-tooltip="Overview">Overview</a></li><li><a href="#714466dc-ad06-42e6-b18a-a40541fa1765" class="tooltipped" data-position="left" data-tooltip="Example">Example</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>