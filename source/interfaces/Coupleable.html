<!DOCTYPE html><head><meta charset="UTF-8"><title>Coupleable | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="8a9fc131-46e2-4251-b391-63be1dd4c3b2" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b461061a-bba2-49e2-9d7d-10050c2a2b82" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1b29d7ef-ecf1-49e8-bb8e-9139c665270f" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="b92c1d69-470b-4e17-9444-662cecb94ac2"><i class="material-icons">menu</i></a><ul class="sidenav" id="b92c1d69-470b-4e17-9444-662cecb94ac2"><li><a href="#!" class="dropdown-trigger" data-target="90a736c5-3fa3-4a65-b201-65e60cfddbc4" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8da5b622-f40b-4644-b893-bd3e05d5713e" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c3f3f5eb-5b54-4b31-ba37-abdfd32b132d" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="8a9fc131-46e2-4251-b391-63be1dd4c3b2"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="b461061a-bba2-49e2-9d7d-10050c2a2b82"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="1b29d7ef-ecf1-49e8-bb8e-9139c665270f"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="90a736c5-3fa3-4a65-b201-65e60cfddbc4"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="8da5b622-f40b-4644-b893-bd3e05d5713e"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="c3f3f5eb-5b54-4b31-ba37-abdfd32b132d"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">interfaces</span><a href="#" class="breadcrumb">Coupleable</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="a0981ee5-e1c4-4fe1-85a8-b4aaff646f67" data-section-level="1" data-section-text="Coupleable"><h1 id="coupleable">Coupleable</h1><p>This class provides API for coupling different kinds of variables values into MOOSE systems. The following table summarizes the methods and kinds of values they provide:</p><div form="['center', 'center']" recursive class="moose-table-div"><table><thead><tr><th style=";text-align:center">Method</th><th style=";text-align:center">Description</th></tr></thead><tbody><tr><td style=";text-align:center">coupledValue</td><td style=";text-align:center">Values of a coupled variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledGradient</td><td style=";text-align:center">Gradients of a coupled variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledSecond</td><td style=";text-align:center">Second derivatives of a coupled variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">adCoupledValue</td><td style=";text-align:center">Values of a coupled variable in q-points with automatic differentiation info</td></tr></tbody><tbody><tr><td style=";text-align:center">adCoupledGradient</td><td style=";text-align:center">Gradients of a coupled variable in q-points with automatic differentiation info</td></tr></tbody><tbody><tr><td style=";text-align:center">adCoupledSecond</td><td style=";text-align:center">Second derivatives of a coupled variable in q-points with automatic differentiation info</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledNodalValue</td><td style=";text-align:center">Values of a coupled variable at nodes.</td></tr></tbody><tbody><tr><td style=";text-align:center">adCoupledNodalValue</td><td style=";text-align:center">Values of a coupled (vector) variable at nodes with automatic differentiation info</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledVectorValue</td><td style=";text-align:center">Values of a coupled vector variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">adCoupledVectorValue</td><td style=";text-align:center">Values of a coupled vector variable in q-points with automatic differentiation info</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledCurl</td><td style=";text-align:center">Curl of a coupled vector variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledDot</td><td style=";text-align:center">Time derivative of a coupled variable</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledDotDu</td><td style=";text-align:center">Derivative of a time derivative of a coupled variable</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledNodalDot</td><td style=";text-align:center">Nodal value of the time derivative of a coupled variable</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledVectorDot</td><td style=";text-align:center">Time derivative of a coupled vector variable</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledVectorDotDu</td><td style=";text-align:center">Derivative of a time derivative of a coupled vector variable</td></tr></tbody><tbody><tr><td style=";text-align:center">adCoupledLowerValue</td><td style=";text-align:center">Value a coupled lower-dimensional variable with automatic differentiation info</td></tr></tbody></table></div><p>For values, gradients and second derivatives, users can request old and older values in case they are running a transient simulation. In case of old and older values, the methods are called <code>coupledValueOld</code> and <code>coupledValueOlder</code>, respectively. Similarly,</p><section class="scrollspy" id="093ff660-30a9-46b4-9a9e-06672fcfbf17" data-section-level="2" data-section-text="Optional Coupling"><h2 id="optional-coupling">Optional Coupling</h2><p>To determine if a variable was coupled, users can use <code>isCoupled</code> method. The typical use case looks like this:</p><pre class="moose-pre"><code class="language-text">
_value(isCoupled(&quot;v&quot;) ? coupledValue(&quot;v&quot;) : _zero)
</code></pre><p>However, this use case became obsolete and now it is recommended to use default values for optionally coupled variables, see the following example:</p><pre class="moose-pre"><code class="language-text">
InputParameters
Class::validParams()
{
  InputParameters params = BaseClass::validParams();
  params.addCoupledVar(&quot;v&quot;, 2., &quot;Coupled value&quot;);
  ...
  return params;
}

Class::Class(...) : BaseClass(...),
  _v(coupledValue(&#x27;v&#x27;))
</code></pre><p>The advantage here is that users can provide arbitrary default values to their variables.</p></section><section class="scrollspy" id="fbfe203b-0af9-46aa-973c-33c4447ffd57" data-section-level="2" data-section-text="Coupling of Vectors of Variables"><h2 id="coupling-of-vectors-of-variables">Coupling of Vectors of Variables</h2><p>Users can couple a vector of variables using the following syntax:</p><pre class="moose-pre"><code class="language-text">
v = &#x27;a b c&#x27;
</code></pre><p>This syntax provides 3 variables coupled as a variable <code>v</code> in a MOOSE object using the <code>Coupleable</code> interface. The number of components coupled into can be obtained by <code>coupledComponents</code> method. Then, individual components can be obtained by calling <code>coupledValue</code> (or any other method mentioned above) passing in the variable name (as usual) and the component index. See the following example:</p><p>Declarations:</p><pre class="moose-pre"><code class="language-text">
class B : public A
{
  ...
protected:
  unsigned int _n_vars;
  std::vector&lt;MooseVariable *&gt; _vars;
};
</code></pre><p>Implementation:</p><pre class="moose-pre"><code class="language-text">
InputParameters
B::validParams()
{
  InputParameters params = A::validParams();
  params.addRequiredCoupledVar(&quot;v&quot;, &quot;Coupled value&quot;);
  ...
  return params;
}

B::B(...) : A(...),
  _n_vars(coupledComponents(&quot;v&quot;))
{
  for (unsigned int i = 0; i &lt; _n_vars; i++)
    _vars.push_back(dynamic_cast&lt;MooseVariable *&gt;(getVar(&quot;v&quot;, i)));
}
</code></pre></section><section class="scrollspy" id="b38e931f-c084-4ac5-856a-5c50828955b8" data-section-level="2" data-section-text="Defaults for Coupling of Vectors of Variables"><h2 id="defaults-for-coupling-of-vectors-of-variables">Defaults for Coupling of Vectors of Variables</h2><p>Vectors of variables can be added using <code>params.addCoupledVar</code> as described above. The parameter class allows providing defaults for vector variables as follows:</p><pre class="moose-pre"><code class="language-text">
InputParameters
B::validParams()
{
  InputParameters params = A::validParams();
  params.addCoupledVar(&quot;v&quot;, {1, 2, 3}, &quot;Coupled value&quot;);
  ...
  return params;
}
</code></pre><p>Coupled variable parameters can be set to constant real numbers in the input file using the syntax</p><pre class="moose-pre"><code class="language-text">
v = &#x27;1&#x27;
</code></pre><p>for a single coupled variable or using</p><pre class="moose-pre"><code class="language-text">
v = &#x27;1 2 3&#x27;
</code></pre><p>for a vector of coupled variables. Currently mixing actual variable assignments and defaults like this:</p><pre class="moose-pre"><code class="language-text">
v = &#x27;1 actual_var 3&#x27;
</code></pre><p>is not supported.</p></section><section class="scrollspy" id="c27e9075-bb11-489d-b694-fd5833cd2244" data-section-level="2" data-section-text="Coupled Solution DOFs"><h2 id="coupled-solution-dofs">Coupled Solution DOFs</h2><p>It is possible to retrieve the solution DOFs of an element in an elemental loop. This is different than the &quot;value&quot; type coupling which holds the interpolated values of the shape functions themselves. Obtaining the raw DOFs all the user to perform their own integration or other evaluation without going through the interpolation process. These functions can be found here:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  /**
   * Returns DoFs in the current solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValues(const std::string &amp; var_name,
                                                 unsigned int comp = 0) const;

  /**
   * Returns DoFs in the current solution vector of all of a coupled variable&#x27;s components for the
   * local element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValues(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the old solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the old DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0) const;

  /**
   * Returns DoFs in the old solution vector of all of a coupled variable&#x27;s components for the local
   * element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each compontnet of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValuesOld(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the older solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the older DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns DoFs in the older solution vector of all of a coupled variable&#x27;s components for the
   * local element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValuesOlder(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the current solution vector of a coupled array variable for the local element
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDofValues(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d25a189b-c7da-4d66-8503-0909373759b4">(moose/framework/include/interfaces/Coupleable.h)</a></section><section class="scrollspy" id="d793247b-ee87-451a-a24a-3c05ab8a61e3" data-section-level="2" data-section-text="Writing directly to coupled variables"><h2 id="writing-directly-to-coupled-variables">Writing directly to coupled variables</h2><p>Element- and nodal user objects as well AuxKernels may obtain a writable reference to a MOOSE field variable through the <code>Coupleable::writableVariable</code> function. The returned variable reference provides a <code>setNodalValue</code> method that can be used to set the nodal or elemental DOF value(s) of the variable.</p><p><code>Coupleable::writableVariable</code> enforces compatibility between the calling object type and the family of the requested variable. I.e. nodal user objects and AuxKernels may only obtain references to nodal variables, and element user objects and elemental AuxKernels may only obtain references to elemental variables.</p><p>The block restrictions of the variables are also checked not to exceed the block restrictions of the calling object. MOOSE keeps track of all variables to which a reference was obtained through <code>Coupleable::writableVariable</code>. Each variable in the system may at most be written to by a single object on any given subdomain.</p><p>The user object and aux kernel thread loops check if an executed object has any writable variable references, and if so, will insert those variables into the aux solution vector. This obviates the need for using the <a href="../auxkernels/ProjectionAux.html"><code>ProjectionAux</code></a> kernel. </p></section></section><div class="moose-modal modal" id="d25a189b-c7da-4d66-8503-0909373759b4"><div class="modal-content"><h4>(moose/framework/include/interfaces/Coupleable.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &lt;unordered_map&gt;
#include &quot;MooseTypes.h&quot;
#include &quot;MooseArray.h&quot;
#include &quot;MooseVariableFE.h&quot;
#include &quot;MooseVariableFV.h&quot;
#include &quot;InputParameters.h&quot;
#include &quot;HasMembers.h&quot;

#define usingCoupleableMembers                                                                     \
  using Coupleable::_zero;                                                                         \
  using Coupleable::_grad_zero;                                                                    \
  using Coupleable::_ad_zero;                                                                      \
  using Coupleable::_ad_grad_zero

// Forward declarations
class MooseVariableScalar;
class MooseObject;

namespace libMesh
{
template &lt;typename T&gt;
class DenseVector;
}

/**
 * Interface for objects that needs coupling capabilities
 *
 */
class Coupleable
{
public:
  /**
   * Constructing the object
   * @param parameters Parameters that come from constructing the object
   * @param nodal true if we need to couple with nodal values, otherwise false
   * @param is_fv Whether the \p MooseObject is a finite volume object
   */
  Coupleable(const MooseObject * moose_object, bool nodal, bool is_fv = false);

  /**
   * Get the list of coupled variables
   * @return The list of coupled variables
   */
  const std::unordered_map&lt;std::string, std::vector&lt;MooseVariableFieldBase *&gt;&gt; &amp;
  getCoupledVars() const
  {
    return _coupled_vars;
  }

  /**
   * Get the list of all coupled variables
   * @return The list of all coupled variables
   */
  const std::vector&lt;MooseVariableFieldBase *&gt; &amp; getCoupledMooseVars() const
  {
    return _coupled_moose_vars;
  }

  /**
   * Get the list of standard coupled variables
   * @return The list of standard coupled variables
   */
  const std::vector&lt;MooseVariable *&gt; &amp; getCoupledStandardMooseVars() const
  {
    return _coupled_standard_moose_vars;
  }

  /**
   * Get the list of vector coupled variables
   * @return The list of vector coupled variables
   */
  const std::vector&lt;VectorMooseVariable *&gt; &amp; getCoupledVectorMooseVars() const
  {
    return _coupled_vector_moose_vars;
  }

  /**
   * Get the list of array coupled variables
   * @return The list of array coupled variables
   */
  const std::vector&lt;ArrayMooseVariable *&gt; &amp; getCoupledArrayMooseVars() const
  {
    return _coupled_array_moose_vars;
  }

  void addFEVariableCoupleableVectorTag(TagID tag) { _fe_coupleable_vector_tags.insert(tag); }

  void addFEVariableCoupleableMatrixTag(TagID tag) { _fe_coupleable_matrix_tags.insert(tag); }

  std::set&lt;TagID&gt; &amp; getFEVariableCoupleableVectorTags() { return _fe_coupleable_vector_tags; }

  std::set&lt;TagID&gt; &amp; getFEVariableCoupleableMatrixTags() { return _fe_coupleable_matrix_tags; }

  const std::set&lt;TagID&gt; &amp; getFEVariableCoupleableVectorTags() const
  {
    return _fe_coupleable_vector_tags;
  }

  const std::set&lt;TagID&gt; &amp; getFEVariableCoupleableMatrixTags() const
  {
    return _fe_coupleable_matrix_tags;
  }

  /**
   * returns a reference to the set of writable coupled variables
   */
  auto &amp; getWritableCoupledVariables() const { return _writable_coupled_variables[_c_tid]; }

  /**
   * Checks whether the object has any writable coupled variables
   */
  bool hasWritableCoupledVariables() const { return !getWritableCoupledVariables().empty(); }

protected:
  /**
   * A call-back function provided by the derived object for actions before coupling a variable
   * with functions such as coupledValue.
   */
  virtual void coupledCallback(const std::string &amp; /*var_name*/, bool /*is_old*/) const {}

  /**
   * Returns true if a variables has been coupled as name.
   * @param var_name The name the kernel wants to refer to the variable as.
   * @param i By default 0, in general the index to test in a vector of MooseVariable pointers.
   * @return True if a coupled variable has the supplied name
   */
  virtual bool isCoupled(const std::string &amp; var_name, unsigned int i = 0) const;

  /**
   * Returns true if a variable passed as a coupled value is really a constant
   * @param var_name The name the kernel wants to refer to the variable as.
   * @return True if the variable is actually a constant
   */
  virtual bool isCoupledConstant(const std::string &amp; var_name) const;

  /**
   * Number of coupled components
   * @param var_name Name of the variable
   * @return number of components this variable has (usually 1)
   */
  unsigned int coupledComponents(const std::string &amp; var_name) const;

  /**
   * Names of the variable in the Coupleable interface
   * @param var_name Name of the variable
   * @param comp the component of the variable
   * @return name the variable has been coupled as. For constants, returns the constant
   */
  VariableName coupledName(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Names of the variables in the Coupleable interface
   * @param var_name Names of the variables
   * @return names the variables have been coupled as
   */
  std::vector&lt;VariableName&gt; coupledNames(const std::string &amp; var_name) const;

  /**
   * Returns the index for a coupled variable by name
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Index of coupled variable, if this is an optionally coupled variable that wasn&#x27;t
   * provided this will return a unique &quot;invalid&quot; index.
   */
  virtual unsigned int coupled(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns the indices for a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of the indices for all components of the coupled variable \p var_name.
   */
  std::vector&lt;unsigned int&gt; coupledIndices(const std::string &amp; var_name) const;

  /**
   * Returns value of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp; coupledValue(const std::string &amp; var_name,
                                             unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled variable components
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledValues(const std::string &amp; var_name) const;

  /**
   * Returns the values for all of a coupled vector variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VectorVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VectorVariableValue *&gt; coupledVectorValues(const std::string &amp; var_name) const;

  /**
   * Returns value of a coupled variable for use in templated automatic differentiation classes
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a GenericVariableValue for the coupled variable
   */
  template &lt;bool is_ad&gt;
  const GenericVariableValue&lt;is_ad&gt; &amp; coupledGenericValue(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled variable&#x27;s components for use in templated automatic
   * differentiation classes
   * @param var_name Name of coupled variable
   * @return Vector of GenericVariableValue pointers for each component of \p var_name
   */
  template &lt;bool is_ad&gt;
  std::vector&lt;const GenericVariableValue&lt;is_ad&gt; *&gt;
  coupledGenericValues(const std::string &amp; var_name) const;

  /**
   * Returns DOF value of a coupled variable for use in templated automatic differentiation classes
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a GenericVariableValue for the coupled variable
   */
  template &lt;bool is_ad&gt;
  const GenericVariableValue&lt;is_ad&gt; &amp; coupledGenericDofValue(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;

  /**
   * Returns value of a coupled lower-dimensional variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  virtual const VariableValue &amp; coupledValueLower(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;

  /**
   * Returns value of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a ADVariableValue for the coupled variable
   */
  const ADVariableValue &amp; adCoupledValue(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled variable&#x27;s components for use in Automatic
   * Differentiation
   * @param var_name Name of coupled variable
   * @return Vector of ADVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const ADVariableValue *&gt; adCoupledValues(const std::string &amp; var_name) const;

  /**
   * Returns value of a coupled lower-dimensional variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a ADVariableValue for the coupled variable
   */
  const ADVariableValue &amp; adCoupledLowerValue(const std::string &amp; var_name,
                                              unsigned int comp = 0) const;

  /**
   * Returns value of a coupled vector variable for use in Automatic Differentiation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::value
   */
  const ADVectorVariableValue &amp; adCoupledVectorValue(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled vector variable&#x27;s components for use in
   * Automatic Differentiation
   * @param var_name Name of coupled variable
   * @return Vector of ADVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const ADVectorVariableValue *&gt;
  adCoupledVectorValues(const std::string &amp; var_name) const;

  /**
   * Returns value of a coupled variable for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp;
  coupledVectorTagValue(const std::string &amp; var_names, TagID tag, unsigned int index = 0) const;

  virtual const VariableValue &amp; coupledVectorTagValue(const std::string &amp; var_names,
                                                      const std::string &amp; tag_name,
                                                      unsigned int index = 0) const;

  /**
   * Returns the values for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @return Vector of VariableValue pointers for each variable in \p var_names
   */
  std::vector&lt;const VariableValue *&gt; coupledVectorTagValues(const std::string &amp; var_names,
                                                            TagID tag) const;

  std::vector&lt;const VariableValue *&gt; coupledVectorTagValues(const std::string &amp; var_names,
                                                            const std::string &amp; tag_name) const;

  /**
   * Returns value of a coupled array variable for a given tag
   * @param var_names Name(s) of coupled array variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a VariableValue for the coupled array variable
   * @see Kernel::_u
   */
  virtual const ArrayVariableValue &amp; coupledVectorTagArrayValue(const std::string &amp; var_names,
                                                                TagID tag,
                                                                unsigned int index = 0) const;

  virtual const ArrayVariableValue &amp; coupledVectorTagArrayValue(const std::string &amp; var_names,
                                                                const std::string &amp; tag_name,
                                                                unsigned int index = 0) const;

  /**
   * Returns the values for all the coupled variables desired for a given tag
   * @param var_name Name of array coupled variable
   * @param tag vector tag ID
   * @return Vector of ArrayVariableValue pointers for each variable in \p var_names
   */
  std::vector&lt;const ArrayVariableValue *&gt; coupledVectorTagArrayValues(const std::string &amp; var_names,
                                                                      TagID tag) const;

  std::vector&lt;const ArrayVariableValue *&gt;
  coupledVectorTagArrayValues(const std::string &amp; var_names, const std::string &amp; tag_name) const;

  /**
   * Returns gradient of a coupled variable for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  virtual const VariableGradient &amp;
  coupledVectorTagGradient(const std::string &amp; var_names, TagID tag, unsigned int index = 0) const;

  virtual const VariableGradient &amp; coupledVectorTagGradient(const std::string &amp; var_names,
                                                            const std::string &amp; tag_name,
                                                            unsigned int index = 0) const;

  /**
   * Returns gradients for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled array variable(s)
   * @param tag vector tag ID
   * @return Vector of VariableGradient pointers for each variables in \p var_name
   */
  std::vector&lt;const VariableGradient *&gt; coupledVectorTagGradients(const std::string &amp; var_names,
                                                                  TagID tag) const;

  std::vector&lt;const VariableGradient *&gt;
  coupledVectorTagGradients(const std::string &amp; var_names, const std::string &amp; tag_name) const;

  /**
   * Returns gradient of a coupled array variable for a given tag
   * @param var_names Name(s) of coupled array variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a ArrayVariableGradient containing the gradient of the coupled array
   * variable
   * @see Kernel::gradient
   */
  virtual const ArrayVariableGradient &amp; coupledVectorTagArrayGradient(const std::string &amp; var_names,
                                                                      TagID tag,
                                                                      unsigned int index = 0) const;

  virtual const ArrayVariableGradient &amp; coupledVectorTagArrayGradient(const std::string &amp; var_names,
                                                                      const std::string &amp; tag_name,
                                                                      unsigned int index = 0) const;

  /**
   * Returns gradients for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled array variable(s)
   * @param tag vector tag ID
   * @return Vector of ArrayVariableGradient pointers for each variable in \p var_name
   */
  std::vector&lt;const ArrayVariableGradient *&gt;
  coupledVectorTagArrayGradients(const std::string &amp; var_names, TagID tag) const;

  std::vector&lt;const ArrayVariableGradient *&gt;
  coupledVectorTagArrayGradients(const std::string &amp; var_names, const std::string &amp; tag_name) const;

  /**
   * Returns dof value of a coupled variable for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a DofValue for the coupled variable
   */
  virtual const VariableValue &amp;
  coupledVectorTagDofValue(const std::string &amp; var_name, TagID tag, unsigned int index = 0) const;

  virtual const VariableValue &amp; coupledVectorTagDofValue(const std::string &amp; var_names,
                                                         const std::string &amp; tag_name,
                                                         unsigned int index = 0) const;

  /**
   * Returns evaluations of a tagged vector at the requested variable&#x27;s degree of freedom indices
   * @param var_name Name of coupled variable
   * @param tag_name vector tag name
   * @return Reference to a ArrayVariableValue for the coupled variable
   */
  const ArrayVariableValue &amp; coupledVectorTagArrayDofValue(const std::string &amp; var_name,
                                                           const std::string &amp; tag_name,
                                                           unsigned int comp = 0) const;

  /**
   * Returns the dof values for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag vector tag ID
   * @return Vector of VariableValue pointers for each variable in \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledVectorTagDofValues(const std::string &amp; var_names,
                                                               TagID tag) const;

  std::vector&lt;const VariableValue *&gt; coupledVectorTagDofValues(const std::string &amp; var_names,
                                                               const std::string &amp; tag_name) const;

  /**
   * Returns value of a coupled variable for a given tag. This couples the diag vector of matrix
   * @param var_names Name(s) of coupled variable(s)
   * @param tag matrix tag ID
   * @param index Index of the desired variable in the vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp;
  coupledMatrixTagValue(const std::string &amp; var_names, TagID tag, unsigned int index = 0) const;

  virtual const VariableValue &amp; coupledMatrixTagValue(const std::string &amp; var_names,
                                                      const std::string &amp; tag_name,
                                                      unsigned int index = 0) const;

  /**
   * Returns the diagonal matrix values for all the coupled variables desired for a given tag
   * @param var_names Name(s) of coupled variable(s)
   * @param tag matrix tag ID
   * @return Vector of VariableValue pointers for each variable in \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledMatrixTagValues(const std::string &amp; var_names,
                                                            TagID tag) const;

  std::vector&lt;const VariableValue *&gt; coupledMatrixTagValues(const std::string &amp; var_names,
                                                            const std::string &amp; tag_name) const;

  /**
   * Returns value of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue for the coupled vector variable
   * @see VectorKernel::_u
   */
  virtual const VectorVariableValue &amp; coupledVectorValue(const std::string &amp; var_name,
                                                         unsigned int comp = 0) const;

  /**
   * Returns value of a coupled array variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a ArrayVariableValue for the coupled vector variable
   * @see ArrayKernel::_u
   */
  virtual const ArrayVariableValue &amp; coupledArrayValue(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  /**
   * Returns the values for all of a coupled array variable&#x27;s components
   * @param var_name Name of coupled array variable
   * @return Vector of ArrayVariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const ArrayVariableValue *&gt; coupledArrayValues(const std::string &amp; var_name) const;

  /**
   * Returns a *writable* MooseVariable object for a nodal or elemental variable. Use
   * var.setNodalValue(val[, idx]) in both cases (!) to set the solution DOF values. Only one object
   * can obtain a writable reference in a simulation. Note that the written values will not ba
   * available in the same system loop! E.g. values written using this API by a nodal AuxKernel will
   * not be updated for other nodal AuxKernels during the same iteration over all nodes.
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a MooseVariable for the coupled variable
   * @see Kernel::value
   */
  MooseVariable &amp; writableVariable(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns a *writable* reference to a coupled variable for writing to multiple
   * AuxVariables from a single AuxKernel or a UserObject. Only one object can obtain
   * a writable reference in a simulation.
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::value
   */
  virtual VariableValue &amp; writableCoupledValue(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Checks that the passed in variable is only accessed writable by one object in a given subdomain
   */
  void checkWritableVar(MooseVariable * var);

  /**
   * Returns an old value from previous time step  of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old value of the coupled variable
   * @see Kernel::valueOld
   */
  virtual const VariableValue &amp; coupledValueOld(const std::string &amp; var_name,
                                                unsigned int comp = 0) const;

  /**
   * Returns the old values for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledValuesOld(const std::string &amp; var_name) const;

  /**
   * Returns an old value from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   * @see Kernel::valueOlder
   */
  virtual const VariableValue &amp; coupledValueOlder(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;

  /**
   * Returns value of previous Newton iterate of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   */
  virtual const VariableValue &amp; coupledValuePreviousNL(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  /**
   * Returns an old value from previous time step  of a coupled vector variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableValue containing the old value of the coupled variable
   * @see VectorKernel::_u_old
   */
  virtual const VectorVariableValue &amp; coupledVectorValueOld(const std::string &amp; var_name,
                                                            unsigned int comp = 0) const;

  /**
   * Returns an old value from two time steps previous of a coupled vector variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableValue containing the older value of the coupled variable
   * @see VectorKernel::_u_older
   */
  virtual const VectorVariableValue &amp; coupledVectorValueOlder(const std::string &amp; var_name,
                                                              unsigned int comp = 0) const;

  /**
   * Returns an old value from previous time step  of a coupled array variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a ArrayVariableValue containing the old value of the coupled variable
   * @see ArrayKernel::_u_old
   */
  virtual const ArrayVariableValue &amp; coupledArrayValueOld(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;

  /**
   * Returns an old value from two time steps previous of a coupled array variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a ArrayVariableValue containing the older value of the coupled variable
   * @see ArrayKernel::_u_older
   */
  virtual const ArrayVariableValue &amp; coupledArrayValueOlder(const std::string &amp; var_name,
                                                            unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  virtual const VariableGradient &amp; coupledGradient(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Returns the gradients for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableGradient pointers for each component of \p var_name
   */
  std::vector&lt;const VariableGradient *&gt; coupledGradients(const std::string &amp; var_name) const;

  /**
   * Returns gradient of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  const ADVariableGradient &amp; adCoupledGradient(const std::string &amp; var_name,
                                               unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled variable&#x27;s time derivative for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVariableGradient containing the gradient of the coupled variable&#x27;s
   * time derivative
   */
  const ADVariableGradient &amp; adCoupledGradientDot(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;

  /**
   * Returns the gradients for all of a coupled variable&#x27;s components for use in Automatic
   * Differentiation
   * @param var_name Name of coupled variable
   * @return Vector of ADVariableGradient pointers for each component of \p var_name
   */
  std::vector&lt;const ADVariableGradient *&gt; adCoupledGradients(const std::string &amp; var_name) const;

  /**
   * Returns gradient of a coupled variable for use in templated automatic differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  template &lt;bool is_ad&gt;
  const GenericVariableGradient&lt;is_ad&gt; &amp; coupledGenericGradient(const std::string &amp; var_name,
                                                                unsigned int comp = 0) const;

  /**
   * Returns the gradients for all of a coupled variable&#x27;s components for use in templated automatic
   * differentiation
   * @param var_name Name of coupled variable
   * @return Vector of VariableGradient pointers for each component of \p var_name
   */
  template &lt;bool is_ad&gt;
  std::vector&lt;const GenericVariableGradient&lt;is_ad&gt; *&gt;
  coupledGenericGradients(const std::string &amp; var_name) const;

  /**
   * Returns gradient of a coupled vector variable for use in Automatic Differentiation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  const ADVectorVariableGradient &amp; adCoupledVectorGradient(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;

  /**
   * Returns second derivatives of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivatives of the coupled variable
   */
  const ADVariableSecond &amp; adCoupledSecond(const std::string &amp; var_name,
                                           unsigned int comp = 0) const;

  /**
   * Returns second derivatives of a coupled vector variable for use in Automatic Differentiation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableSecond containing the second derivatives of the coupled
   * variable
   */
  const ADVectorVariableSecond &amp; adCoupledVectorSecond(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  /**
   * Returns an old gradient from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the old gradient of the coupled variable
   * @see Kernel::gradientOld
   */
  virtual const VariableGradient &amp; coupledGradientOld(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns the old gradients for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableGradient pointers for each component of \p var_name
   */
  std::vector&lt;const VariableGradient *&gt; coupledGradientsOld(const std::string &amp; var_name) const;

  /**
   * Returns an old gradient from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the older gradient of the coupled variable
   * @see Kernel::gradientOlder
   */
  virtual const VariableGradient &amp; coupledGradientOlder(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled variable for previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientPreviousNL(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;

  /**
   * Time derivative of the gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the time derivative of the gradient of a
   * coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientDot(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Second time derivative of the gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the time derivative of the gradient of a
   * coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientDotDot(const std::string &amp; var_name,
                                                         unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled vector
   * variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradient(const std::string &amp; var_name,
                                                               unsigned int comp = 0) const;

  /**
   * Returns an old gradient from previous time step of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the old gradient of the coupled vector
   * variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradientOld(const std::string &amp; var_name,
                                                                  unsigned int comp = 0) const;

  /**
   * Returns an old gradient from two time steps previous of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the older gradient of the coupled
   * vector variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradientOlder(const std::string &amp; var_name,
                                                                    unsigned int comp = 0) const;

  /**
   * Returns gradient of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled array
   * variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradient(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;

  /**
   * Returns an old gradient from previous time step of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VectorVariableGradient containing the old gradient of the coupled array
   * variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradientOld(const std::string &amp; var_name,
                                                                unsigned int comp = 0) const;

  /**
   * Returns an old gradient from two time steps previous of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableGradient containing the older gradient of the coupled
   * array variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradientOlder(const std::string &amp; var_name,
                                                                  unsigned int comp = 0) const;

  /**
   * Returns curl of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the curl of the coupled variable
   * @see Kernel::_curl_u
   */
  virtual const VectorVariableCurl &amp; coupledCurl(const std::string &amp; var_name,
                                                 unsigned int comp = 0) const;

  /**
   * Returns an old curl from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the old curl of the coupled variable
   * @see Kernel::_curl_u_old
   */
  virtual const VectorVariableCurl &amp; coupledCurlOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0) const;

  /**
   * Returns an old curl from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the older curl of the coupled variable
   * @see Kernel::_curl_u_older
   */
  virtual const VectorVariableCurl &amp; coupledCurlOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns second derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivative of the coupled variable
   * @see Kernel::second
   */
  virtual const VariableSecond &amp; coupledSecond(const std::string &amp; var_name,
                                               unsigned int comp = 0) const;

  /**
   * Returns an old second derivative from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the old second derivative of the coupled
   * variable
   * @see Kernel::secondOld
   */
  virtual const VariableSecond &amp; coupledSecondOld(const std::string &amp; var_name,
                                                  unsigned int comp = 0) const;

  /**
   * Returns an old second derivative from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the older second derivative of the coupled
   * variable
   * @see Kernel::secondOlder
   */
  virtual const VariableSecond &amp; coupledSecondOlder(const std::string &amp; var_name,
                                                    unsigned int comp = 0) const;

  /**
   * Returns second derivative of a coupled variable for the previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivative of the coupled variable
   */
  virtual const VariableSecond &amp; coupledSecondPreviousNL(const std::string &amp; var_name,
                                                         unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   */
  virtual const VariableValue &amp; coupledDot(const std::string &amp; var_name,
                                           unsigned int comp = 0) const;

  /**
   * Returns the time derivatives for all of a coupled variable&#x27;s components
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const VariableValue *&gt; coupledDots(const std::string &amp; var_name) const;

  /**
   * Second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the second time derivative of the coupled
   * variable
   */
  virtual const VariableValue &amp; coupledDotDot(const std::string &amp; var_name,
                                              unsigned int comp = 0) const;

  /**
   * Old time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old time derivative of the coupled variable
   */
  virtual const VariableValue &amp; coupledDotOld(const std::string &amp; var_name,
                                              unsigned int comp = 0) const;

  /**
   * Old second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old second time derivative of the coupled
   * variable
   */
  virtual const VariableValue &amp; coupledDotDotOld(const std::string &amp; var_name,
                                                 unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled variable for ad simulations
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * @see Kernel::dot
   */
  const ADVariableValue &amp; adCoupledDot(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns the time derivatives for all of a coupled variable&#x27;s components for ad simulations
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of \p var_name
   */
  std::vector&lt;const ADVariableValue *&gt; adCoupledDots(const std::string &amp; var_name) const;

  /**
   * Second time derivative of a coupled variable for ad simulations
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVariableValue containing the second time derivative of the coupled
   * variable
   */
  const ADVariableValue &amp; adCoupledDotDot(const std::string &amp; var_name,
                                          unsigned int comp = 0) const;

  /**
   * Time derivative of a vector coupled variable for ad simulations
   * @param var_name Name of vector coupled variable
   * @param comp Component number
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   * @see Kernel::dot
   */
  const ADVectorVariableValue &amp; adCoupledVectorDot(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDot(const std::string &amp; var_name,
                                                       unsigned int comp = 0) const;

  /**
   * Second time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotDot(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;

  /**
   * Old time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotOld(const std::string &amp; var_name,
                                                          unsigned int comp = 0) const;

  /**
   * Old second time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotDotOld(const std::string &amp; var_name,
                                                             unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled vector variable with respect to the coefficients
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VariableValue containing the time derivative of the coupled
   * vector variable with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledVectorDotDu(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Second time derivative of a coupled vector variable with respect to the coefficients
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VariableValue containing the time derivative of the coupled vector
   * variable with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledVectorDotDotDu(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDot(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;

  /**
   * Second time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotDot(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;

  /**
   * Old time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotOld(const std::string &amp; var_name,
                                                        unsigned int comp = 0) const;

  /**
   * Old second time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotDotOld(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;

  /**
   * Time derivative of a coupled variable with respect to the coefficients
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledDotDu(const std::string &amp; var_name,
                                             unsigned int comp = 0) const;

  /**
   * Second time derivative of a coupled variable with respect to the coefficients
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledDotDotDu(const std::string &amp; var_name,
                                                unsigned int comp = 0) const;

  /**
   * Returns nodal values of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValue(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns AD nodal values of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T&gt;
  const typename Moose::ADType&lt;T&gt;::type &amp; adCoupledNodalValue(const std::string &amp; var_name,
                                                              unsigned int comp = 0) const;

  /**
   * Returns an old nodal value from previous time step  of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old value of the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValueOld(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns an old nodal value from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValueOlder(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Returns nodal values of a coupled variable for previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValuePreviousNL(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Nodal values of time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of time derivative of the
   * coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalDot(const std::string &amp; var_name, unsigned int comp = 0) const;

  /**
   * Nodal values of second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of second time derivative of
   * the coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotDot(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Nodal values of old time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of time derivative of the
   * coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotOld(const std::string &amp; var_name,
                                                   unsigned int comp = 0) const;

  /**
   * Nodal values of old second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of second time derivative of
   * the coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotDotOld(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;
  // coupled-dof-values-begin
  /**
   * Returns DoFs in the current solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValues(const std::string &amp; var_name,
                                                 unsigned int comp = 0) const;

  /**
   * Returns DoFs in the current solution vector of all of a coupled variable&#x27;s components for the
   * local element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValues(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the old solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the old DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0) const;

  /**
   * Returns DoFs in the old solution vector of all of a coupled variable&#x27;s components for the local
   * element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each compontnet of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValuesOld(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the older solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the older DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0) const;

  /**
   * Returns DoFs in the older solution vector of all of a coupled variable&#x27;s components for the
   * local element
   * @param var_name Name of coupled variable
   * @return Vector of VariableValue pointers for each component of the coupled variable
   */
  std::vector&lt;const VariableValue *&gt; coupledAllDofValuesOlder(const std::string &amp; var_name) const;

  /**
   * Returns DoFs in the current solution vector of a coupled array variable for the local element
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDofValues(const std::string &amp; var_name,
                                                           unsigned int comp = 0) const;
  // coupled-dof-values-end

  /**
   * Returns DOF value of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to an ADVariableValue for the DoFs of the coupled variable
   */
  virtual const ADVariableValue &amp; adCoupledDofValues(const std::string &amp; var_name,
                                                     unsigned int comp = 0) const;

  /**
   * method that returns _zero to RESIDUAL computing objects and _ad_zero to JACOBIAN
   * computing objects
   */
  const ADVariableValue &amp; adZeroValue() const;

  /**
   *  method that returns _grad_zero to RESIDUAL computing objects and _ad_grad_zero to
   * JACOBIAN computing objects
   */
  const ADVariableGradient &amp; adZeroGradient() const;

  /**
   * Retrieve a zero second for automatic differentiation
   */
  const ADVariableSecond &amp; adZeroSecond() const;

  /**
   * Returns zero value templated with automatic differentiation boolean
   * @return Reference to a const GenericVariableValue
   */
  template &lt;bool is_ad&gt;
  const GenericVariableValue&lt;is_ad&gt; &amp; genericZeroValue();

  /**
   * Returns zero gradient templated with automatic differentiation boolean
   * @return Reference to a const GenericVariableValue
   */
  template &lt;bool is_ad&gt;
  const GenericVariableGradient&lt;is_ad&gt; &amp; genericZeroGradient();

  /**
   * Returns zero second derivative templated with automatic differentiation boolean
   * @return Reference to a const GenericVariableValue
   */
  template &lt;bool is_ad&gt;
  const GenericVariableSecond&lt;is_ad&gt; &amp; genericZeroSecond();

protected:
  // Reference to the interface&#x27;s input parameters
  const InputParameters &amp; _c_parameters;

  /// The name of the object this interface is part of
  const std::string &amp; _c_name;
  /// The type of the object this interface is part of
  const std::string &amp; _c_type;

  // Reference to FEProblemBase
  FEProblemBase &amp; _c_fe_problem;

  /// Pointer to the system object if the moose object this is an interface for has one
  const SystemBase * const _c_sys;

  /// Coupled vars whose values we provide
  std::unordered_map&lt;std::string, std::vector&lt;MooseVariableFieldBase *&gt;&gt; _coupled_vars;

  /// Vector of all coupled variables
  std::vector&lt;MooseVariableFieldBase *&gt; _coupled_moose_vars;

  /// Vector of standard coupled variables
  std::vector&lt;MooseVariable *&gt; _coupled_standard_moose_vars;

  /// Vector of vector coupled variables
  std::vector&lt;VectorMooseVariable *&gt; _coupled_vector_moose_vars;

  /// Vector of array coupled variables
  std::vector&lt;ArrayMooseVariable *&gt; _coupled_array_moose_vars;

  /// Vector of standard finite volume coupled variables
  std::vector&lt;MooseVariableFV&lt;Real&gt; *&gt; _coupled_standard_fv_moose_vars;

  /// map from new to deprecated variable names
  const std::unordered_map&lt;std::string, std::string&gt; &amp; _new_to_deprecated_coupled_vars;

  /// True if we provide coupling to nodal values
  bool _c_nodal;

  /// True if implicit value is required
  bool _c_is_implicit;

  // Argument to allow element-to-nodal coupling
  const bool _c_allow_element_to_nodal_coupling;

  /// Thread ID of the thread using this object
  THREAD_ID _c_tid;

  /// Will hold the default value for optional coupled variables.
  mutable std::unordered_map&lt;std::string, std::vector&lt;std::unique_ptr&lt;VariableValue&gt;&gt;&gt;
      _default_value;

  /// Will hold the default value for optional coupled variables for automatic differentiation.
  mutable std::unordered_map&lt;std::string, std::unique_ptr&lt;MooseArray&lt;DualReal&gt;&gt;&gt; _ad_default_value;

  /// Will hold the default value for optional vector coupled variables.
  mutable std::unordered_map&lt;std::string, std::unique_ptr&lt;VectorVariableValue&gt;&gt;
      _default_vector_value;

  /// Will hold the default value for optional array coupled variables.
  mutable std::unordered_map&lt;std::string, std::unique_ptr&lt;ArrayVariableValue&gt;&gt; _default_array_value;

  /// Will hold the default value for optional vector coupled variables for automatic differentiation.
  mutable std::unordered_map&lt;std::string, std::unique_ptr&lt;MooseArray&lt;ADRealVectorValue&gt;&gt;&gt;
      _ad_default_vector_value;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  mutable VariableValue _default_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VariableGradient _default_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable MooseArray&lt;ADRealVectorValue&gt; _ad_default_gradient;

  /// This will always be zero because the default values for optionally coupled vector variables is always constant
  mutable MooseArray&lt;ADRealTensorValue&gt; _ad_default_vector_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VariableSecond _default_second;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable MooseArray&lt;ADRealTensorValue&gt; _ad_default_second;

  /// Zero value of a variable
  const VariableValue &amp; _zero;
  const VariablePhiValue &amp; _phi_zero;
  const MooseArray&lt;DualReal&gt; &amp; _ad_zero;

  /// Zero gradient of a variable
  const VariableGradient &amp; _grad_zero;
  const MooseArray&lt;ADRealVectorValue&gt; &amp; _ad_grad_zero;

  /// Zero gradient of trial function
  const VariablePhiGradient &amp; _grad_phi_zero;

  /// Zero second derivative of a variable
  const VariableSecond &amp; _second_zero;
  const MooseArray&lt;ADRealTensorValue&gt; &amp; _ad_second_zero;
  /// Zero second derivative of a test function
  const VariablePhiSecond &amp; _second_phi_zero;
  /// Zero value of a vector variable
  const VectorVariableValue &amp; _vector_zero;
  /// Zero value of the curl of a vector variable
  const VectorVariableCurl &amp; _vector_curl_zero;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  mutable VectorVariableValue _default_vector_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VectorVariableGradient _default_vector_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  mutable VectorVariableCurl _default_vector_curl;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  ArrayVariableValue _default_array_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  ArrayVariableGradient _default_array_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  ArrayVariableCurl _default_array_curl;

  /**
   * Check that the right kind of variable is being coupled in
   *
   * @param var_name The name of the coupled variable
   */
  bool
  checkVar(const std::string &amp; var_name, unsigned int comp = 0, unsigned int comp_bound = 0) const;

private:
  /**
   * Generic helper method to get vector tag values based on tag ID
   */
  template &lt;typename T&gt;
  const typename OutputTools&lt;T&gt;::VariableValue &amp;
  vectorTagValueHelper(const std::string &amp; var_names, TagID tag, unsigned int index = 0) const;

  /**
   * Generic helper method to get vector tag values based on tag name
   */
  template &lt;typename T&gt;
  const typename OutputTools&lt;T&gt;::VariableValue &amp; vectorTagValueHelper(const std::string &amp; var_names,
                                                                      const std::string &amp; tag_name,
                                                                      unsigned int index = 0) const;

  /**
   * Generic helper method to get vector tag degree of freedom values based on tag ID
   */
  template &lt;typename T&gt;
  const typename OutputTools&lt;T&gt;::VariableValue &amp;
  vectorTagDofValueHelper(const std::string &amp; var_name, TagID tag, unsigned int comp = 0) const;

  /**
   * Generic helper method to get vector tag degree of freedom values based on tag name
   */
  template &lt;typename T&gt;
  const typename OutputTools&lt;T&gt;::VariableValue &amp; vectorTagDofValueHelper(
      const std::string &amp; var_name, const std::string &amp; tag_name, unsigned int comp = 0) const;

  /**
   * Method that may request additional solution states from the variable&#x27;s system depending on the
   * value of \p tag_name. E.g. if the tag name corresponds to old or older variable solution
   * values, then we must request more states
   */
  template &lt;typename T&gt;
  void
  requestStates(const std::string &amp; var_name, const TagName &amp; tag_name, const unsigned int comp);

  enum class FuncAge
  {
    Curr,
    Old,
    Older,
  };

  enum class VarType
  {
    Ignore,
    Gradient,
    Second,
    GradientDot,
    Dot,
  };

  void checkFuncType(const std::string var_name, VarType t, FuncAge age) const;

protected:
  /**
   * Deprecated method. Use \p getFieldVar instead
   * Extract pointer to a base coupled field variable. Could be either a finite volume or finite
   * element variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const MooseVariableFieldBase * getFEVar(const std::string &amp; var_name, unsigned int comp) const;

  /*
   * Extract pointer to a base coupled field variable. Could be either a finite volume or finite
   * element variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const MooseVariableFieldBase * getFieldVar(const std::string &amp; var_name, unsigned int comp) const;

  /*
   * Extract pointer to a base coupled field variable. Could be either a finite volume or finite
   * element variable
   * @param var_name Name of variable desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  MooseVariableFieldBase * getFieldVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Helper that that be used to retrieve a variable of arbitrary type \p T
   */
  template &lt;typename T&gt;
  const T * getVarHelper(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Helper that can be used to retrieve a variable of arbitrary type \p T
   */
  template &lt;typename T&gt;
  T * getVarHelper(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  MooseVariable * getVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled vector variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  VectorMooseVariable * getVectorVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled array variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  ArrayMooseVariable * getArrayVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const MooseVariable * getVar(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Extract pointer to a coupled vector variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const VectorMooseVariable * getVectorVar(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Extract pointer to a coupled array variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  const ArrayMooseVariable * getArrayVar(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Checks to make sure that the current Executioner has set &quot;_is_transient&quot; when old/older values
   * are coupled in.
   * @param name the name of the variable
   * @param fn_name The name of the function that called this method - used in the error message
   */
  void validateExecutionerType(const std::string &amp; name, const std::string &amp; fn_name) const;

  template &lt;typename T, typename Func&gt;
  std::vector&lt;T&gt; coupledVectorHelper(const std::string &amp; var_name, const Func &amp; func) const
  {
    const auto components = coupledComponents(var_name);
    std::vector&lt;T&gt; vals(components);
    for (MooseIndex(components) comp = 0; comp &lt; components; ++comp)
      vals[comp] = func(comp);
    return vals;
  }

  /// Whether or not this object is a &quot;neighbor&quot; object: ie all of it&#x27;s coupled values should be neighbor values
  bool _coupleable_neighbor;

public:
  /**
   * Helper method to return (and insert if necessary) the default value for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default value
   * @return VariableValue * a pointer to the associated VarirableValue.
   */
  const ADVariableValue * getADDefaultValue(const std::string &amp; var_name) const;

  /**
   * Helper method to return (and insert if necessary) the default vector value for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return VariableVectorValue * a pointer to the associated VarirableVectorValue.
   */
  const ADVectorVariableValue * getADDefaultVectorValue(const std::string &amp; var_name) const;

  /**
   * Helper method to return (and insert if necessary) the default gradient for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default gradient
   * @return VariableGradient * a pointer to the associated VariableGradient.
   */
  const ADVariableGradient &amp; getADDefaultGradient() const;

  /**
   * Helper method to return (and insert if necessary) the default gradient for Automatic
   * Differentiation for an uncoupled vector variable.
   * @param var_name the name of the vector variable for which to retrieve a default gradient
   * @return VariableGradient * a pointer to the associated VectorVariableGradient.
   */
  const ADVectorVariableGradient &amp; getADDefaultVectorGradient() const;

  /**
   * Helper method to return (and insert if necessary) the default second derivatives for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default second derivative
   * @return VariableSecond * a pointer to the associated VariableSecond.
   */
  const ADVariableSecond &amp; getADDefaultSecond() const;

private:
  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default value
   * @return a pointer to the associated VariableValue.
   */
  const VariableValue * getDefaultValue(const std::string &amp; var_name, unsigned int comp) const;

  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled vector variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return a pointer to the associated VectorVariableValue.
   */
  const VectorVariableValue * getDefaultVectorValue(const std::string &amp; var_name) const;

  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled array variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return a pointer to the associated VectorVariableValue.
   */
  const ArrayVariableValue * getDefaultArrayValue(const std::string &amp; var_name) const;

  /**
   * Get nodal default value
   */
  template &lt;typename T&gt;
  const T &amp; getDefaultNodalValue(const std::string &amp; var_name, unsigned int comp = 0) const;

  template &lt;typename T&gt;
  const Moose::Functor&lt;T&gt; &amp; getDefaultFunctor(const std::string &amp; var_name) const;

  /// Maximum qps for any element in this system
  unsigned int _coupleable_max_qps;

  /// Unique indices for optionally coupled vars that weren&#x27;t provided
  std::unordered_map&lt;std::string, std::vector&lt;unsigned int&gt;&gt; _optional_var_index;

  /// Scalar variables coupled into this object (for error checking)
  std::unordered_map&lt;std::string, std::vector&lt;MooseVariableScalar *&gt;&gt; _c_coupled_scalar_vars;

  std::set&lt;TagID&gt; _fe_coupleable_vector_tags;

  std::set&lt;TagID&gt; _fe_coupleable_matrix_tags;

  /// Whether the MooseObject is a finite volume object
  const bool _is_fv;

  const MooseObject * const _obj;

  /// vector tag names for which we need to request older solution states from the system
  const std::set&lt;std::string&gt; _older_state_tags = {Moose::OLD_SOLUTION_TAG,
                                                   Moose::OLDER_SOLUTION_TAG};

  /// keep a set of allocated writable variable references to make sure only one object can obtain them per thread
  std::vector&lt;std::set&lt;MooseVariable *&gt;&gt; _writable_coupled_variables;
};

template &lt;typename T&gt;
T *
Coupleable::getVarHelper(const std::string &amp; var_name_in, unsigned int comp)
{
  const auto var_name = _c_parameters.checkForRename(var_name_in);
  auto name_to_use = var_name;

  // First check for supplied name
  if (!checkVar(var_name, comp, 0))
  {
    // See if there is an associated deprecated name that the user may have used instead
    auto it = _new_to_deprecated_coupled_vars.find(var_name);
    if (it == _new_to_deprecated_coupled_vars.end())
      return nullptr;
    else
    {
      auto deprecated_name = it-&gt;second;
      if (checkVar(deprecated_name, comp, 0))
        name_to_use = deprecated_name;
      else
        return nullptr;
    }
  }

  auto coupled_vars_it = _coupled_vars.find(name_to_use);

  mooseAssert(coupled_vars_it != _coupled_vars.end(),
              &quot;Trying to get a coupled var &quot; &lt;&lt; name_to_use &lt;&lt; &quot; that doesn&#x27;t exist&quot;);

  if (auto coupled_var = dynamic_cast&lt;T *&gt;(coupled_vars_it-&gt;second[comp]))
    return coupled_var;
  else
  {
    for (auto &amp; var : _coupled_standard_moose_vars)
      if (var-&gt;name() == name_to_use)
        mooseError(&quot;The named variable is a standard variable, try a &quot;
                   &quot;&#x27;coupled[Value/Gradient/Dot/etc]...&#x27; function instead&quot;);
    for (auto &amp; var : _coupled_vector_moose_vars)
      if (var-&gt;name() == name_to_use)
        mooseError(&quot;The named variable is a vector variable, try a &quot;
                   &quot;&#x27;coupledVector[Value/Gradient/Dot/etc]...&#x27; function instead&quot;);
    for (auto &amp; var : _coupled_array_moose_vars)
      if (var-&gt;name() == name_to_use)
        mooseError(&quot;The named variable is an array variable, try a &quot;
                   &quot;&#x27;coupledArray[Value/Gradient/Dot/etc]...&#x27; function instead&quot;);
    for (auto &amp; var : _coupled_standard_fv_moose_vars)
      if (var-&gt;name() == name_to_use)
        mooseError(&quot;The named variable is a finite volume variable, which the coupled[...] routine &quot;
                   &quot;used does not support. Try using the functor system routines instead.&quot;);
    mooseError(
        &quot;Variable &#x27;&quot;, name_to_use, &quot;&#x27; is of a different C++ type than you tried to fetch it as.&quot;);
  }
}

template &lt;typename T&gt;
const T *
Coupleable::getVarHelper(const std::string &amp; var_name, unsigned int comp) const
{
  return const_cast&lt;Coupleable *&gt;(this)-&gt;getVarHelper&lt;T&gt;(var_name, comp);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#093ff660-30a9-46b4-9a9e-06672fcfbf17" class="tooltipped" data-position="left" data-tooltip="Optional Coupling">Optional Coupling</a></li><li><a href="#fbfe203b-0af9-46aa-973c-33c4447ffd57" class="tooltipped" data-position="left" data-tooltip="Coupling of Vectors of Variables">Coupling of Vectors of Variables</a></li><li><a href="#b38e931f-c084-4ac5-856a-5c50828955b8" class="tooltipped" data-position="left" data-tooltip="Defaults for Coupling of Vectors of Variables">Defaults for Coupling of Vectors of Variables</a></li><li><a href="#c27e9075-bb11-489d-b694-fd5833cd2244" class="tooltipped" data-position="left" data-tooltip="Coupled Solution DOFs">Coupled Solution DOFs</a></li><li><a href="#d793247b-ee87-451a-a24a-3c05ab8a61e3" class="tooltipped" data-position="left" data-tooltip="Writing directly to coupled variables">Writing directly to coupled variables</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>