<!DOCTYPE html><head><meta charset="UTF-8"><title>SetupInterface execute on | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="adcbd054-5eec-4028-b953-84515c0efe2f" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b37c1c42-0a7b-4dda-b78b-5a10fc71b8c8" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c0b73d19-c815-4458-ab77-3e2fbcd22c40" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="1d6ddd6f-b151-4377-bc31-a0d1f7d16587"><i class="material-icons">menu</i></a><ul class="sidenav" id="1d6ddd6f-b151-4377-bc31-a0d1f7d16587"><li><a href="#!" class="dropdown-trigger" data-target="cf24a371-cd3c-4822-897d-e998e4aebd6b" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="0f4ec522-0064-49d9-b629-4d77a9889f81" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8673ca0e-a2ad-4daf-b41b-488ff53ae9b2" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="adcbd054-5eec-4028-b953-84515c0efe2f"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="b37c1c42-0a7b-4dda-b78b-5a10fc71b8c8"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="c0b73d19-c815-4458-ab77-3e2fbcd22c40"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="cf24a371-cd3c-4822-897d-e998e4aebd6b"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="0f4ec522-0064-49d9-b629-4d77a9889f81"><li><a href="../../syntax/index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="8673ca0e-a2ad-4daf-b41b-488ff53ae9b2"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">interfaces</span><a href="#" class="breadcrumb">SetupInterface</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="5ac5ae37-044e-4ff6-9c23-e46ad9fe07cc" data-section-level="1" data-section-text="SetupInterface ( execute _ on )"><h1 id="setupinterface-execute-on">SetupInterface (execute_on)</h1><p>Most user-facing objects in MOOSE inherit from the SetupInterface class. This class provides two features to objects. Foremost, it provides the the &quot;execute_on&quot; parameter, which, as the name suggests, dictates when the object is to be executed. Secondly, it adds virtual setup methods that allow derived classes to perform setup applications prior to execution.</p><section class="scrollspy" id="d6e0f691-cb57-4838-ba35-cf5b287b31d8" data-section-level="2" data-section-text="Execute On"><h2 id="execute-on">Execute On</h2><p>Any object inheriting from the SetupInterface, that adds the <code>SetupInterface::validParams()</code> within its own parameters, will have an &quot;execute_on&quot; parameter that can be set to various flags, the most common (default) flags are listed below.</p><div form="['left', 'left']" recursive class="moose-table-div"><table><thead><tr><th style=";text-align:left">Execute Flag</th><th style=";text-align:left">Description</th></tr></thead><tbody><tr><td style=";text-align:left">NONE</td><td style=";text-align:left">Never executed.</td></tr></tbody><tbody><tr><td style=";text-align:left">INITIAL</td><td style=";text-align:left">Prior to the first time step.</td></tr></tbody><tbody><tr><td style=";text-align:left">LINEAR</td><td style=";text-align:left">Prior to each residual evaluation.</td></tr></tbody><tbody><tr><td style=";text-align:left">NONLINEAR</td><td style=";text-align:left">Prior to each Jacobian evaluation.</td></tr></tbody><tbody><tr><td style=";text-align:left">TIMESTEP_END</td><td style=";text-align:left">After the solve for each time step.</td></tr></tbody><tbody><tr><td style=";text-align:left">TIMESTEP_BEGIN</td><td style=";text-align:left">Prior to the solve for each time step.</td></tr></tbody><tbody><tr><td style=";text-align:left">FINAL</td><td style=";text-align:left">At the end of the entire simulation.</td></tr></tbody><tbody><tr><td style=";text-align:left">CUSTOM</td><td style=";text-align:left">At user specified instants.</td></tr></tbody><tbody><tr><td style=";text-align:left">ALWAYS</td><td style=";text-align:left">Union of all the above flags.</td></tr></tbody></table></div><p>The &quot;execute_on&quot; parameter can be set to a single flag or multiple flags. For example, it may be desirable to only execute an object initially because the state of the auxiliary computation does not vary. In the input file snippet below, the <a href="../auxkernels/ElementLengthAux.html">ElementLengthAux</a> computation only needs to be computed initially, thus the &quot;exeucte_on&quot; parameter is set as such.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[AuxKernels]
  [./min]
    type = ElementLengthAux
    variable = min
    method = min
    execute_on = initial
  [../]
  [./max]
    type = ElementLengthAux
    variable = max
    method = max
    execute_on = initial
  [../]
[../]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#aba2655e-9738-4f51-bc29-19ad59ac3c92">(moose/test/tests/auxkernels/element_length/element_length.i)</a><p>Alternatively, it is often desirable to run a computation with multiple execute flags. For example, in the input file snippet below a <a href="../controls/TimePeriod.html">TimePeriod</a> control object that is responsible for enabling in <a href="../../syntax/Dampers/index.html">Damper</a> object needs to be run initially and prior to each timestep to guarantee that the damper is enabled when desired.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Controls]
  [./damping_control]
    type = TimePeriod
    disable_objects = &#x27;*::const_damp&#x27;
    start_time = 0.25
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d5cb10d6-2511-4d58-836b-c0a7dabb0a76">(moose/test/tests/controls/time_periods/dampers/control.i)</a><p>Depending on the system these options or others will be available, since as discussed in <a href="SetupInterface.html#creating-custom-execute-flags">Creating Custom Execute Flags</a> custom flags may be added. The complete list of execution flags is provided by MOOSE are listed in the &quot;registerExecFlags&quot; function.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#ifdef HAVE_GPERFTOOLS
#include &quot;gperftools/profiler.h&quot;
#include &quot;gperftools/heap-profiler.h&quot;
#endif

// MOOSE includes
#include &quot;MooseRevision.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;NonlinearSystemBase.h&quot;
#include &quot;AuxiliarySystem.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;MooseInit.h&quot;
#include &quot;Executioner.h&quot;
#include &quot;Executor.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;CommandLine.h&quot;
#include &quot;InfixIterator.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseObjectAction.h&quot;
#include &quot;InputParameterWarehouse.h&quot;
#include &quot;SystemInfo.h&quot;
#include &quot;RestartableDataIO.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;FileOutput.h&quot;
#include &quot;ConsoleUtils.h&quot;
#include &quot;JsonSyntaxTree.h&quot;
#include &quot;JsonInputFileFormatter.h&quot;
#include &quot;SONDefinitionFormatter.h&quot;
#include &quot;RelationshipManager.h&quot;
#include &quot;ProxyRelationshipManager.h&quot;
#include &quot;Registry.h&quot;
#include &quot;SerializerGuard.h&quot;
#include &quot;PerfGraphInterface.h&quot; // For TIME_SECTION
#include &quot;SolutionInvalidInterface.h&quot;
#include &quot;Attributes.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;CommonOutputAction.h&quot;
#include &quot;CastUniquePointer.h&quot;
#include &quot;NullExecutor.h&quot;
#include &quot;ExecFlagRegistry.h&quot;
#include &quot;SolutionInvalidity.h&quot;
#include &quot;MooseServer.h&quot;

// Regular expression includes
#include &quot;pcrecpp.h&quot;

#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/mesh_refinement.h&quot;
#include &quot;libmesh/string_to_enum.h&quot;
#include &quot;libmesh/checkpoint_io.h&quot;
#include &quot;libmesh/mesh_base.h&quot;

// System include for dynamic library methods
#ifdef LIBMESH_HAVE_DLOPEN
#include &lt;dlfcn.h&gt;
#include &lt;sys/utsname.h&gt; // utsname
#endif

// C++ includes
#include &lt;numeric&gt; // std::accumulate
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt; // for system()
#include &lt;chrono&gt;
#include &lt;thread&gt;

#define QUOTE(macro) stringifyName(macro)
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#2f4a872c-d52c-4b72-94a5-46859f48b977">(moose/framework/src/base/MooseApp.C)</a><p>The default value of &quot;execute_on&quot; is <em>linear</em> for most of MOOSE objects with the exception of:</p><ul class="browser-default"><li><p>The auxiliary kernels have the default value of <em>linear</em> and <em>timestep_end</em>. </p></li><li><p>The postprocessors have default value of <em>timestep_end</em>. </p></li><li><p>The controls have default value of <em>initial</em> and <em>timestep_end</em>. </p></li><li><p>The multi-apps have default value of <em>timestep_begin</em>. </p></li><li><p>The user objects have default value of <em>timestep_end</em>. </p></li><li><p>The outputs have default value of <em>initial</em> and <em>timestep_end</em>. </p></li><li><p>The default value for a transfer is set to be the same as the execute_on value of its corresponding sub-application.</p></li></ul><p>Several objects in the framework have custom or selected default &quot;execute_on&quot;. The default value for all objects including objects in MOOSE modules and MOOSE-based applications can be found in their parameter list.</p></section><section class="scrollspy" id="625673fb-0837-4617-9caf-1715bde17809" data-section-level="2" data-section-text="Modifying Execute On"><h2 id="modifying-execute-on">Modifying Execute On</h2><p>When creating objects that inherit from SetupInterface it is possible to set, add, or remove available execute flags by retrieving and then modifying the <code>ExecFlagEnum</code> parameter. For example, consider the snippet below (see <a class="moose-source-filename tooltipped modal-trigger" href="#6acdeb82-0545-4bcf-8372-28d96128385e">Output.C</a>).</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#cb7456c4-b5b4-48e9-85dd-1d6a436c2a66">(moose/framework/src/outputs/Output.C)</a><p>First, the &quot;execute_on&quot; is retrieved for modification by using the &quot;set&quot; method. Notice, that a second boolean argument is passed to &quot;set&quot;, this second flag enables &quot;quiet mode&quot;. Quiet mode will modify the parameter silently as if the default was the modified parameter. In this case, the parameter will be listed as un-modified by the user. That is, <code>InputParameters::isParamSetByUser</code> returns false, if quiet mode is not enabled this method would return true.</p><p>Second, the two new execution flags are added (<code>EXEC_FINAL</code> and <code>EXEC_FAILED</code>), therefore these additional options are available to all classes (all Output objects in this case) that inherit from this object.</p><p>Third, the default active flags are set to <code>EXEC_INITIAL</code> and <code>EXEC_TIMESTEP_END</code>, which are the defaults for all Output objects.</p><p>Finally, the documentation string for the &quot;execute_on&quot; parameter for the Output objects is update to reflect the changes made to the parameter. The <code>ExecFlagEnum</code> has a convenience function that generates a documentation string that includes the available options in the string.</p></section><section class="scrollspy" id="d332beed-91c2-4d24-b09a-1a3e018446dd" data-section-level="2" data-section-text="Virtual Setup Methods"><h2 id="virtual-setup-methods">Virtual Setup Methods</h2><p>The SetupInterface includes virtual methods that correspond to the primary execute flags with MOOSE, these methods are listed in the header as shown here.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">/**
* Gets called at the beginning of the simulation before this object is asked to do its job
*/
virtual void initialSetup();
/**
* Gets called at the beginning of the timestep before this object is asked to do its job
*/
virtual void timestepSetup();
/**
* Gets called just before the Jacobian is computed and before this object is asked to do its job
*/
virtual void jacobianSetup();
/**
* Gets called just before the residual is computed and before this object is asked to do its job
*/
virtual void residualSetup();
/**
* Gets called when the subdomain changes (i.e. in a Jacobian or residual loop) and before this
* object is asked to do its job
*/
virtual void subdomainSetup();
/**
* Gets called in FEProblemBase::execute() for execute flags other than initial, timestep_begin,
* nonlinear, linear and subdomain
*/
virtual void customSetup(const ExecFlagType &amp; /*exec_type*/) {}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#4c6f3f1e-0481-4473-9a2a-0f210779284a">(moose/framework/include/interfaces/SetupInterface.h)</a><p>In general, these methods should be utilized to perform &quot;setup&quot; procedures prior to the calls to execute for the corresponding execute flag.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>A few of the methods were created prior to the execute flags, thus the names do not correspond but they remain as is to keep the API consistent: the &quot;jacobianSetup&quot; methods is called prior to the &quot;NONLINEAR&quot; execute flag and the &quot;residualSetup&quot; is called prior to the &quot;LINEAR&quot; execute flag.</p></div></div></div><p>There is also a generic setup function &quot;customSetup&quot; that takes an execute flag as the argument. This function is called by MOOSE when performing evaluations of objects on the custom execute flags in <a href="SetupInterface.html#creating-custom-execute-flags">Creating Custom Execute Flags</a>.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning:</span>Note on the &quot;customSetup&quot; function</div><div class="card-content"><div class="moose-alert-content"><p>This function is not called on <em>initial</em>, <em>timestep_begin</em>, <em>subdomain</em>, <em>nonlinear</em> and <em>linear</em>. Setup operations for those execute flags should be implemented in <em>initialSetup</em>, <em>timestepSetup</em>, <em>subdomainSetup</em>, <em>jacobianSetup</em> and <em>residualSetup</em> functions respectively.</p></div></div></div></section><section class="scrollspy" id="b9e2e51d-f34c-48e1-bdc9-d5cb7733cbfc" data-section-level="2" data-section-text="Creating Custom Execute Flags"><h2 id="creating-custom-execute-flags">Creating Custom Execute Flags</h2><p>It is possible to create custom execute flags for an application. To create at utilize a custom execute flag the following steps should be followed.</p><section id="301a60a2-9238-4df2-85d4-84401ca89f6a" data-section-level="3" data-section-text="1 . Register an Execute Flag"><h3 id="1-register-an-execute-flag">1. Register an Execute Flag</h3><p>Within your application a new global <code>const</code> should be declared in a header file. For example, within the <code>LevelSetApp</code> within MOOSE modules, there is a header (LevelSetTypes.h) that declares a new flag (<code>EXEC_ADAPT_MESH</code>).</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#pragma once

#include &quot;Moose.h&quot;

namespace LevelSet
{
extern const ExecFlagType EXEC_ADAPT_MESH;
extern const ExecFlagType EXEC_COMPUTE_MARKERS;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b8b10745-2fa2-46e4-9c86-fda9f2b64aaa">(moose/modules/level_set/include/base/LevelSetTypes.h)</a><p>This new global must be registered, which occurs in the corresponding source file using the <code>registerExecFlag()</code> macro defined in <code>ExecFlagRegistry.h</code>.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
// Level set includes
#include &quot;LevelSetTypes.h&quot;

// MOOSE includes
#include &quot;ExecFlagRegistry.h&quot;

const ExecFlagType LevelSet::EXEC_ADAPT_MESH = registerExecFlag(&quot;ADAPT_MESH&quot;);
const ExecFlagType LevelSet::EXEC_COMPUTE_MARKERS = registerExecFlag(&quot;COMPUTE_MARKERS&quot;);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#7453a2b7-41e0-4158-854b-fed7e8cc65cb">(moose/modules/level_set/src/base/LevelSetTypes.C)</a></section><section id="7dcfecc5-0f51-4de7-bb10-35b8dc81c43d" data-section-level="3" data-section-text="2 . Add the Execute Flag to InputParameters"><h3 id="2-add-the-execute-flag-to-inputparameters">2. Add the Execute Flag to InputParameters</h3><p>After a flag is registered, it must be made available to the object(s) in which are desired to be executed with the custom flag. This is done by adding this new flag to an existing objects valid parameters. For example, the following adds the <code>EXEC_ADAPT_MESH</code> flag to a <code>Transfer</code> object.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">ExecFlagEnum &amp; exec = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);
exec.addAvailableFlags(LevelSet::EXEC_ADAPT_MESH, LevelSet::EXEC_COMPUTE_MARKERS);
exec = {LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH};
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#f83f30dc-663e-4879-98b6-46c851d7278c">(moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C)</a></section><section id="a34b1949-011d-4ee9-984d-3a5dc2825be3" data-section-level="3" data-section-text="3 . Use the Execute Flag"><h3 id="3-use-the-execute-flag">3. Use the Execute Flag</h3><p>Depending on what type of custom computation is desired, various MOOSE execution calls accept execution flags, which will spawn calculations. For example, the <code>LevelSetProblem</code> contains a custom method that uses the <code>EXEC_ADAPT_MESH</code> flag to perform an additional <a href="../../syntax/Transfers/index.html"><code>MultiAppTransfer</code></a> execution.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">execMultiAppTransfers(LevelSet::EXEC_ADAPT_MESH, MultiAppTransfer::TO_MULTIAPP);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#e3b353c2-6805-4d4d-9435-158952d8e182">(moose/modules/level_set/src/base/LevelSetProblem.C)</a></section></section></section><div class="moose-modal modal" id="aba2655e-9738-4f51-bc29-19ad59ac3c92"><div class="modal-content"><h4>(moose/test/tests/auxkernels/element_length/element_length.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 100
[]

[AuxVariables]
  [./min]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./max]
    order = CONSTANT
    family = MONOMIAL
  [../]
[]

[AuxKernels]
  [./min]
    type = ElementLengthAux
    variable = min
    method = min
    execute_on = initial
  [../]
  [./max]
    type = ElementLengthAux
    variable = max
    method = max
    execute_on = initial
  [../]
[../]

[Problem]
  type = FEProblem
  solve = false
[]

[Executioner]
  type = Steady
[]

[Outputs]
  execute_on = &#x27;TIMESTEP_END&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="d5cb10d6-2511-4d58-836b-c0a7dabb0a76"><div class="modal-content"><h4>(moose/test/tests/controls/time_periods/dampers/control.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [./u]
  [../]
[]

[Kernels]
  [./diff]
    type = CoefDiffusion
    variable = u
    coef = 0.1
  [../]
  [./time]
    type = TimeDerivative
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  [../]
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  nl_rel_tol = 0.95e-8
[]

[Postprocessors]
  [./nlin]
    type = NumNonlinearIterations
  [../]
[]

[Dampers]
  [./const_damp]
    type = ConstantDamper
    damping = 0.9
  [../]
[]

[Outputs]
  csv = true
[]

[Controls]
  [./damping_control]
    type = TimePeriod
    disable_objects = &#x27;*::const_damp&#x27;
    start_time = 0.25
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="2f4a872c-d52c-4b72-94a5-46859f48b977"><div class="modal-content"><h4>(moose/framework/src/base/MooseApp.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#ifdef HAVE_GPERFTOOLS
#include &quot;gperftools/profiler.h&quot;
#include &quot;gperftools/heap-profiler.h&quot;
#endif

// MOOSE includes
#include &quot;MooseRevision.h&quot;
#include &quot;AppFactory.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;NonlinearSystemBase.h&quot;
#include &quot;AuxiliarySystem.h&quot;
#include &quot;MooseSyntax.h&quot;
#include &quot;MooseInit.h&quot;
#include &quot;Executioner.h&quot;
#include &quot;Executor.h&quot;
#include &quot;PetscSupport.h&quot;
#include &quot;Conversion.h&quot;
#include &quot;CommandLine.h&quot;
#include &quot;InfixIterator.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseObjectAction.h&quot;
#include &quot;InputParameterWarehouse.h&quot;
#include &quot;SystemInfo.h&quot;
#include &quot;RestartableDataIO.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;FileOutput.h&quot;
#include &quot;ConsoleUtils.h&quot;
#include &quot;JsonSyntaxTree.h&quot;
#include &quot;JsonInputFileFormatter.h&quot;
#include &quot;SONDefinitionFormatter.h&quot;
#include &quot;RelationshipManager.h&quot;
#include &quot;ProxyRelationshipManager.h&quot;
#include &quot;Registry.h&quot;
#include &quot;SerializerGuard.h&quot;
#include &quot;PerfGraphInterface.h&quot; // For TIME_SECTION
#include &quot;SolutionInvalidInterface.h&quot;
#include &quot;Attributes.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;CommonOutputAction.h&quot;
#include &quot;CastUniquePointer.h&quot;
#include &quot;NullExecutor.h&quot;
#include &quot;ExecFlagRegistry.h&quot;
#include &quot;SolutionInvalidity.h&quot;
#include &quot;MooseServer.h&quot;

// Regular expression includes
#include &quot;pcrecpp.h&quot;

#include &quot;libmesh/exodusII_io.h&quot;
#include &quot;libmesh/mesh_refinement.h&quot;
#include &quot;libmesh/string_to_enum.h&quot;
#include &quot;libmesh/checkpoint_io.h&quot;
#include &quot;libmesh/mesh_base.h&quot;

// System include for dynamic library methods
#ifdef LIBMESH_HAVE_DLOPEN
#include &lt;dlfcn.h&gt;
#include &lt;sys/utsname.h&gt; // utsname
#endif

// C++ includes
#include &lt;numeric&gt; // std::accumulate
#include &lt;fstream&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdlib&gt; // for system()
#include &lt;chrono&gt;
#include &lt;thread&gt;

#define QUOTE(macro) stringifyName(macro)

void
MooseApp::addAppParam(InputParameters &amp; params)
{
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;app_to_run&quot;,
      &quot;--app &lt;AppName&gt;&quot;,
      &quot;Specify the application that should be used to run the input file. This must match an &quot;
      &quot;application name registered to the application factory. Note that this option is &quot;
      &quot;case-sensitive.&quot;);
}

InputParameters
MooseApp::validParams()
{
  InputParameters params = emptyInputParameters();

  params.addCommandLineParam&lt;bool&gt;(
      &quot;display_version&quot;, &quot;-v --version&quot;, false, &quot;Print application version&quot;);
  params.addCommandLineParam&lt;std::vector&lt;std::string&gt;&gt;(
      &quot;input_file&quot;,
      &quot;-i &lt;input_files&gt;&quot;,
      &quot;Specify one or multiple input files. Multiple files get merged into a single simulation &quot;
      &quot;input.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;mesh_only&quot;,
      &quot;--mesh-only [mesh_file_name]&quot;,
      &quot;Setup and Output the input mesh only (Default: \&quot;&lt;input_file_name&gt;_in.e\&quot;)&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;show_input&quot;,
                                   &quot;--show-input&quot;,
                                   false,
                                   &quot;Shows the parsed input file before running the simulation.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_outputs&quot;, &quot;--show-outputs&quot;, false, &quot;Shows the output execution time information.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_controls&quot;, &quot;--show-controls&quot;, false, &quot;Shows the Control logic available and executed.&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;no_color&quot;, &quot;--no-color&quot;, false, &quot;Disable coloring of all Console outputs.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;color&quot;,
                                          &quot;--color [auto,on,off]&quot;,
                                          &quot;default-on&quot;,
                                          &quot;Whether to use color in console output (default &#x27;on&#x27;).&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;help&quot;, &quot;-h --help&quot;, false, &quot;Displays CLI usage statement.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;minimal&quot;,
      &quot;--minimal&quot;,
      false,
      &quot;Ignore input file and build a minimal application with Transient executioner.&quot;);

#ifdef WASP_ENABLED
  params.addCommandLineParam&lt;bool&gt;(
      &quot;language_server&quot;,
      &quot;--language-server&quot;,
      &quot;Starts a process to communicate with development tools using the language server protocol&quot;);
#endif

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;definition&quot;, &quot;--definition&quot;, &quot;Shows a SON style input definition dump for input validation&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;dump&quot;, &quot;--dump [search_string]&quot;, &quot;Shows a dump of available input file syntax.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry&quot;, &quot;--registry&quot;, &quot;Lists all known objects and actions.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;registry_hit&quot;, &quot;--registry-hit&quot;, &quot;Lists all known objects and actions in hit format.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;use_executor&quot;, &quot;--executor&quot;, false, &quot;Use the new Executor system instead of Executioners&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;apptype&quot;, &quot;--type&quot;, false, &quot;Return the name of the application object.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;yaml&quot;, &quot;--yaml&quot;, &quot;Dumps input file syntax in YAML format.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;json&quot;, &quot;--json&quot;, &quot;Dumps input file syntax in JSON format.&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;syntax&quot;, &quot;--syntax&quot;, false, &quot;Dumps the associated Action syntax paths ONLY&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;show_docs&quot;, &quot;--docs&quot;, false, &quot;print url/path to the documentation website&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;check_input&quot;,
                                   &quot;--check-input&quot;,
                                   false,
                                   &quot;Check the input file (i.e. requires -i &lt;filename&gt;) and quit.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;show_inputs&quot;,
      &quot;--show-copyable-inputs&quot;,
      &quot;Shows the directories able to be installed (copied) into a user-writable location&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;copy_inputs&quot;,
                                          &quot;--copy-inputs &lt;dir&gt;&quot;,
                                          &quot;Copies installed inputs (e.g. tests, examples, etc.) to &quot;
                                          &quot;an directory named  &lt;appname&gt;_&lt;dir&gt;.&quot;);
  params.addCommandLineParam&lt;std::string&gt;(&quot;run&quot;,
                                          &quot;--run&quot;,
                                          &quot;Runs the inputs in the current directory copied to a &quot;
                                          &quot;user-writable location by \&quot;--copy-inputs\&quot;&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;list_constructed_objects&quot;,
      &quot;--list-constructed-objects&quot;,
      false,
      &quot;List all moose object type names constructed by the master app factory.&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;n_threads&quot;, &quot;--n-threads=&lt;n&gt;&quot;, 1, &quot;Runs the specified number of threads per process&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;allow_unused&quot;,
                                   &quot;-w --allow-unused&quot;,
                                   false,
                                   &quot;Warn about unused input file options instead of erroring.&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;error_unused&quot;,
                                   &quot;-e --error-unused&quot;,
                                   false,
                                   &quot;Error when encountering unused input file options&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_override&quot;,
      &quot;-o --error-override&quot;,
      false,
      &quot;Error when encountering overridden or parameters supplied multiple times&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;error_deprecated&quot;, &quot;--error-deprecated&quot;, false, &quot;Turn deprecated code messages into Errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;distributed_mesh&quot;,
      &quot;--distributed-mesh&quot;,
      false,
      &quot;The libMesh Mesh underlying MooseMesh should always be a DistributedMesh&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;split_mesh&quot;,
      &quot;--split-mesh [splits]&quot;,
      &quot;comma-separated list of numbers of chunks to split the mesh into&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;split_file&quot;,
                                          &quot;--split-file [filename]&quot;,
                                          &quot;&quot;,
                                          &quot;optional name of split mesh file(s) to write/read&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;use_split&quot;, &quot;--use-split&quot;, false, &quot;use split distributed mesh files&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(
      &quot;refinements&quot;,
      &quot;-r &lt;n&gt;&quot;,
      0,
      &quot;Specify additional initial uniform mesh refinements for grid convergence studies&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recover&quot;,
                                          &quot;--recover [file_base]&quot;,
                                          &quot;Continue the calculation.  If file_base is omitted then &quot;
                                          &quot;the most recent recovery file will be utilized&quot;);

  params.addCommandLineParam&lt;std::string&gt;(&quot;recoversuffix&quot;,
                                          &quot;--recoversuffix [suffix]&quot;,
                                          &quot;Use a different file extension, other than cpr, &quot;
                                          &quot;for a recovery file&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;half_transient&quot;,
                                   &quot;--half-transient&quot;,
                                   false,
                                   &quot;When true the simulation will only run half of &quot;
                                   &quot;its specified transient (ie half the &quot;
                                   &quot;timesteps).  This is useful for testing &quot;
                                   &quot;recovery and restart&quot;);

  // No default on these two options, they must not both be valid
  params.addCommandLineParam&lt;bool&gt;(
      &quot;trap_fpe&quot;,
      &quot;--trap-fpe&quot;,
      &quot;Enable Floating Point Exception handling in critical sections of &quot;
      &quot;code.  This is enabled automatically in DEBUG mode&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_trap_fpe&quot;,
                                   &quot;--no-trap-fpe&quot;,
                                   &quot;Disable Floating Point Exception handling in critical &quot;
                                   &quot;sections of code when using DEBUG mode.&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;error&quot;, &quot;--error&quot;, false, &quot;Turn all warnings into errors&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;timing&quot;,
      &quot;-t --timing&quot;,
      false,
      &quot;Enable all performance logging for timing purposes. This will disable all &quot;
      &quot;screen output of performance logs for all Console objects.&quot;);
  params.addCommandLineParam&lt;bool&gt;(&quot;no_timing&quot;,
                                   &quot;--no-timing&quot;,
                                   false,
                                   &quot;Disabled performance logging. Overrides -t or --timing &quot;
                                   &quot;if passed in conjunction with this flag&quot;);

  params.addCommandLineParam&lt;bool&gt;(
      &quot;allow_test_objects&quot;, &quot;--allow-test-objects&quot;, false, &quot;Register test objects and syntax.&quot;);

  // Options ignored by MOOSE but picked up by libMesh, these are here so that they are displayed in
  // the application help
  params.addCommandLineParam&lt;bool&gt;(
      &quot;keep_cout&quot;,
      &quot;--keep-cout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);
  params.addCommandLineParam&lt;bool&gt;(
      &quot;redirect_stdout&quot;,
      &quot;--redirect-stdout&quot;,
      false,
      &quot;Keep standard output from all processors when running in parallel&quot;);

  params.addCommandLineParam&lt;std::string&gt;(
      &quot;timpi_sync&quot;,
      &quot;--timpi-sync &lt;sync type&gt;&quot;,
      &quot;nbx&quot;,
      &quot;Changes the sync type used in spare parallel communitations within the TIMPI library &quot;
      &quot;(advanced option).&quot;);

  // Options for debugging
  params.addCommandLineParam&lt;std::string&gt;(&quot;start_in_debugger&quot;,
                                          &quot;--start-in-debugger &lt;debugger&gt;&quot;,
                                          &quot;Start the application and attach a debugger.  This will &quot;
                                          &quot;launch xterm windows using the command you specify for &quot;
                                          &quot;&#x27;debugger&#x27;&quot;);

  params.addCommandLineParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;,
                                           &quot;--stop-for-debugger [seconds]&quot;,
                                           30,
                                           &quot;Pauses the application during startup for the &quot;
                                           &quot;specified time to allow for connection of debuggers.&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;perf_graph_live_all&quot;,
                                   &quot;--perf-graph-live-all&quot;,
                                   false,
                                   &quot;Forces printing of ALL progress messages.&quot;);

  params.addCommandLineParam&lt;bool&gt;(&quot;disable_perf_graph_live&quot;,
                                   &quot;--disable-perf-graph-live&quot;,
                                   false,
                                   &quot;Disables PerfGraph Live Printing.&quot;);

  params.addParam&lt;bool&gt;(
      &quot;automatic_automatic_scaling&quot;, false, &quot;Whether to turn on automatic scaling by default.&quot;);

#ifdef HAVE_GPERFTOOLS
  params.addCommandLineParam&lt;std::string&gt;(
      &quot;gperf_profiler_on&quot;,
      &quot;--gperf-profiler-on [ranks]&quot;,
      &quot;To generate profiling report only on comma-separated list of MPI ranks.&quot;);
#endif

  params.addPrivateParam&lt;std::string&gt;(&quot;_app_name&quot;); // the name passed to AppFactory::create
  params.addPrivateParam&lt;std::string&gt;(&quot;_type&quot;);
  params.addPrivateParam&lt;int&gt;(&quot;_argc&quot;);
  params.addPrivateParam&lt;char **&gt;(&quot;_argv&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  params.addPrivateParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_level&quot;);
  params.addPrivateParam&lt;unsigned int&gt;(&quot;_multiapp_number&quot;);
  params.addPrivateParam&lt;const MooseMesh *&gt;(&quot;_master_mesh&quot;);
  params.addPrivateParam&lt;const MooseMesh *&gt;(&quot;_master_displaced_mesh&quot;);
  params.addPrivateParam&lt;std::string&gt;(&quot;_input_text&quot;, &quot;&quot;); // input string passed by language server

  params.addParam&lt;bool&gt;(
      &quot;use_legacy_material_output&quot;,
      true,
      &quot;Set false to allow material properties to be output on INITIAL, not just TIMESTEP_END.&quot;);

  MooseApp::addAppParam(params);

  return params;
}

MooseApp::MooseApp(InputParameters parameters)
  : ConsoleStreamInterface(*this),
    PerfGraphInterface(*this, &quot;MooseApp&quot;),
    ParallelObject(*parameters.get&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(
        &quot;_comm&quot;)), // Can&#x27;t call getParam() before pars is set
    _name(parameters.get&lt;std::string&gt;(&quot;_app_name&quot;)),
    _pars(parameters),
    _type(getParam&lt;std::string&gt;(&quot;_type&quot;)),
    _comm(getParam&lt;std::shared_ptr&lt;Parallel::Communicator&gt;&gt;(&quot;_comm&quot;)),
    _file_base_set_by_user(false),
    _output_position_set(false),
    _start_time_set(false),
    _start_time(0.0),
    _global_time_offset(0.0),
    _input_parameter_warehouse(std::make_unique&lt;InputParameterWarehouse&gt;()),
    _action_factory(*this),
    _action_warehouse(*this, _syntax, _action_factory),
    _output_warehouse(*this),
    _parser(*this, _action_warehouse),
    _restartable_data(libMesh::n_threads()),
    _perf_graph(createRecoverablePerfGraph()),
    _solution_invalidity(createRecoverableSolutionInvalidity()),
    _rank_map(*_comm, _perf_graph),
    _use_executor(parameters.get&lt;bool&gt;(&quot;use_executor&quot;)),
    _null_executor(NULL),
    _use_nonlinear(true),
    _use_eigen_value(false),
    _enable_unused_check(ERROR_UNUSED),
    _factory(*this),
    _error_overridden(false),
    _ready_to_exit(false),
    _initial_from_file(false),
    _distributed_mesh_on_command_line(false),
    _recover(false),
    _restart(false),
    _split_mesh(false),
    _use_split(parameters.get&lt;bool&gt;(&quot;use_split&quot;)),
#ifdef DEBUG
    _trap_fpe(true),
#else
    _trap_fpe(false),
#endif
    _restart_recover_suffix(&quot;cpr&quot;),
    _half_transient(false),
    _check_input(getParam&lt;bool&gt;(&quot;check_input&quot;)),
    _multiapp_level(
        isParamValid(&quot;_multiapp_level&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_level&quot;) : 0),
    _multiapp_number(
        isParamValid(&quot;_multiapp_number&quot;) ? parameters.get&lt;unsigned int&gt;(&quot;_multiapp_number&quot;) : 0),
    _master_mesh(isParamValid(&quot;_master_mesh&quot;) ? parameters.get&lt;const MooseMesh *&gt;(&quot;_master_mesh&quot;)
                                              : nullptr),
    _master_displaced_mesh(isParamValid(&quot;_master_displaced_mesh&quot;)
                               ? parameters.get&lt;const MooseMesh *&gt;(&quot;_master_displaced_mesh&quot;)
                               : nullptr),
    _mesh_generator_system(*this),
    _execute_flags(moose::internal::ExecFlagRegistry::getExecFlagRegistry().getFlags()),
    _output_buffer_cache(nullptr),
    _automatic_automatic_scaling(getParam&lt;bool&gt;(&quot;automatic_automatic_scaling&quot;))
{
  // Set the TIMPI sync type via --timpi-sync
  const auto &amp; timpi_sync = parameters.get&lt;std::string&gt;(&quot;timpi_sync&quot;);
  const_cast&lt;Parallel::Communicator &amp;&gt;(comm()).sync_type(timpi_sync);

#ifdef HAVE_GPERFTOOLS
  if (isUltimateMaster())
  {
    bool has_cpu_profiling = false;
    bool has_heap_profiling = false;
    static std::string cpu_profile_file;
    static std::string heap_profile_file;

    // For CPU profiling, users need to have environment &#x27;MOOSE_PROFILE_BASE&#x27;
    if (std::getenv(&quot;MOOSE_PROFILE_BASE&quot;))
    {
      has_cpu_profiling = true;
      cpu_profile_file =
          std::getenv(&quot;MOOSE_PROFILE_BASE&quot;) + std::to_string(_comm-&gt;rank()) + &quot;.prof&quot;;
      // create directory if needed
      auto name = MooseUtils::splitFileName(cpu_profile_file);
      if (!name.first.empty())
      {
        if (processor_id() == 0)
          MooseUtils::makedirs(name.first.c_str());
        _comm-&gt;barrier();
      }
    }

    // For Heap profiling, users need to have &#x27;MOOSE_HEAP_BASE&#x27;
    if (std::getenv(&quot;MOOSE_HEAP_BASE&quot;))
    {
      has_heap_profiling = true;
      heap_profile_file = std::getenv(&quot;MOOSE_HEAP_BASE&quot;) + std::to_string(_comm-&gt;rank());
      // create directory if needed
      auto name = MooseUtils::splitFileName(heap_profile_file);
      if (!name.first.empty())
      {
        if (processor_id() == 0)
          MooseUtils::makedirs(name.first.c_str());
        _comm-&gt;barrier();
      }
    }

    // turn on profiling only on selected ranks
    if (isParamValid(&quot;gperf_profiler_on&quot;))
    {
      auto rankstr = getParam&lt;std::string&gt;(&quot;gperf_profiler_on&quot;);
      std::vector&lt;processor_id_type&gt; ranks;
      bool success = MooseUtils::tokenizeAndConvert(rankstr, ranks, &quot;, &quot;);
      if (!success)
        mooseError(&quot;Invalid argument for --gperf-profiler-on: &#x27;&quot;, rankstr, &quot;&#x27;&quot;);
      for (auto &amp; rank : ranks)
      {
        if (rank &gt;= _comm-&gt;size())
          mooseError(&quot;Invalid argument for --gperf-profiler-on: &quot;,
                     rank,
                     &quot; is greater than or equal to &quot;,
                     _comm-&gt;size());
        if (rank == _comm-&gt;rank())
        {
          _cpu_profiling = has_cpu_profiling;
          _heap_profiling = has_heap_profiling;
        }
      }
    }
    else
    {
      _cpu_profiling = has_cpu_profiling;
      _heap_profiling = has_heap_profiling;
    }

    if (_cpu_profiling)
      if (!ProfilerStart(cpu_profile_file.c_str()))
        mooseError(&quot;CPU profiler is not started properly&quot;);

    if (_heap_profiling)
    {
      HeapProfilerStart(heap_profile_file.c_str());
      if (!IsHeapProfilerRunning())
        mooseError(&quot;Heap profiler is not started properly&quot;);
    }
  }
#else
  if (std::getenv(&quot;MOOSE_PROFILE_BASE&quot;) || std::getenv(&quot;MOOSE_HEAP_BASE&quot;))
    mooseError(&quot;gperftool is not available for CPU or heap profiling&quot;);
#endif

  // If this will be a language server then turn off output until that starts
  if (isParamValid(&quot;language_server&quot;))
    _output_buffer_cache = Moose::out.rdbuf(nullptr);

  Registry::addKnownLabel(_type);
  Moose::registerAll(_factory, _action_factory, _syntax);

  _the_warehouse = std::make_unique&lt;TheWarehouse&gt;();
  _the_warehouse-&gt;registerAttribute&lt;AttribMatrixTags&gt;(&quot;matrix_tags&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribVectorTags&gt;(&quot;vector_tags&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribExecOns&gt;(&quot;exec_ons&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribSubdomains&gt;(&quot;subdomains&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribBoundaries&gt;(&quot;boundaries&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribThread&gt;(&quot;thread&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribExecutionOrderGroup&gt;(&quot;execution_order_group&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribPreIC&gt;(&quot;pre_ic&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribPreAux&gt;(&quot;pre_aux&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribPostAux&gt;(&quot;post_aux&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribName&gt;(&quot;name&quot;, &quot;dummy&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribSystem&gt;(&quot;system&quot;, &quot;dummy&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribVar&gt;(&quot;variable&quot;, -1);
  _the_warehouse-&gt;registerAttribute&lt;AttribInterfaces&gt;(&quot;interfaces&quot;, 0);
  _the_warehouse-&gt;registerAttribute&lt;AttribSysNum&gt;(&quot;sys_num&quot;, libMesh::invalid_uint);
  _the_warehouse-&gt;registerAttribute&lt;AttribResidualObject&gt;(&quot;residual_object&quot;);
  _the_warehouse-&gt;registerAttribute&lt;AttribSorted&gt;(&quot;sorted&quot;);

  if (isParamValid(&quot;_argc&quot;) &amp;&amp; isParamValid(&quot;_argv&quot;))
  {
    int argc = getParam&lt;int&gt;(&quot;_argc&quot;);
    char ** argv = getParam&lt;char **&gt;(&quot;_argv&quot;);

    _sys_info = std::make_unique&lt;SystemInfo&gt;(argc, argv);
  }
  if (isParamValid(&quot;_command_line&quot;))
    _command_line = getParam&lt;std::shared_ptr&lt;CommandLine&gt;&gt;(&quot;_command_line&quot;);
  else
    mooseError(&quot;Valid CommandLine object required&quot;);

  if (_check_input &amp;&amp; isParamValid(&quot;recover&quot;))
    mooseError(&quot;Cannot run --check-input with --recover. Recover files might not exist&quot;);

  if (isParamValid(&quot;start_in_debugger&quot;) &amp;&amp; _multiapp_level == 0)
  {
    auto command = getParam&lt;std::string&gt;(&quot;start_in_debugger&quot;);

    Moose::out &lt;&lt; &quot;Starting in debugger using: &quot; &lt;&lt; command &lt;&lt; std::endl;

    auto hostname = MooseUtils::hostname();

    std::stringstream command_stream;

    // This will start XTerm and print out some info first... then run the debugger
    command_stream &lt;&lt; &quot;xterm -e \&quot;echo &#x27;Rank: &quot; &lt;&lt; processor_id() &lt;&lt; &quot;  Hostname: &quot; &lt;&lt; hostname
                   &lt;&lt; &quot;  PID: &quot; &lt;&lt; getpid() &lt;&lt; &quot;&#x27;; echo &#x27;&#x27;; &quot;;

    // Figure out how to run the debugger
    if (command.find(&quot;lldb&quot;) != std::string::npos || command.find(&quot;gdb&quot;) != std::string::npos)
      command_stream &lt;&lt; command &lt;&lt; &quot; -p &quot; &lt;&lt; getpid();
    else
      mooseError(&quot;Unknown debugger: &quot;,
                 command,
                 &quot;\nIf this is truly what you meant then contact moose-users to have a discussion &quot;
                 &quot;about adding your debugger.&quot;);

    // Finish up the command
    command_stream &lt;&lt; &quot;\&quot;&quot;
                   &lt;&lt; &quot; &amp; &quot;;

    std::string command_string = command_stream.str();
    Moose::out &lt;&lt; &quot;Running: &quot; &lt;&lt; command_string &lt;&lt; std::endl;

    int ret = std::system(command_string.c_str());
    libmesh_ignore(ret);

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(10));
  }

  if (!parameters.isParamSetByAddParam(&quot;stop_for_debugger&quot;))
  {
    Moose::out &lt;&lt; &quot;\nStopping for &quot; &lt;&lt; getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)
               &lt;&lt; &quot; seconds to allow attachment from a debugger.\n&quot;;

    Moose::out &lt;&lt; &quot;\nAll of the processes you can connect to:\n&quot;;
    Moose::out &lt;&lt; &quot;rank - hostname - pid\n&quot;;

    auto hostname = MooseUtils::hostname();

    {
      // The &#x27;false&#x27; turns off the serialization warning
      SerializerGuard sg(_communicator, false); // Guarantees that the processors print in order
      Moose::err &lt;&lt; processor_id() &lt;&lt; &quot; - &quot; &lt;&lt; hostname &lt;&lt; &quot; - &quot; &lt;&lt; getpid() &lt;&lt; &quot;\n&quot;;
    }

    Moose::out &lt;&lt; &quot;\nWaiting...\n&quot; &lt;&lt; std::endl;

    // Sleep to allow time for the debugger to attach
    std::this_thread::sleep_for(std::chrono::seconds(getParam&lt;unsigned int&gt;(&quot;stop_for_debugger&quot;)));
  }

  if (_master_mesh &amp;&amp; _multiapp_level == 0)
    mooseError(&quot;Mesh can be passed in only for sub-apps&quot;);

  if (_master_displaced_mesh &amp;&amp; !_master_mesh)
    mooseError(&quot;_master_mesh should have been set when _master_displaced_mesh is set&quot;);

  // Data specifically associated with the mesh (meta-data) that will read from the restart
  // file early during the simulation setup so that they are available to Actions and other objects
  // that need them during the setup process. Most of the restartable data isn&#x27;t made available
  // until all objects have been created and all Actions have been executed (i.e. initialSetup).
  registerRestartableDataMapName(MooseApp::MESH_META_DATA, &quot;mesh&quot;);

  if (parameters.have_parameter&lt;bool&gt;(&quot;use_legacy_dirichlet_bc&quot;))
    mooseDeprecated(&quot;The parameter &#x27;use_legacy_dirichlet_bc&#x27; is no longer valid.\n\n&quot;,
                    &quot;All Dirichlet boundary conditions are preset by default.\n\n&quot;,
                    &quot;Remove said parameter in &quot;,
                    name(),
                    &quot; to remove this deprecation warning.&quot;);

  Moose::out &lt;&lt; std::flush;
}

MooseApp::~MooseApp()
{
#ifdef HAVE_GPERFTOOLS
  // CPU profiling stop
  if (_cpu_profiling)
    ProfilerStop();
  // Heap profiling stop
  if (_heap_profiling)
    HeapProfilerStop();
#endif
  _action_warehouse.clear();
  _executioner.reset();
  _the_warehouse.reset();

  // Don&#x27;t wait for implicit destruction of input parameter storage
  _input_parameter_warehouse.reset();

#ifdef LIBMESH_HAVE_DLOPEN
  // Close any open dynamic libraries
  for (const auto &amp; lib_pair : _lib_handles)
    dlclose(lib_pair.second.library_handle);
#endif
}

std::string
MooseApp::getFrameworkVersion() const
{
  return MOOSE_VERSION;
}

std::string
MooseApp::getVersion() const
{
  return MOOSE_VERSION;
}

std::string
MooseApp::getPrintableVersion() const
{
  return getPrintableName() + &quot; Version: &quot; + getVersion();
}

void
MooseApp::setupOptions()
{
  TIME_SECTION(&quot;setupOptions&quot;, 5, &quot;Setting Up Options&quot;);

  // Print the header, this is as early as possible
  auto hdr = header();
  if (hdr.length() != 0)
  {
    if (multiAppLevel() &gt; 0)
      MooseUtils::indentMessage(_name, hdr);
    Moose::out &lt;&lt; hdr &lt;&lt; std::endl;
  }

  if (getParam&lt;bool&gt;(&quot;error_unused&quot;))
    setCheckUnusedFlag(true);
  else if (getParam&lt;bool&gt;(&quot;allow_unused&quot;))
    setCheckUnusedFlag(false);

  if (getParam&lt;bool&gt;(&quot;error_override&quot;))
    setErrorOverridden();

  _distributed_mesh_on_command_line = getParam&lt;bool&gt;(&quot;distributed_mesh&quot;);

  _half_transient = getParam&lt;bool&gt;(&quot;half_transient&quot;);

  // The no_timing flag takes precedence over the timing flag.
  if (getParam&lt;bool&gt;(&quot;no_timing&quot;))
  {
    _pars.set&lt;bool&gt;(&quot;timing&quot;) = false;

    _perf_graph.setActive(false);
  }

  if (isParamValid(&quot;trap_fpe&quot;) &amp;&amp; isParamValid(&quot;no_trap_fpe&quot;))
    mooseError(&quot;Cannot use both \&quot;--trap-fpe\&quot; and \&quot;--no-trap-fpe\&quot; flags.&quot;);
  if (isParamValid(&quot;trap_fpe&quot;))
    _trap_fpe = true;
  else if (isParamValid(&quot;no_trap_fpe&quot;))
    _trap_fpe = false;

  // Turn all warnings in MOOSE to errors (almost see next logic block)
  Moose::_warnings_are_errors = getParam&lt;bool&gt;(&quot;error&quot;);

  // Deprecated messages can be toggled to errors independently from everything else.
  Moose::_deprecated_is_error = getParam&lt;bool&gt;(&quot;error_deprecated&quot;);

  if (isUltimateMaster()) // makes sure coloring isn&#x27;t reset incorrectly in multi-app settings
  {
    // Toggle the color console off
    Moose::setColorConsole(true, true); // set default color condition
    if (getParam&lt;bool&gt;(&quot;no_color&quot;))
      Moose::setColorConsole(false);

    char * c_color = std::getenv(&quot;MOOSE_COLOR&quot;);
    std::string color = &quot;on&quot;;
    if (c_color)
      color = c_color;
    if (getParam&lt;std::string&gt;(&quot;color&quot;) != &quot;default-on&quot;)
      color = getParam&lt;std::string&gt;(&quot;color&quot;);

    if (color == &quot;auto&quot;)
      Moose::setColorConsole(true);
    else if (color == &quot;on&quot;)
      Moose::setColorConsole(true, true);
    else if (color == &quot;off&quot;)
      Moose::setColorConsole(false);
    else
      mooseWarning(&quot;ignoring invalid --color arg (want &#x27;auto&#x27;, &#x27;on&#x27;, or &#x27;off&#x27;)&quot;);
  }

  // this warning goes below --color processing to honor that setting for
  // the warning. And below settings for warnings/error setup.
  if (getParam&lt;bool&gt;(&quot;no_color&quot;))
    mooseDeprecated(&quot;The --no-color flag is deprecated. Use &#x27;--color off&#x27; instead.&quot;);

// If there&#x27;s no threading model active, but the user asked for
// --n-threads &gt; 1 on the command line, throw a mooseError.  This is
// intended to prevent situations where the user has potentially
// built MOOSE incorrectly (neither TBB nor pthreads found) and is
// asking for multiple threads, not knowing that there will never be
// any threads launched.
#if !LIBMESH_USING_THREADS
  if (libMesh::command_line_value(&quot;--n-threads&quot;, 1) &gt; 1)
    mooseError(&quot;You specified --n-threads &gt; 1, but there is no threading model active!&quot;);
#endif

  // Build a minimal running application, ignoring the input file.
  if (getParam&lt;bool&gt;(&quot;minimal&quot;))
    createMinimalApp();

  else if (getParam&lt;bool&gt;(&quot;display_version&quot;))
  {
    Moose::perf_log.disable_logging();
    Moose::out &lt;&lt; getPrintableVersion() &lt;&lt; std::endl;
    _ready_to_exit = true;
    return;
  }
  else if (getParam&lt;bool&gt;(&quot;help&quot;))
  {
    Moose::perf_log.disable_logging();

    _command_line-&gt;printUsage();
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;dump&quot;))
  {
    Moose::perf_log.disable_logging();

    // Get command line argument following --dump on command line
    std::string following_arg = getParam&lt;std::string&gt;(&quot;dump&quot;);

    // The argument following --dump is a parameter search string,
    // which can be empty.
    std::string param_search;
    if (!following_arg.empty() &amp;&amp; (following_arg.find(&#x27;-&#x27;) != 0))
      param_search = following_arg;

    JsonSyntaxTree tree(param_search);

    {
      TIME_SECTION(&quot;dump&quot;, 1, &quot;Building Syntax Tree&quot;);
      _parser.buildJsonSyntaxTree(tree);
    }

    // Turn off live printing so that it doesn&#x27;t mess with the dump
    _perf_graph.disableLivePrint();

    JsonInputFileFormatter formatter;
    Moose::out &lt;&lt; &quot;\n### START DUMP DATA ###\n&quot;
               &lt;&lt; formatter.toString(tree.getRoot()) &lt;&lt; &quot;\n### END DUMP DATA ###&quot; &lt;&lt; std::endl;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;registry&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::out &lt;&lt; &quot;Label\tType\tName\tClass\tFile\n&quot;;

    auto &amp; objmap = Registry::allObjects();
    for (auto &amp; entry : objmap)
      for (auto &amp; obj : entry.second)
        Moose::out &lt;&lt; entry.first &lt;&lt; &quot;\tobject\t&quot; &lt;&lt; obj-&gt;name() &lt;&lt; &quot;\t&quot; &lt;&lt; obj-&gt;_classname &lt;&lt; &quot;\t&quot;
                   &lt;&lt; obj-&gt;_file &lt;&lt; &quot;\n&quot;;

    auto &amp; actmap = Registry::allActions();
    for (auto &amp; entry : actmap)
    {
      for (auto &amp; act : entry.second)
        Moose::out &lt;&lt; entry.first &lt;&lt; &quot;\taction\t&quot; &lt;&lt; act-&gt;_name &lt;&lt; &quot;\t&quot; &lt;&lt; act-&gt;_classname &lt;&lt; &quot;\t&quot;
                   &lt;&lt; act-&gt;_file &lt;&lt; &quot;\n&quot;;
    }

    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;registry_hit&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::out &lt;&lt; &quot;### START REGISTRY DATA ###\n&quot;;

    hit::Section root(&quot;&quot;);
    auto sec = new hit::Section(&quot;registry&quot;);
    root.addChild(sec);
    auto objsec = new hit::Section(&quot;objects&quot;);
    sec-&gt;addChild(objsec);

    auto &amp; objmap = Registry::allObjects();
    for (auto &amp; entry : objmap)
      for (auto &amp; obj : entry.second)
      {
        auto ent = new hit::Section(&quot;entry&quot;);
        objsec-&gt;addChild(ent);
        ent-&gt;addChild(new hit::Field(&quot;label&quot;, hit::Field::Kind::String, entry.first));
        ent-&gt;addChild(new hit::Field(&quot;type&quot;, hit::Field::Kind::String, &quot;object&quot;));
        ent-&gt;addChild(new hit::Field(&quot;name&quot;, hit::Field::Kind::String, obj-&gt;name()));
        ent-&gt;addChild(new hit::Field(&quot;class&quot;, hit::Field::Kind::String, obj-&gt;_classname));
        ent-&gt;addChild(new hit::Field(&quot;file&quot;, hit::Field::Kind::String, obj-&gt;_file));
      }

    auto actsec = new hit::Section(&quot;actions&quot;);
    sec-&gt;addChild(actsec);
    auto &amp; actmap = Registry::allActions();
    for (auto &amp; entry : actmap)
      for (auto &amp; act : entry.second)
      {
        auto ent = new hit::Section(&quot;entry&quot;);
        actsec-&gt;addChild(ent);
        ent-&gt;addChild(new hit::Field(&quot;label&quot;, hit::Field::Kind::String, entry.first));
        ent-&gt;addChild(new hit::Field(&quot;type&quot;, hit::Field::Kind::String, &quot;action&quot;));
        ent-&gt;addChild(new hit::Field(&quot;task&quot;, hit::Field::Kind::String, act-&gt;_name));
        ent-&gt;addChild(new hit::Field(&quot;class&quot;, hit::Field::Kind::String, act-&gt;_classname));
        ent-&gt;addChild(new hit::Field(&quot;file&quot;, hit::Field::Kind::String, act-&gt;_file));
      }

    Moose::out &lt;&lt; root.render();

    Moose::out &lt;&lt; &quot;\n### END REGISTRY DATA ###\n&quot;;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;definition&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::perf_log.disable_logging();
    JsonSyntaxTree tree(&quot;&quot;);
    _parser.buildJsonSyntaxTree(tree);
    SONDefinitionFormatter formatter;
    Moose::out &lt;&lt; &quot;%-START-SON-DEFINITION-%\n&quot;
               &lt;&lt; formatter.toString(tree.getRoot()) &lt;&lt; &quot;\n%-END-SON-DEFINITION-%\n&quot;;
    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;yaml&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::perf_log.disable_logging();

    _parser.initSyntaxFormatter(Parser::YAML, true);

    // Get command line argument following --yaml on command line
    std::string yaml_following_arg = getParam&lt;std::string&gt;(&quot;yaml&quot;);

    // If the argument following --yaml is non-existent or begins with
    // a dash, call buildFullTree() with an empty string, otherwise
    // pass the argument following --yaml.
    if (yaml_following_arg.empty() || (yaml_following_arg.find(&#x27;-&#x27;) == 0))
      _parser.buildFullTree(&quot;&quot;);
    else
      _parser.buildFullTree(yaml_following_arg);

    _ready_to_exit = true;
  }
  else if (isParamValid(&quot;json&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::perf_log.disable_logging();

    // Get command line argument following --json on command line
    std::string json_following_arg = getParam&lt;std::string&gt;(&quot;json&quot;);

    // The argument following --json is a parameter search string,
    // which can be empty.
    std::string search;
    if (!json_following_arg.empty() &amp;&amp; (json_following_arg.find(&#x27;-&#x27;) != 0))
      search = json_following_arg;

    JsonSyntaxTree tree(search);
    _parser.buildJsonSyntaxTree(tree);

    Moose::out &lt;&lt; &quot;**START JSON DATA**\n&quot; &lt;&lt; tree.getRoot().dump(2) &lt;&lt; &quot;\n**END JSON DATA**\n&quot;;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;syntax&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::perf_log.disable_logging();

    std::multimap&lt;std::string, Syntax::ActionInfo&gt; syntax = _syntax.getAssociatedActions();
    Moose::out &lt;&lt; &quot;**START SYNTAX DATA**\n&quot;;
    for (const auto &amp; it : syntax)
      Moose::out &lt;&lt; it.first &lt;&lt; &quot;\n&quot;;
    Moose::out &lt;&lt; &quot;**END SYNTAX DATA**\n&quot; &lt;&lt; std::endl;
    _ready_to_exit = true;
  }
  else if (getParam&lt;bool&gt;(&quot;apptype&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::perf_log.disable_logging();
    Moose::out &lt;&lt; &quot;MooseApp Type: &quot; &lt;&lt; type() &lt;&lt; std::endl;
    _ready_to_exit = true;
  }
  else if (!_input_filenames.empty() ||
           isParamValid(&quot;input_file&quot;)) // They already specified an input filename
  {
    if (_input_filenames.empty())
      _input_filenames = getParam&lt;std::vector&lt;std::string&gt;&gt;(&quot;input_file&quot;);

    // Reset output to the buffer what was cached before it was turned it off
    if (!Moose::out.rdbuf() &amp;&amp; _output_buffer_cache)
      Moose::out.rdbuf(_output_buffer_cache);

    if (isParamValid(&quot;recover&quot;))
    {
      // We need to set the flag manually here since the recover parameter is a string type (takes
      // an optional filename)
      _recover = true;

      // Get command line argument following --recover on command line
      std::string recover_following_arg = getParam&lt;std::string&gt;(&quot;recover&quot;);

      // If the argument following --recover is non-existent or begins with
      // a dash then we are going to eventually find the newest recovery file to use
      if (!(recover_following_arg.empty() || (recover_following_arg.find(&#x27;-&#x27;) == 0)))
        _restart_recover_base = recover_following_arg;
    }

    // Optionally get command line argument following --recoversuffix
    // on command line.  Currently this argument applies to both
    // recovery and restart files.
    if (isParamValid(&quot;recoversuffix&quot;))
    {
      _restart_recover_suffix = getParam&lt;std::string&gt;(&quot;recoversuffix&quot;);
    }

    // Pass list of input files and optional text string if provided to parser
    _parser.parse(_input_filenames, getParam&lt;std::string&gt;(&quot;_input_text&quot;));

    if (isParamValid(&quot;mesh_only&quot;))
    {
      _syntax.registerTaskName(&quot;mesh_only&quot;, true);
      _syntax.addDependency(&quot;mesh_only&quot;, &quot;setup_mesh_complete&quot;);
      _syntax.addDependency(&quot;determine_system_type&quot;, &quot;mesh_only&quot;);
      _action_warehouse.setFinalTask(&quot;mesh_only&quot;);
    }
    else if (isParamValid(&quot;split_mesh&quot;))
    {
      _split_mesh = true;
      _syntax.registerTaskName(&quot;split_mesh&quot;, true);
      _syntax.addDependency(&quot;split_mesh&quot;, &quot;setup_mesh_complete&quot;);
      _syntax.addDependency(&quot;determine_system_type&quot;, &quot;split_mesh&quot;);
      _action_warehouse.setFinalTask(&quot;split_mesh&quot;);
    }
    _action_warehouse.build();

    // Setup the AppFileBase for use by the Outputs or other systems that need output file info
    {
      // Extract the CommonOutputAction
      const auto common_actions = _action_warehouse.getActions&lt;CommonOutputAction&gt;();
      mooseAssert(common_actions.size() &lt;= 1, &quot;Should not be more than one CommonOutputAction&quot;);
      const Action * common = common_actions.empty() ? nullptr : *common_actions.begin();

      // If file_base is set in CommonOutputAction through parsing input, obtain the file_base
      if (common &amp;&amp; common-&gt;isParamValid(&quot;file_base&quot;))
      {
        _output_file_base = common-&gt;getParam&lt;std::string&gt;(&quot;file_base&quot;);
        _file_base_set_by_user = true;
      }
      else if (isUltimateMaster())
      {
        // if this app is a master, we use the first input file name as the default file base
        std::string base = getInputFileName();
        size_t pos = base.find_last_of(&#x27;.&#x27;);
        _output_file_base = base.substr(0, pos);
        // Note: we did not append &quot;_out&quot; in the file base here because we do not want to
        //       have it in between the input file name and the object name for Output/*
        //       syntax.
      }
      // default file base for multiapps is set by MultiApp
    }
  }

#ifdef WASP_ENABLED
  else if (isParamValid(&quot;language_server&quot;))
  {
    _perf_graph.disableLivePrint();

    Moose::perf_log.disable_logging();

    // Reset output to the buffer what was cached before it was turned it off
    if (!Moose::out.rdbuf() &amp;&amp; _output_buffer_cache)
      Moose::out.rdbuf(_output_buffer_cache);

    // Start a language server that communicates using an iostream connection
    MooseServer moose_server(*this);

    moose_server.run();

    _ready_to_exit = true;
  }
#endif

  else /* The catch-all case for bad options or missing options, etc. */
  {
    Moose::perf_log.disable_logging();

    if (_check_input)
      mooseError(&quot;You specified --check-input, but did not provide an input file. Add -i &quot;
                 &quot;&lt;inputfile&gt; to your command line.&quot;);

    _command_line-&gt;printUsage();
    _ready_to_exit = true;
  }

  Moose::out &lt;&lt; std::flush;
}

void
MooseApp::setInputFileName(const std::string &amp; input_filename)
{
  // for now we only permit single input to be set for multiapps
  _input_filenames = {input_filename};
}

std::string
MooseApp::getOutputFileBase(bool for_non_moose_build_output) const
{
  if (_file_base_set_by_user || for_non_moose_build_output || _multiapp_level)
    return _output_file_base;
  else
    return _output_file_base + &quot;_out&quot;;
}

void
MooseApp::setOutputFileBase(const std::string &amp; output_file_base)
{
  _output_file_base = output_file_base;

  // Reset the file base in the outputs
  _output_warehouse.resetFileBase();

  // Reset the file base in multiapps (if they have been constructed yet)
  if (getExecutioner())
    for (auto &amp; multi_app : feProblem().getMultiAppWarehouse().getObjects())
      multi_app-&gt;setAppOutputFileBase();

  _file_base_set_by_user = true;
}

void
MooseApp::runInputFile()
{
  TIME_SECTION(&quot;runInputFile&quot;, 3);

  // If ready to exit has been set, then just return
  if (_ready_to_exit)
    return;

  _action_warehouse.executeAllActions();

  if (isParamValid(&quot;mesh_only&quot;) || isParamValid(&quot;split_mesh&quot;))
    _ready_to_exit = true;
  else if (getParam&lt;bool&gt;(&quot;list_constructed_objects&quot;))
  {
    // TODO: ask multiapps for their constructed objects
    _ready_to_exit = true;
    std::vector&lt;std::string&gt; obj_list = _factory.getConstructedObjects();
    Moose::out &lt;&lt; &quot;**START OBJECT DATA**\n&quot;;
    for (const auto &amp; name : obj_list)
      Moose::out &lt;&lt; name &lt;&lt; &quot;\n&quot;;
    Moose::out &lt;&lt; &quot;**END OBJECT DATA**\n&quot; &lt;&lt; std::endl;
  }
}

void
MooseApp::errorCheck()
{
  bool warn = _enable_unused_check == WARN_UNUSED;
  bool err = _enable_unused_check == ERROR_UNUSED;

  _parser.errorCheck(*_comm, warn, err);

  auto apps = feProblem().getMultiAppWarehouse().getObjects();
  for (auto app : apps)
    for (unsigned int i = 0; i &lt; app-&gt;numLocalApps(); i++)
      app-&gt;localApp(i)-&gt;errorCheck();
}

void
MooseApp::executeExecutioner()
{
  TIME_SECTION(&quot;executeExecutioner&quot;, 3);

  // If ready to exit has been set, then just return
  if (_ready_to_exit)
    return;

  // run the simulation
  if (_use_executor &amp;&amp; _executor)
  {
    Moose::PetscSupport::petscSetupOutput(_command_line.get());

    _executor-&gt;init();
    errorCheck();
    auto result = _executor-&gt;exec();
    if (!result.convergedAll())
      mooseError(result.str());
  }
  else if (_executioner)
  {
    Moose::PetscSupport::petscSetupOutput(_command_line.get());
    _executioner-&gt;init();
    errorCheck();
    _executioner-&gt;execute();
  }
  else
    mooseError(&quot;No executioner was specified (go fix your input file)&quot;);
}

bool
MooseApp::isRecovering() const
{
  return _recover;
}

bool
MooseApp::isRestarting() const
{
  return _restart;
}

bool
MooseApp::isSplitMesh() const
{
  return _split_mesh;
}

bool
MooseApp::hasRestartRecoverFileBase() const
{
  return !_restart_recover_base.empty();
}

bool
MooseApp::hasRecoverFileBase() const
{
  mooseDeprecated(&quot;MooseApp::hasRecoverFileBase is deprecated, use &quot;
                  &quot;MooseApp::hasRestartRecoverFileBase() instead.&quot;);
  return !_restart_recover_base.empty();
}

void
MooseApp::registerRestartableNameWithFilter(const std::string &amp; name,
                                            Moose::RESTARTABLE_FILTER filter)
{
  using Moose::RESTARTABLE_FILTER;
  switch (filter)
  {
    case RESTARTABLE_FILTER::RECOVERABLE:
      _recoverable_data_names.insert(name);
      break;
    default:
      mooseError(&quot;Unknown filter&quot;);
  }
}

std::shared_ptr&lt;Backup&gt;
MooseApp::backup()
{
  TIME_SECTION(&quot;backup&quot;, 2, &quot;Backing Up Application&quot;);

  mooseAssert(_executioner, &quot;Executioner is nullptr&quot;);
  FEProblemBase &amp; fe_problem = feProblem();

  RestartableDataIO rdio(fe_problem);
  return rdio.createBackup();
}

void
MooseApp::restore(std::shared_ptr&lt;Backup&gt; backup, bool for_restart)
{
  TIME_SECTION(&quot;restore&quot;, 2, &quot;Restoring Application&quot;);

  mooseAssert(_executioner, &quot;Executioner is nullptr&quot;);
  FEProblemBase &amp; fe_problem = feProblem();

  RestartableDataIO rdio(fe_problem);
  rdio.restoreBackup(backup, for_restart);
}

void
MooseApp::setCheckUnusedFlag(bool warn_is_error)
{
  _enable_unused_check = warn_is_error ? ERROR_UNUSED : WARN_UNUSED;
}

void
MooseApp::disableCheckUnusedFlag()
{
  _enable_unused_check = OFF;
}

FEProblemBase &amp;
MooseApp::feProblem() const
{
  return _executor.get() ? _executor-&gt;feProblem() : _executioner-&gt;feProblem();
}

void
MooseApp::addExecutor(const std::string &amp; type,
                      const std::string &amp; name,
                      const InputParameters &amp; params)
{
  std::shared_ptr&lt;Executor&gt; executor = _factory.create&lt;Executor&gt;(type, name, params);

  if (_executors.count(executor-&gt;name()) &gt; 0)
    mooseError(&quot;an executor with name &#x27;&quot;, executor-&gt;name(), &quot;&#x27; already exists&quot;);
  _executors[executor-&gt;name()] = executor;
}

void
MooseApp::addExecutorParams(const std::string &amp; type,
                            const std::string &amp; name,
                            const InputParameters &amp; params)
{
  _executor_params[name] = std::make_pair(type, std::make_unique&lt;InputParameters&gt;(params));
}

void
MooseApp::recursivelyCreateExecutors(const std::string &amp; current_executor_name,
                                     std::list&lt;std::string&gt; &amp; possible_roots,
                                     std::list&lt;std::string&gt; &amp; current_branch)
{
  // Did we already make this one?
  if (_executors.find(current_executor_name) != _executors.end())
    return;

  // Is this one already on the current branch (i.e. there is a cycle)
  if (std::find(current_branch.begin(), current_branch.end(), current_executor_name) !=
      current_branch.end())
  {
    std::stringstream exec_names_string;

    auto branch_it = current_branch.begin();

    exec_names_string &lt;&lt; *branch_it++;

    for (; branch_it != current_branch.end(); ++branch_it)
      exec_names_string &lt;&lt; &quot;, &quot; &lt;&lt; *branch_it;

    exec_names_string &lt;&lt; &quot;, &quot; &lt;&lt; current_executor_name;

    mooseError(&quot;Executor cycle detected: &quot;, exec_names_string.str());
  }

  current_branch.push_back(current_executor_name);

  // Build the dependencies first
  const auto &amp; params = *_executor_params[current_executor_name].second;

  for (const auto &amp; param : params)
  {
    if (params.have_parameter&lt;ExecutorName&gt;(param.first))
    {
      const auto &amp; dependency_name = params.get&lt;ExecutorName&gt;(param.first);

      possible_roots.remove(dependency_name);

      if (!dependency_name.empty())
        recursivelyCreateExecutors(dependency_name, possible_roots, current_branch);
    }
  }

  // Add this Executor
  const auto &amp; type = _executor_params[current_executor_name].first;
  addExecutor(type, current_executor_name, params);

  current_branch.pop_back();
}

void
MooseApp::createExecutors()
{
  // Do we have any?
  if (_executor_params.empty())
    return;

  // Holds the names of Executors that may be the root executor
  std::list&lt;std::string&gt; possibly_root;

  // What is already built
  std::map&lt;std::string, bool&gt; already_built;

  // The Executors that are currently candidates for being roots
  std::list&lt;std::string&gt; possible_roots;

  // The current line of dependencies - used for finding cycles
  std::list&lt;std::string&gt; current_branch;

  // Build the NullExecutor
  {
    auto params = _factory.getValidParams(&quot;NullExecutor&quot;);
    _null_executor = _factory.create&lt;NullExecutor&gt;(&quot;NullExecutor&quot;, &quot;_null_executor&quot;, params);
  }

  for (const auto &amp; params_entry : _executor_params)
  {
    const auto &amp; name = params_entry.first;

    // Did we already make this one?
    if (_executors.find(name) != _executors.end())
      continue;

    possible_roots.emplace_back(name);

    recursivelyCreateExecutors(name, possible_roots, current_branch);
  }

  // If there is more than one possible root - error
  if (possible_roots.size() &gt; 1)
  {
    auto root_string_it = possible_roots.begin();

    std::stringstream roots_string;

    roots_string &lt;&lt; *root_string_it++;

    for (; root_string_it != possible_roots.end(); ++root_string_it)
      roots_string &lt;&lt; &quot;, &quot; &lt;&lt; *root_string_it;

    mooseError(&quot;Multiple Executor roots found: &quot;, roots_string.str());
  }

  // Set the root executor
  _executor = _executors[possible_roots.front()];
}

Executor &amp;
MooseApp::getExecutor(const std::string &amp; name, bool fail_if_not_found)
{
  auto it = _executors.find(name);

  if (it != _executors.end())
    return *it-&gt;second;

  if (fail_if_not_found)
    mooseError(&quot;Executor not found: &quot;, name);

  return *_null_executor;
}

Executioner *
MooseApp::getExecutioner() const
{
  return _executioner.get() ? _executioner.get() : _executor.get();
}

void
MooseApp::setErrorOverridden()
{
  _error_overridden = true;
}

void
MooseApp::run()
{
  TIME_SECTION(&quot;run&quot;, 3);
  if (isParamValid(&quot;show_docs&quot;) &amp;&amp; getParam&lt;bool&gt;(&quot;show_docs&quot;))
  {
    auto binname = appBinaryName();
    if (binname == &quot;&quot;)
      mooseError(&quot;could not locate installed tests to run (unresolved binary/app name)&quot;);
    auto docspath = MooseUtils::docsDir(binname);
    if (docspath == &quot;&quot;)
      mooseError(&quot;no installed documentation found&quot;);

    auto docmsgfile = MooseUtils::pathjoin(docspath, &quot;docmsg.txt&quot;);
    std::string docmsg = &quot;file://&quot; + MooseUtils::realpath(docspath) + &quot;/index.html&quot;;
    if (MooseUtils::pathExists(docmsgfile) &amp;&amp; MooseUtils::checkFileReadable(docmsgfile))
    {
      std::ifstream ifs(docmsgfile);
      std::string content((std::istreambuf_iterator&lt;char&gt;(ifs)),
                          (std::istreambuf_iterator&lt;char&gt;()));
      content.replace(content.find(&quot;$LOCAL_SITE_HOME&quot;), content.length(), docmsg);
      docmsg = content;
    }

    Moose::out &lt;&lt; docmsg &lt;&lt; &quot;\n&quot;;
    _ready_to_exit = true;
    return;
  }

  if (showInputs() || copyInputs() || runInputs())
  {
    _ready_to_exit = true;
    return;
  }

  try
  {
    TIME_SECTION(&quot;setup&quot;, 2, &quot;Setting Up&quot;);
    setupOptions();
    runInputFile();
  }
  catch (std::exception &amp; err)
  {
    mooseError(err.what());
  }

  if (!_check_input)
  {
    TIME_SECTION(&quot;execute&quot;, 2, &quot;Executing&quot;);
    executeExecutioner();
  }
  else
  {
    errorCheck();
    // Output to stderr, so it is easier for peacock to get the result
    Moose::err &lt;&lt; &quot;Syntax OK&quot; &lt;&lt; std::endl;
  }
}

bool
MooseApp::showInputs() const
{
  if (isParamValid(&quot;show_inputs&quot;))
  {
    auto copy_syntax = _pars.getSyntax(&quot;copy_inputs&quot;);
    std::vector&lt;std::string&gt; dirs;
    const auto installable_inputs = getInstallableInputs();

    if (installable_inputs == &quot;&quot;)
    {
      Moose::out
          &lt;&lt; &quot;Show inputs has not been overriden in this application.\nContact the developers of &quot;
             &quot;this appication and request that they override \&quot;MooseApp::getInstallableInputs\&quot;.\n&quot;;
    }
    else
    {
      mooseAssert(!copy_syntax.empty(), &quot;copy_inputs sytnax should not be empty&quot;);

      MooseUtils::tokenize(installable_inputs, dirs, 1, &quot; &quot;);
      Moose::out &lt;&lt; &quot;The following directories are installable into a user-writeable directory:\n\n&quot;
                 &lt;&lt; installable_inputs &lt;&lt; &#x27;\n&#x27;
                 &lt;&lt; &quot;\nTo install one or more directories of inputs, execute the binary with the \&quot;&quot;
                 &lt;&lt; copy_syntax[0] &lt;&lt; &quot;\&quot; flag. e.g.:\n$ &quot; &lt;&lt; _command_line-&gt;getExecutableName()
                 &lt;&lt; &#x27; &#x27; &lt;&lt; copy_syntax[0] &lt;&lt; &#x27; &#x27; &lt;&lt; dirs[0] &lt;&lt; &#x27;\n&#x27;;
    }
    return true;
  }
  return false;
}

std::string
MooseApp::getInstallableInputs() const
{
  return &quot;tests&quot;;
}

bool
MooseApp::copyInputs() const
{
  if (isParamValid(&quot;copy_inputs&quot;))
  {
    // Get command line argument following --copy-inputs on command line
    auto dir_to_copy = getParam&lt;std::string&gt;(&quot;copy_inputs&quot;);

    if (dir_to_copy.empty())
      mooseError(&quot;Error retrieving directory to copy&quot;);
    if (dir_to_copy.back() != &#x27;/&#x27;)
      dir_to_copy += &#x27;/&#x27;;

    auto binname = appBinaryName();
    if (binname == &quot;&quot;)
      mooseError(&quot;could not locate installed tests to run (unresolved binary/app name)&quot;);

    auto src_dir =
        MooseUtils::installedInputsDir(binname,
                                       dir_to_copy,
                                       &quot;Rerun binary with &quot; + _pars.getSyntax(&quot;show_inputs&quot;)[0] +
                                           &quot; to get a list of installable directories.&quot;);
    auto dst_dir = binname + &quot;/&quot; + dir_to_copy;
    auto cmdname = Moose::getExecutableName();
    if (cmdname.find_first_of(&quot;/&quot;) != std::string::npos)
      cmdname = cmdname.substr(cmdname.find_first_of(&quot;/&quot;) + 1, std::string::npos);

    if (MooseUtils::pathExists(dst_dir))
      mooseError(
          &quot;The directory \&quot;./&quot;,
          dst_dir,
          &quot;\&quot; already exists.\nTo update/recopy the contents of this directory, rename (\&quot;mv &quot;,
          dst_dir,
          &quot; new_dir_name\&quot;) or remove (\&quot;rm -r &quot;,
          dst_dir,
          &quot;\&quot;) the existing directory.\nThen re-run \&quot;&quot;,
          cmdname,
          &quot; --copy-inputs &quot;,
          dir_to_copy,
          &quot;\&quot;.&quot;);

    std::string cmd = &quot;mkdir -p &quot; + dst_dir + &quot;; rsync -av &quot; + src_dir + &quot; &quot; + dst_dir;

    TIME_SECTION(&quot;copy_inputs&quot;, 2, &quot;Copying Inputs&quot;);

    // Only perform the copy on the root processor
    int return_value = 0;
    if (processor_id() == 0)
      return_value = system(cmd.c_str());
    _communicator.broadcast(return_value);

    if (WIFEXITED(return_value) &amp;&amp; WEXITSTATUS(return_value) != 0)
      mooseError(&quot;Failed to copy the requested directory.&quot;);
    Moose::out &lt;&lt; &quot;Directory successfully copied into ./&quot; &lt;&lt; dst_dir &lt;&lt; &#x27;\n&#x27;;
    return true;
  }
  return false;
}

bool
MooseApp::runInputs() const
{
  if (isParamValid(&quot;run&quot;))
  {
    // Here we are going to pass everything after --run on the cli to the TestHarness. That means
    // cannot validate these CLIs.
    auto it = _command_line-&gt;find(&quot;run&quot;);

    std::string test_args;
    if (it != _command_line-&gt;end())
    {
      // Preincrement here to skip over --run
      while (++it != _command_line-&gt;end())
        test_args += &quot; &quot; + *it;
    }

    auto cmd = MooseUtils::runTestsExecutable() + test_args;
    auto working_dir = MooseUtils::getCurrentWorkingDir();

    if (MooseUtils::findTestRoot() == &quot;&quot;)
    {
      auto bin_name = appBinaryName();
      if (bin_name == &quot;&quot;)
        mooseError(&quot;Could not locate binary name relative to installed location&quot;);

      auto cmd_name = Moose::getExecutableName();
      mooseError(
          &quot;Could not locate installed tests from the current working directory:&quot;,
          working_dir,
          &quot;.\nMake sure you are executing this command from within a writable installed inputs &quot;,
          &quot;directory.\nRun \&quot;&quot;,
          cmd_name,
          &quot; --copy-inputs &lt;dir&gt;\&quot; to copy the contents of &lt;dir&gt; to a \&quot;./&quot;,
          bin_name,
          &quot;_&lt;dir&gt;\&quot; directory.\nChange into that directory and try \&quot;&quot;,
          cmd_name,
          &quot; --run &lt;dir&gt;\&quot; again.&quot;);
    }

    // Only launch the tests on the root processor
    Moose::out &lt;&lt; &quot;Working Directory: &quot; &lt;&lt; working_dir &lt;&lt; &quot;\nRunning Command: &quot; &lt;&lt; cmd &lt;&lt; std::endl;
    int return_value = 0;
    if (processor_id() == 0)
      return_value = system(cmd.c_str());
    _communicator.broadcast(return_value);

    if (WIFEXITED(return_value) &amp;&amp; WEXITSTATUS(return_value) != 0)
      mooseError(&quot;Run failed&quot;);
    return true;
  }

  return false;
}

void
MooseApp::setOutputPosition(const Point &amp; p)
{
  _output_position_set = true;
  _output_position = p;
  _output_warehouse.meshChanged();

  if (_executioner.get())
    _executioner-&gt;parentOutputPositionChanged();
}

std::list&lt;std::string&gt;
MooseApp::getCheckpointDirectories() const
{
  // Storage for the directory names
  std::list&lt;std::string&gt; checkpoint_dirs;

  // Add the directories added with Outputs/checkpoint=true input syntax
  checkpoint_dirs.push_back(getOutputFileBase() + &quot;_cp&quot;);
  // Add the directories added with the autosave checkpoint input syntax
  checkpoint_dirs.push_back(&quot;autosave_cp&quot;);

  // Add the directories from any existing checkpoint output objects
  const auto &amp; actions = _action_warehouse.getActionListByName(&quot;add_output&quot;);
  for (const auto &amp; action : actions)
  {
    // Get the parameters from the MooseObjectAction
    MooseObjectAction * moose_object_action = dynamic_cast&lt;MooseObjectAction *&gt;(action);
    if (!moose_object_action)
      continue;

    const InputParameters &amp; params = moose_object_action-&gt;getObjectParams();
    if (moose_object_action-&gt;getParam&lt;std::string&gt;(&quot;type&quot;) == &quot;Checkpoint&quot;)
      checkpoint_dirs.push_back(params.get&lt;std::string&gt;(&quot;file_base&quot;) + &quot;_cp&quot;);
  }
  return checkpoint_dirs;
}

std::list&lt;std::string&gt;
MooseApp::getCheckpointFiles() const
{
  auto checkpoint_dirs = getCheckpointDirectories();
  return MooseUtils::getFilesInDirs(checkpoint_dirs);
}

void
MooseApp::setStartTime(Real time)
{
  _start_time_set = true;
  _start_time = time;
}

std::string
MooseApp::getFileName(bool stripLeadingPath) const
{
  return _parser.getPrimaryFileName(stripLeadingPath);
}

OutputWarehouse &amp;
MooseApp::getOutputWarehouse()
{
  return _output_warehouse;
}

std::string
MooseApp::appNameToLibName(const std::string &amp; app_name) const
{
  std::string library_name(app_name);

  // Strip off the App part (should always be the last 3 letters of the name)
  size_t pos = library_name.find(&quot;App&quot;);
  if (pos != library_name.length() - 3)
    mooseError(&quot;Invalid application name: &quot;, library_name);
  library_name.erase(pos);

  // Now get rid of the camel case, prepend lib, and append the method and suffix
  return std::string(&quot;lib&quot;) + MooseUtils::camelCaseToUnderscore(library_name) + &#x27;-&#x27; +
         QUOTE(METHOD) + &quot;.la&quot;;
}

std::string
MooseApp::libNameToAppName(const std::string &amp; library_name) const
{
  std::string app_name(library_name);

  // Strip off the leading &quot;lib&quot; and trailing &quot;.la&quot;
  if (pcrecpp::RE(&quot;lib(.+?)(?:-\\w+)?\\.la&quot;).Replace(&quot;\\1&quot;, &amp;app_name) == 0)
    mooseError(&quot;Invalid library name: &quot;, app_name);

  return MooseUtils::underscoreToCamelCase(app_name, true);
}

RestartableDataValue &amp;
MooseApp::registerRestartableData(const std::string &amp; name,
                                  std::unique_ptr&lt;RestartableDataValue&gt; data,
                                  THREAD_ID tid,
                                  bool read_only,
                                  const RestartableDataMapName &amp; metaname)
{
  if (!metaname.empty() &amp;&amp; tid != 0)
    mooseError(
        &quot;The meta data storage for &#x27;&quot;, metaname, &quot;&#x27; is not threaded, so the tid must be zero.&quot;);

  mooseAssert(metaname.empty() ||
                  _restartable_meta_data.find(metaname) != _restartable_meta_data.end(),
              &quot;The desired meta data name does not exist: &quot; + metaname);

  // Select the data store for saving this piece of restartable data (mesh or everything else)
  auto &amp; data_ref =
      metaname.empty() ? _restartable_data[tid] : _restartable_meta_data[metaname].first;

  auto data_it = data_ref.find(name);
  if (data_it == data_ref.end())
  {
    auto insert_pair = data_ref.emplace(name, std::move(data));
    mooseAssert(insert_pair.second, &quot;Insert didn&#x27;t happen&quot;);
    data_it = insert_pair.first;
  }

  auto &amp; value = *data_it-&gt;second;
  if (!read_only)
    value.setDeclared();

  return value;
}

bool
MooseApp::hasRestartableMetaData(const std::string &amp; name,
                                 const RestartableDataMapName &amp; metaname) const
{
  auto it = _restartable_meta_data.find(metaname);
  if (it == _restartable_meta_data.end())
    return false;
  else
  {
    auto &amp; m = it-&gt;second.first;
    return m.find(name) != m.end();
  }
}

RestartableDataValue &amp;
MooseApp::getRestartableMetaData(const std::string &amp; name,
                                 const RestartableDataMapName &amp; metaname,
                                 THREAD_ID tid) const
{
  if (tid != 0)
    mooseError(
        &quot;The meta data storage for &#x27;&quot;, metaname, &quot;&#x27; is not threaded, so the tid must be zero.&quot;);

  // Get metadata reference from RestartableDataMap and return a (non-const) reference to its value
  auto &amp; restartable_data_map = getRestartableDataMap(metaname);
  auto iter = restartable_data_map.find(name);
  if (iter == restartable_data_map.end())
    mooseError(&quot;Unable to find RestartableDataValue object with name &quot; + name +
               &quot; in RestartableDataMap&quot;);

  return *iter-&gt;second;
}

void
MooseApp::dynamicAppRegistration(const std::string &amp; app_name,
                                 std::string library_path,
                                 const std::string &amp; library_name,
                                 bool lib_load_deps)
{
#ifdef LIBMESH_HAVE_DLOPEN
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = APPLICATION;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__registerApps&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;

  const auto effective_library_name =
      library_name.empty() ? appNameToLibName(app_name) : library_name;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) = effective_library_name;
  params.set&lt;bool&gt;(&quot;library_load_dependencies&quot;) = lib_load_deps;

  const auto paths = getLibrarySearchPaths(library_path);
  std::ostringstream oss;

  auto successfully_loaded = false;
  if (paths.empty())
    oss &lt;&lt; &#x27;&quot;&#x27; &lt;&lt; app_name &lt;&lt; &quot;\&quot; is not a registered application name.\n&quot;
        &lt;&lt; &quot;No search paths were set. We made no attempts to locate the corresponding library &quot;
           &quot;file.\n&quot;;
  else
  {
    dynamicRegistration(params);

    // At this point the application should be registered so check it
    if (!AppFactory::instance().isRegistered(app_name))
    {
      oss &lt;&lt; &#x27;&quot;&#x27; &lt;&lt; app_name &lt;&lt; &quot;\&quot; is not a registered application name.\n&quot;
          &lt;&lt; &quot;Unable to locate library archive for \&quot;&quot; &lt;&lt; app_name
          &lt;&lt; &quot;\&quot;.\nWe attempted to locate the library archive \&quot;&quot; &lt;&lt; effective_library_name
          &lt;&lt; &quot;\&quot; in the following paths:\n\t&quot;;
      std::copy(paths.begin(), paths.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;\n\t&quot;));
    }
    else
      successfully_loaded = true;
  }

  if (!successfully_loaded)
  {
    oss &lt;&lt; &quot;\nMake sure you have compiled the library and either set the \&quot;library_path\&quot; &quot;
           &quot;variable in your input file or exported \&quot;MOOSE_LIBRARY_PATH\&quot;.\n&quot;;

    mooseError(oss.str());
  }

#else
  mooseError(&quot;Dynamic Loading is either not supported or was not detected by libMesh configure.&quot;);
#endif
}

void
MooseApp::dynamicAllRegistration(const std::string &amp; app_name,
                                 Factory * factory,
                                 ActionFactory * action_factory,
                                 Syntax * syntax,
                                 std::string library_path,
                                 const std::string &amp; library_name)
{
#ifdef LIBMESH_HAVE_DLOPEN
  Parameters params;
  params.set&lt;std::string&gt;(&quot;app_name&quot;) = app_name;
  params.set&lt;RegistrationType&gt;(&quot;reg_type&quot;) = REGALL;
  params.set&lt;std::string&gt;(&quot;registration_method&quot;) = app_name + &quot;__registerAll&quot;;
  params.set&lt;std::string&gt;(&quot;library_path&quot;) = library_path;
  params.set&lt;std::string&gt;(&quot;library_name&quot;) =
      library_name.empty() ? appNameToLibName(app_name) : library_name;

  params.set&lt;Factory *&gt;(&quot;factory&quot;) = factory;
  params.set&lt;Syntax *&gt;(&quot;syntax&quot;) = syntax;
  params.set&lt;ActionFactory *&gt;(&quot;action_factory&quot;) = action_factory;
  params.set&lt;bool&gt;(&quot;library_load_dependencies&quot;) = false;

  dynamicRegistration(params);
#else
  mooseError(&quot;Dynamic Loading is either not supported or was not detected by libMesh configure.&quot;);
#endif
}

void
MooseApp::dynamicRegistration(const Parameters &amp; params)
{
  const auto paths = getLibrarySearchPaths(params.get&lt;std::string&gt;(&quot;library_path&quot;));
  const auto library_name = params.get&lt;std::string&gt;(&quot;library_name&quot;);

  // Attempt to dynamically load the library
  for (const auto &amp; path : paths)
    if (MooseUtils::checkFileReadable(path + &#x27;/&#x27; + library_name, false, false))
      loadLibraryAndDependencies(
          path + &#x27;/&#x27; + library_name, params, params.get&lt;bool&gt;(&quot;library_load_dependencies&quot;));
}

void
MooseApp::loadLibraryAndDependencies(const std::string &amp; library_filename,
                                     const Parameters &amp; params,
                                     const bool load_dependencies)
{
  std::string line;
  std::string dl_lib_filename;

  // This RE looks for absolute path libtool filenames (i.e. begins with a slash and ends with a
  // .la)
  pcrecpp::RE re_deps(&quot;(/\\S*\\.la)&quot;);

  std::ifstream la_handle(library_filename.c_str());
  if (la_handle.is_open())
  {
    while (std::getline(la_handle, line))
    {
      // Look for the system dependent dynamic library filename to open
      if (line.find(&quot;dlname=&quot;) != std::string::npos)
        // Magic numbers are computed from length of this string &quot;dlname=&#x27; and line minus that
        // string plus quotes&quot;
        dl_lib_filename = line.substr(8, line.size() - 9);

      if (line.find(&quot;dependency_libs=&quot;) != std::string::npos)
      {
        if (load_dependencies)
        {
          pcrecpp::StringPiece input(line);
          pcrecpp::StringPiece depend_library;
          while (re_deps.FindAndConsume(&amp;input, &amp;depend_library))
            // Recurse here to load dependent libraries in depth-first order
            loadLibraryAndDependencies(depend_library.as_string(), params, load_dependencies);
        }

        // There&#x27;s only one line in the .la file containing the dependency libs so break after
        // finding it
        break;
      }
    }
    la_handle.close();
  }

  // This should only occur if we have static linkage.
  if (dl_lib_filename.empty())
    return;

  const auto &amp; [dir, file_name] = MooseUtils::splitFileName(library_filename);

  // Time to load the library, First see if we&#x27;ve already loaded this particular dynamic library
  //     1) make sure we haven&#x27;t already loaded this library
  // AND 2) make sure we have a library name (we won&#x27;t for static linkage)
  // Note: Here was are going to assume uniqueness based on the filename alone. This has significant
  // implications for applications that have &quot;diamond&quot; inheritance of libraries (usually
  // modules). We will only load one of those libraries, versions be damned.
  auto dyn_lib_it = _lib_handles.find(file_name);
  if (dyn_lib_it == _lib_handles.end())
  {
    // Assemble the actual filename using the base path of the *.la file and the dl_lib_filename
    const auto dl_lib_full_path = dir + &#x27;/&#x27; + dl_lib_filename;

    MooseUtils::checkFileReadable(dl_lib_full_path, false, /*throw_on_unreadable=*/true);

#ifdef LIBMESH_HAVE_DLOPEN
    void * const lib_handle = dlopen(dl_lib_full_path.c_str(), RTLD_LAZY);
#else
    void * const lib_handle = nullptr;
#endif

    if (!lib_handle)
      mooseError(&quot;The library file \&quot;&quot;,
                 dl_lib_full_path,
                 &quot;\&quot; exists and has proper permissions, but cannot by dynamically loaded.\nThis &quot;
                 &quot;generally means that the loader was unable to load one or more of the &quot;
                 &quot;dependencies listed in the supplied library (see otool or ldd).\n&quot;);

    DynamicLibraryInfo lib_info;
    lib_info.library_handle = lib_handle;
    lib_info.full_path = library_filename;

    auto insert_ret = _lib_handles.insert(std::make_pair(file_name, lib_info));
    mooseAssert(insert_ret.second == true, &quot;Error inserting into lib_handles map&quot;);

    dyn_lib_it = insert_ret.first;
  }

  // Library has been loaded, check to see if we&#x27;ve called the requested registration method
  const auto registration_method = params.get&lt;std::string&gt;(&quot;registration_method&quot;);
  auto &amp; entry_sym_from_curr_lib = dyn_lib_it-&gt;second.entry_symbols;

  if (entry_sym_from_curr_lib.find(registration_method) == entry_sym_from_curr_lib.end())
  {
    // get the pointer to the method in the library.  The dlsym()
    // function returns a null pointer if the symbol cannot be found,
    // we also explicitly set the pointer to NULL if dlsym is not
    // available.
#ifdef LIBMESH_HAVE_DLOPEN
    void * registration_handle =
        dlsym(dyn_lib_it-&gt;second.library_handle, registration_method.c_str());
#else
    void * registration_handle = nullptr;
#endif

    if (registration_handle)
    {
      switch (params.get&lt;RegistrationType&gt;(&quot;reg_type&quot;))
      {
        case APPLICATION:
        {
          using register_app_t = void (*)();
          register_app_t * const reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_handle);
          (*reg_ptr)();
          break;
        }
        case REGALL:
        {
          using register_app_t = void (*)(Factory *, ActionFactory *, Syntax *);
          register_app_t * const reg_ptr = reinterpret_cast&lt;register_app_t *&gt;(&amp;registration_handle);
          (*reg_ptr)(params.get&lt;Factory *&gt;(&quot;factory&quot;),
                     params.get&lt;ActionFactory *&gt;(&quot;action_factory&quot;),
                     params.get&lt;Syntax *&gt;(&quot;syntax&quot;));
          break;
        }
        default:
          mooseError(&quot;Unhandled RegistrationType&quot;);
      }

      entry_sym_from_curr_lib.insert(registration_method);
    }
    else
    {

#ifdef DEBUG
      // We found a dynamic library that doesn&#x27;t have a dynamic
      // registration method in it. This shouldn&#x27;t be an error, so
      // we&#x27;ll just move on.
      if (!registration_handle)
        mooseWarning(&quot;Unable to find extern \&quot;C\&quot; method \&quot;&quot;,
                     registration_method,
                     &quot;\&quot; in library: &quot;,
                     dyn_lib_it-&gt;first,
                     &quot;.\n&quot;,
                     &quot;This doesn&#x27;t necessarily indicate an error condition unless you believe that &quot;
                     &quot;the method should exist in that library.\n&quot;,
                     dlerror());
#endif
    }
  }
}

std::set&lt;std::string&gt;
MooseApp::getLoadedLibraryPaths() const
{
  // Return the paths but not the open file handles
  std::set&lt;std::string&gt; paths;
  for (const auto &amp; it : _lib_handles)
    paths.insert(it.first);

  return paths;
}

std::set&lt;std::string&gt;
MooseApp::getLibrarySearchPaths(const std::string &amp; library_path) const
{
  std::set&lt;std::string&gt; paths;

  if (!library_path.empty())
  {
    std::vector&lt;std::string&gt; tmp_paths;
    MooseUtils::tokenize(library_path, tmp_paths, 1, &quot;:&quot;);

    paths.insert(tmp_paths.begin(), tmp_paths.end());
  }

  char * moose_lib_path_env = std::getenv(&quot;MOOSE_LIBRARY_PATH&quot;);
  if (moose_lib_path_env)
  {
    std::string moose_lib_path(moose_lib_path_env);
    std::vector&lt;std::string&gt; tmp_paths;
    MooseUtils::tokenize(moose_lib_path, tmp_paths, 1, &quot;:&quot;);

    paths.insert(tmp_paths.begin(), tmp_paths.end());
  }

  return paths;
}

InputParameterWarehouse &amp;
MooseApp::getInputParameterWarehouse()
{
  return *_input_parameter_warehouse;
}

std::string
MooseApp::header() const
{
  return std::string(&quot;&quot;);
}

void
MooseApp::setRestart(bool value)
{
  _restart = value;
}

void
MooseApp::setRecover(bool value)
{
  _recover = value;
}

void
MooseApp::setBackupObject(std::shared_ptr&lt;Backup&gt; backup)
{
  _cached_backup = backup;
}

void
MooseApp::restoreCachedBackup()
{
  if (!_cached_backup.get())
    mooseError(&quot;No cached Backup to restore!&quot;);

  TIME_SECTION(&quot;restoreCachedBackup&quot;, 2, &quot;Restoring Cached Backup&quot;);

  restore(_cached_backup, isRestarting());

  // Release our hold on this Backup
  _cached_backup.reset();
}

void
MooseApp::createMinimalApp()
{
  TIME_SECTION(&quot;createMinimalApp&quot;, 3, &quot;Creating Minimal App&quot;);

  // SetupMeshAction
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;SetupMeshAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;GeneratedMesh&quot;;

    // Create The Action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;SetupMeshAction&quot;, &quot;Mesh&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;MooseEnum&gt;(&quot;dim&quot;) = &quot;1&quot;;
    params.set&lt;unsigned int&gt;(&quot;nx&quot;) = 1;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Executioner
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CreateExecutionerAction&quot;);
    action_params.set&lt;std::string&gt;(&quot;type&quot;) = &quot;Transient&quot;;

    // Create the action
    std::shared_ptr&lt;MooseObjectAction&gt; action = std::static_pointer_cast&lt;MooseObjectAction&gt;(
        _action_factory.create(&quot;CreateExecutionerAction&quot;, &quot;Executioner&quot;, action_params));

    // Set the object parameters
    InputParameters &amp; params = action-&gt;getObjectParams();
    params.set&lt;unsigned int&gt;(&quot;num_steps&quot;) = 1;
    params.set&lt;Real&gt;(&quot;dt&quot;) = 1;

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Problem
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CreateProblemDefaultAction&quot;);
    action_params.set&lt;bool&gt;(&quot;_solve&quot;) = false;

    // Create the action
    std::shared_ptr&lt;Action&gt; action = std::static_pointer_cast&lt;Action&gt;(
        _action_factory.create(&quot;CreateProblemDefaultAction&quot;, &quot;Problem&quot;, action_params));

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  // Outputs
  {
    // Build the Action parameters
    InputParameters action_params = _action_factory.getValidParams(&quot;CommonOutputAction&quot;);
    action_params.set&lt;bool&gt;(&quot;console&quot;) = false;

    // Create action
    std::shared_ptr&lt;Action&gt; action =
        _action_factory.create(&quot;CommonOutputAction&quot;, &quot;Outputs&quot;, action_params);

    // Add Action to the warehouse
    _action_warehouse.addActionBlock(action);
  }

  _action_warehouse.build();
}

bool
MooseApp::hasRelationshipManager(const std::string &amp; name) const
{
  return std::find_if(_relationship_managers.begin(),
                      _relationship_managers.end(),
                      [&amp;name](const std::shared_ptr&lt;RelationshipManager&gt; &amp; rm)
                      { return rm-&gt;name() == name; }) != _relationship_managers.end();
}

namespace
{
void
donateForWhom(const RelationshipManager &amp; donor, RelationshipManager &amp; acceptor)
{
  auto &amp; existing_for_whom = acceptor.forWhom();

  // Take all the for_whoms from the donor, and give them to the acceptor
  for (auto &amp; fw : donor.forWhom())
  {
    if (std::find(existing_for_whom.begin(), existing_for_whom.end(), fw) ==
        existing_for_whom.end())
      acceptor.addForWhom(fw);
  }
}
}

bool
MooseApp::addRelationshipManager(std::shared_ptr&lt;RelationshipManager&gt; new_rm)
{
  // We prefer to always add geometric RMs. There is no hurt to add RMs for replicated mesh
  // since MeshBase::delete_remote_elements{} is a no-op (empty) for replicated mesh.
  // The motivation here is that MooseMesh::_use_distributed_mesh may not be properly set
  // at the time we are adding geometric relationship managers. We deleted the following
  // old logic to add all geometric RMs regardless of there is a distributed mesh or not.
  // Otherwise, all geometric RMs will be improperly ignored for a distributed mesh generator.

  // if (!_action_warehouse.mesh()-&gt;isDistributedMesh() &amp;&amp; !_split_mesh &amp;&amp;
  //    (relationship_manager-&gt;isType(Moose::RelationshipManagerType::GEOMETRIC) &amp;&amp;
  //     !(relationship_manager-&gt;isType(Moose::RelationshipManagerType::ALGEBRAIC) ||
  //       relationship_manager-&gt;isType(Moose::RelationshipManagerType::COUPLING))))
  //  return false;

  bool add = true;

  std::set&lt;std::shared_ptr&lt;RelationshipManager&gt;&gt; rms_to_erase;

  for (const auto &amp; existing_rm : _relationship_managers)
  {
    if (*existing_rm &gt;= *new_rm)
    {
      add = false;
      donateForWhom(*new_rm, *existing_rm);
      break;
    }
    // The new rm did not provide less or the same amount/type of ghosting as the existing rm, but
    // what about the other way around?
    else if (*new_rm &gt;= *existing_rm)
      rms_to_erase.emplace(existing_rm);
  }

  if (add)
  {
    _relationship_managers.emplace(new_rm);
    for (const auto &amp; rm_to_erase : rms_to_erase)
    {
      donateForWhom(*rm_to_erase, *new_rm);
      removeRelationshipManager(rm_to_erase);
    }
  }

  // Inform the caller whether the object was added or not
  return add;
}

bool
MooseApp::hasRMClone(const RelationshipManager &amp; template_rm, const MeshBase &amp; mesh) const
{
  auto it = _template_to_clones.find(&amp;template_rm);
  // C++ does short circuiting so we&#x27;re safe here
  return (it != _template_to_clones.end()) &amp;&amp; (it-&gt;second.find(&amp;mesh) != it-&gt;second.end());
}

RelationshipManager &amp;
MooseApp::getRMClone(const RelationshipManager &amp; template_rm, const MeshBase &amp; mesh) const
{
  auto outer_it = _template_to_clones.find(&amp;template_rm);
  if (outer_it == _template_to_clones.end())
    mooseError(&quot;The template rm does not exist in our _template_to_clones map&quot;);

  auto &amp; mesh_to_clone_map = outer_it-&gt;second;
  auto inner_it = mesh_to_clone_map.find(&amp;mesh);
  if (inner_it == mesh_to_clone_map.end())
    mooseError(&quot;We should have the mesh key in our mesh&quot;);

  return *inner_it-&gt;second;
}

void
MooseApp::removeRelationshipManager(std::shared_ptr&lt;RelationshipManager&gt; rm)
{
  auto * const mesh = _action_warehouse.mesh().get();
  if (!mesh)
    mooseError(&quot;The MooseMesh should exist&quot;);

  const MeshBase * const undisp_lm_mesh = mesh-&gt;getMeshPtr();
  RelationshipManager * undisp_clone = nullptr;
  if (undisp_lm_mesh &amp;&amp; hasRMClone(*rm, *undisp_lm_mesh))
  {
    undisp_clone = &amp;getRMClone(*rm, *undisp_lm_mesh);
    const_cast&lt;MeshBase *&gt;(undisp_lm_mesh)-&gt;remove_ghosting_functor(*undisp_clone);
  }

  auto &amp; displaced_mesh = _action_warehouse.displacedMesh();
  MeshBase * const disp_lm_mesh = displaced_mesh ? &amp;displaced_mesh-&gt;getMesh() : nullptr;
  RelationshipManager * disp_clone = nullptr;
  if (disp_lm_mesh &amp;&amp; hasRMClone(*rm, *disp_lm_mesh))
  {
    disp_clone = &amp;getRMClone(*rm, *disp_lm_mesh);
    disp_lm_mesh-&gt;remove_ghosting_functor(*disp_clone);
  }

  if (_executioner)
  {
    auto &amp; problem = feProblem();
    if (undisp_clone)
    {
      problem.removeAlgebraicGhostingFunctor(*undisp_clone);
      auto &amp; dof_map = problem.getNonlinearSystemBase().dofMap();
      dof_map.remove_coupling_functor(*undisp_clone);
    }

    auto * dp = problem.getDisplacedProblem().get();
    if (dp &amp;&amp; disp_clone)
      dp-&gt;removeAlgebraicGhostingFunctor(*disp_clone);
  }

  _factory.releaseSharedObjects(*rm);
  _relationship_managers.erase(rm);
}

RelationshipManager &amp;
MooseApp::createRMFromTemplateAndInit(const RelationshipManager &amp; template_rm,
                                      MeshBase &amp; mesh,
                                      const DofMap * const dof_map)
{
  auto &amp; mesh_to_clone = _template_to_clones[&amp;template_rm];
  auto it = mesh_to_clone.find(&amp;mesh);
  if (it != mesh_to_clone.end())
  {
    // We&#x27;ve already created a clone for this mesh
    auto &amp; clone_rm = *it-&gt;second;
    if (!clone_rm.dofMap() &amp;&amp; dof_map)
      // We didn&#x27;t have a DofMap before, but now we do, so we should re-init
      clone_rm.init(mesh, dof_map);
    else if (clone_rm.dofMap() &amp;&amp; dof_map &amp;&amp; (clone_rm.dofMap() != dof_map))
      mooseError(&quot;Attempting to create and initialize an existing clone with a different DofMap. &quot;
                 &quot;This should not happen.&quot;);

    return clone_rm;
  }

  // It&#x27;s possible that this method is going to get called for multiple different MeshBase
  // objects. If that happens, then we *cannot* risk having a MeshBase object with a ghosting
  // functor that is init&#x27;d with another MeshBase object. So the safe thing to do is to make a
  // different RM for every MeshBase object that gets called here. Then the
  // RelationshipManagers stored here in MooseApp are serving as a template only
  auto pr = mesh_to_clone.emplace(
      std::make_pair(&amp;const_cast&lt;const MeshBase &amp;&gt;(mesh),
                     dynamic_pointer_cast&lt;RelationshipManager&gt;(template_rm.clone())));
  mooseAssert(pr.second, &quot;An insertion should have happened&quot;);
  auto &amp; clone_rm = *pr.first-&gt;second;
  clone_rm.init(mesh, dof_map);
  return clone_rm;
}

void
MooseApp::attachRelationshipManagers(MeshBase &amp; mesh, MooseMesh &amp; moose_mesh)
{
  for (auto &amp; rm : _relationship_managers)
  {
    if (rm-&gt;isType(Moose::RelationshipManagerType::GEOMETRIC))
    {
      if (rm-&gt;attachGeometricEarly())
        mesh.add_ghosting_functor(createRMFromTemplateAndInit(*rm, mesh));
      else
      {
        // If we have a geometric ghosting functor that can&#x27;t be attached early, then we have to
        // prevent the mesh from deleting remote elements
        moose_mesh.allowRemoteElementRemoval(false);

        if (const MeshBase * const moose_mesh_base = moose_mesh.getMeshPtr())
        {
          if (moose_mesh_base != &amp;mesh)
            mooseError(&quot;The MooseMesh MeshBase and the MeshBase we&#x27;re trying to attach &quot;
                       &quot;relationship managers to are different&quot;);
        }
        else
          // The MeshBase isn&#x27;t attached to the MooseMesh yet, so have to tell it not to remove
          // remote elements independently
          mesh.allow_remote_element_removal(false);
      }
    }
  }
}

void
MooseApp::attachRelationshipManagers(Moose::RelationshipManagerType rm_type,
                                     bool attach_geometric_rm_final)
{
  for (auto &amp; rm : _relationship_managers)
  {
    if (!rm-&gt;isType(rm_type))
      continue;

    // RM is already attached (this also handles the geometric early case)
    if (_attached_relationship_managers[rm_type].count(rm.get()))
      continue;

    if (rm_type == Moose::RelationshipManagerType::GEOMETRIC)
    {
      // The problem is not built yet - so the ActionWarehouse currently owns the mesh
      MooseMesh * const mesh = _action_warehouse.mesh().get();

      // &quot;attach_geometric_rm_final = true&quot; inidicate that it is the last chance to attach
      // geometric RMs. Therefore, we need to attach them.
      if (!rm-&gt;attachGeometricEarly() &amp;&amp; !attach_geometric_rm_final)
      {
        // Will attach them later (during algebraic). But also, we need to tell the mesh that we
        // shouldn&#x27;t be deleting remote elements yet
        if (!mesh-&gt;getMeshPtr())
          mooseError(&quot;We should have attached a MeshBase object to the mesh by now&quot;);

        mesh-&gt;allowRemoteElementRemoval(false);
      }
      else
      {
        MeshBase &amp; undisp_mesh_base = mesh-&gt;getMesh();
        const DofMap * const undisp_nl_dof_map =
            _executioner ? &amp;feProblem().systemBaseNonlinear(0).dofMap() : nullptr;
        undisp_mesh_base.add_ghosting_functor(
            createRMFromTemplateAndInit(*rm, undisp_mesh_base, undisp_nl_dof_map));

        // In the final stage, if there is a displaced mesh, we need to
        // clone ghosting functors for displacedMesh
        if (attach_geometric_rm_final &amp;&amp; _action_warehouse.displacedMesh())
        {
          MeshBase &amp; disp_mesh_base = _action_warehouse.displacedMesh()-&gt;getMesh();
          const DofMap * disp_nl_dof_map = nullptr;
          if (_executioner &amp;&amp; feProblem().getDisplacedProblem())
            disp_nl_dof_map = &amp;feProblem().getDisplacedProblem()-&gt;systemBaseNonlinear(0).dofMap();
          disp_mesh_base.add_ghosting_functor(
              createRMFromTemplateAndInit(*rm, disp_mesh_base, disp_nl_dof_map));
        }
        else if (_action_warehouse.displacedMesh())
          mooseError(&quot;The displaced mesh should not yet exist at the time that we are attaching &quot;
                     &quot;early geometric relationship managers.&quot;);

        // Mark this RM as attached
        mooseAssert(!_attached_relationship_managers[rm_type].count(rm.get()), &quot;Already attached&quot;);
        _attached_relationship_managers[rm_type].insert(rm.get());
      }
    }
    else // rm_type is algebraic or coupling
    {
      if (!_executioner &amp;&amp; !_executor)
        mooseError(&quot;We must have an executioner by now or else we do not have to data to add &quot;
                   &quot;algebraic or coupling functors to in MooseApp::attachRelationshipManagers&quot;);

      // Now we&#x27;ve built the problem, so we can use it
      auto &amp; problem = feProblem();
      auto &amp; undisp_nl = problem.systemBaseNonlinear(0);
      auto &amp; undisp_nl_dof_map = undisp_nl.dofMap();
      auto &amp; undisp_mesh = problem.mesh().getMesh();

      if (rm-&gt;useDisplacedMesh() &amp;&amp; problem.getDisplacedProblem())
      {
        if (rm_type == Moose::RelationshipManagerType::COUPLING)
          // We actually need to add this to the FEProblemBase NonlinearSystemBase&#x27;s DofMap
          // because the DisplacedProblem &quot;nonlinear&quot; DisplacedSystem doesn&#x27;t have any matrices
          // for which to do coupling. It&#x27;s actually horrifying to me that we are adding a
          // coupling functor, that is going to determine its couplings based on a displaced
          // MeshBase object, to a System associated with the undisplaced MeshBase object (there
          // is only ever one EquationSystems object per MeshBase object and visa versa). So here
          // I&#x27;m left with the choice of whether to pass in a MeshBase object that is *not* the
          // MeshBase object that will actually determine the couplings or to pass in the MeshBase
          // object that is inconsistent with the System DofMap that we are adding the coupling
          // functor for! Let&#x27;s err on the side of *libMesh* consistency and pass properly paired
          // MeshBase-DofMap
          problem.addCouplingGhostingFunctor(
              createRMFromTemplateAndInit(*rm, undisp_mesh, &amp;undisp_nl_dof_map),
              /*to_mesh = */ false);

        else if (rm_type == Moose::RelationshipManagerType::ALGEBRAIC)
        {
          auto &amp; displaced_problem = *problem.getDisplacedProblem();
          MeshBase &amp; disp_mesh = displaced_problem.mesh().getMesh();
          const DofMap * const disp_nl_dof_map = &amp;displaced_problem.systemBaseNonlinear(0).dofMap();
          displaced_problem.addAlgebraicGhostingFunctor(
              createRMFromTemplateAndInit(*rm, disp_mesh, disp_nl_dof_map),
              /*to_mesh = */ false);
        }
      }
      else // undisplaced
      {
        if (rm_type == Moose::RelationshipManagerType::COUPLING)
          problem.addCouplingGhostingFunctor(
              createRMFromTemplateAndInit(*rm, undisp_mesh, &amp;undisp_nl_dof_map),
              /*to_mesh = */ false);

        else if (rm_type == Moose::RelationshipManagerType::ALGEBRAIC)
          problem.addAlgebraicGhostingFunctor(
              createRMFromTemplateAndInit(*rm, undisp_mesh, &amp;undisp_nl_dof_map),
              /*to_mesh = */ false);
      }

      // Mark this RM as attached
      mooseAssert(!_attached_relationship_managers[rm_type].count(rm.get()), &quot;Already attached&quot;);
      _attached_relationship_managers[rm_type].insert(rm.get());
    }
  }
}

std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;
MooseApp::getRelationshipManagerInfo() const
{
  std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; info_strings;
  info_strings.reserve(_relationship_managers.size());

  for (const auto &amp; rm : _relationship_managers)
  {
    std::stringstream oss;
    oss &lt;&lt; rm-&gt;getInfo();

    auto &amp; for_whom = rm-&gt;forWhom();

    if (!for_whom.empty())
    {
      oss &lt;&lt; &quot; for &quot;;

      std::copy(for_whom.begin(), for_whom.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;, &quot;));
    }

    info_strings.emplace_back(std::make_pair(Moose::stringify(rm-&gt;getType()), oss.str()));
  }

  // List the libMesh GhostingFunctors - Not that in libMesh all of the algebraic and coupling
  // Ghosting Functors are also attached to the mesh. This should catch them all.
  const auto &amp; mesh = _action_warehouse.getMesh();
  if (mesh)
  {
    // Let us use an ordered map to avoid stochastic console behaviors.
    // I believe we won&#x27;t have many RMs, and there is no performance issue.
    // Deterministic behaviors are good for setting up regression tests
    std::map&lt;std::string, unsigned int&gt; counts;

    for (auto &amp; gf : as_range(mesh-&gt;getMesh().ghosting_functors_begin(),
                              mesh-&gt;getMesh().ghosting_functors_end()))
    {
      const auto * gf_ptr = dynamic_cast&lt;const RelationshipManager *&gt;(gf);
      if (!gf_ptr)
        // Count how many occurences of the same Ghosting Functor types we are encountering
        counts[demangle(typeid(*gf).name())]++;
    }

    for (const auto &amp; pair : counts)
      info_strings.emplace_back(std::make_pair(
          &quot;Default&quot;, pair.first + (pair.second &gt; 1 ? &quot; x &quot; + std::to_string(pair.second) : &quot;&quot;)));
  }

  // List the libMesh GhostingFunctors - Not that in libMesh all of the algebraic and coupling
  // Ghosting Functors are also attached to the mesh. This should catch them all.
  const auto &amp; d_mesh = _action_warehouse.getDisplacedMesh();
  if (d_mesh)
  {
    // Let us use an ordered map to avoid stochastic console behaviors.
    // I believe we won&#x27;t have many RMs, and there is no performance issue.
    // Deterministic behaviors are good for setting up regression tests
    std::map&lt;std::string, unsigned int&gt; counts;

    for (auto &amp; gf : as_range(d_mesh-&gt;getMesh().ghosting_functors_begin(),
                              d_mesh-&gt;getMesh().ghosting_functors_end()))
    {
      const auto * gf_ptr = dynamic_cast&lt;const RelationshipManager *&gt;(gf);
      if (!gf_ptr)
        // Count how many occurences of the same Ghosting Functor types we are encountering
        counts[demangle(typeid(*gf).name())]++;
    }

    for (const auto &amp; pair : counts)
      info_strings.emplace_back(
          std::make_pair(&quot;Default&quot;,
                         pair.first + (pair.second &gt; 1 ? &quot; x &quot; + std::to_string(pair.second) : &quot;&quot;) +
                             &quot; for DisplacedMesh&quot;));
  }

  return info_strings;
}

void
MooseApp::checkMetaDataIntegrity() const
{
  for (auto map_iter = _restartable_meta_data.begin(); map_iter != _restartable_meta_data.end();
       ++map_iter)
  {
    const RestartableDataMapName &amp; name = map_iter-&gt;first;
    const RestartableDataMap &amp; meta_data = map_iter-&gt;second.first;

    std::vector&lt;std::string&gt; not_declared;

    for (const auto &amp; pair : meta_data)
      if (!pair.second-&gt;declared())
        not_declared.push_back(pair.first);

    if (!not_declared.empty())
    {
      std::ostringstream oss;
      std::copy(
          not_declared.begin(), not_declared.end(), infix_ostream_iterator&lt;std::string&gt;(oss, &quot;, &quot;));

      mooseError(&quot;The following &#x27;&quot;,
                 name,
                 &quot;&#x27; meta-data properties were retrieved but never declared: &quot;,
                 oss.str());
    }
  }
}

const RestartableDataMapName MooseApp::MESH_META_DATA = &quot;MeshMetaData&quot;;

const RestartableDataMap &amp;
MooseApp::getRestartableDataMap(const RestartableDataMapName &amp; name) const
{
  auto iter = _restartable_meta_data.find(name);
  if (iter == _restartable_meta_data.end())
    mooseError(&quot;Unable to find RestartableDataMap object for the supplied name &#x27;&quot;,
               name,
               &quot;&#x27;, did you call registerRestartableDataMapName in the application constructor?&quot;);
  return iter-&gt;second.first;
}

bool
MooseApp::hasRestartableDataMap(const RestartableDataMapName &amp; name) const
{
  return _restartable_meta_data.count(name);
}

void
MooseApp::registerRestartableDataMapName(const RestartableDataMapName &amp; name, std::string suffix)
{
  if (!suffix.empty())
    std::transform(suffix.begin(), suffix.end(), suffix.begin(), ::tolower);
  suffix.insert(0, &quot;_&quot;);
  _restartable_meta_data.emplace(
      std::make_pair(name, std::make_pair(RestartableDataMap(), suffix)));
}

const std::string &amp;
MooseApp::getRestartableDataMapName(const RestartableDataMapName &amp; name) const
{
  const auto it = _restartable_meta_data.find(name);
  if (it == _restartable_meta_data.end())
    mooseError(&quot;MooseApp::getRestartableDataMapName: The name &#x27;&quot;, name, &quot;&#x27; is not registered&quot;);
  return it-&gt;second.second;
}

PerfGraph &amp;
MooseApp::createRecoverablePerfGraph()
{
  registerRestartableNameWithFilter(&quot;perf_graph&quot;, Moose::RESTARTABLE_FILTER::RECOVERABLE);

  auto perf_graph =
      std::make_unique&lt;RestartableData&lt;PerfGraph&gt;&gt;(&quot;perf_graph&quot;,
                                                   this,
                                                   type() + &quot; (&quot; + name() + &#x27;)&#x27;,
                                                   *this,
                                                   getParam&lt;bool&gt;(&quot;perf_graph_live_all&quot;),
                                                   !getParam&lt;bool&gt;(&quot;disable_perf_graph_live&quot;));

  return dynamic_cast&lt;RestartableData&lt;PerfGraph&gt; &amp;&gt;(
             registerRestartableData(&quot;perf_graph&quot;, std::move(perf_graph), 0, false))
      .set();
}

SolutionInvalidity &amp;
MooseApp::createRecoverableSolutionInvalidity()
{
  registerRestartableNameWithFilter(&quot;solution_invalidity&quot;, Moose::RESTARTABLE_FILTER::RECOVERABLE);

  auto solution_invalidity =
      std::make_unique&lt;RestartableData&lt;SolutionInvalidity&gt;&gt;(&quot;solution_invalidity&quot;, nullptr, *this);

  return dynamic_cast&lt;RestartableData&lt;SolutionInvalidity&gt; &amp;&gt;(
             registerRestartableData(
                 &quot;solution_invalidity&quot;, std::move(solution_invalidity), 0, false))
      .set();
}

bool
MooseApp::constructingMeshGenerators() const
{
  return _action_warehouse.getCurrentTaskName() == &quot;create_added_mesh_generators&quot; ||
         _mesh_generator_system.appendingMeshGenerators();
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6acdeb82-0545-4bcf-8372-28d96128385e"><div class="modal-content"><h4>(moose/framework/src/outputs/Output.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Standard includes
#include &lt;cmath&gt;
#include &lt;limits&gt;

// MOOSE includes
#include &quot;Output.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Postprocessor.h&quot;
#include &quot;Restartable.h&quot;
#include &quot;FileMesh.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Console.h&quot;
#include &quot;Function.h&quot;
#include &quot;PiecewiseLinear.h&quot;
#include &quot;Times.h&quot;

#include &quot;libmesh/equation_systems.h&quot;

InputParameters
Output::validParams()
{
  // Get the parameters from the parent object
  InputParameters params = MooseObject::validParams();
  params += SetupInterface::validParams();

  // Displaced Mesh options
  params.addParam&lt;bool&gt;(
      &quot;use_displaced&quot;, false, &quot;Enable/disable the use of the displaced mesh for outputting&quot;);

  // Output intervals and timing
  params.addParam&lt;unsigned int&gt;(
      &quot;interval&quot;, 1, &quot;The interval at which time steps are output to the solution file&quot;);
  params.addParam&lt;Real&gt;(
      &quot;minimum_time_interval&quot;, 0.0, &quot;The minimum simulation time between output steps&quot;);
  params.addParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;,
                                     &quot;Times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;TimesName&gt;(
      &quot;sync_times_object&quot;,
      &quot;Times object providing the times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;bool&gt;(&quot;sync_only&quot;, false, &quot;Only export results at sync times&quot;);
  params.addParam&lt;Real&gt;(&quot;start_time&quot;, &quot;Time at which this output object begins to operate&quot;);
  params.addParam&lt;Real&gt;(&quot;end_time&quot;, &quot;Time at which this output object stop operating&quot;);
  params.addParam&lt;int&gt;(&quot;start_step&quot;, &quot;Time step at which this output object begins to operate&quot;);
  params.addParam&lt;int&gt;(&quot;end_step&quot;, &quot;Time step at which this output object stop operating&quot;);
  params.addParam&lt;Real&gt;(
      &quot;time_tolerance&quot;, 1e-14, &quot;Time tolerance utilized checking start and end times&quot;);
  params.addDeprecatedParam&lt;FunctionName&gt;(
      &quot;output_limiting_function&quot;,
      &quot;Piecewise base function that sets sync_times&quot;,
      &quot;Replaced by using the Times system with the sync_times_objects parameter&quot;);

  // Update the &#x27;execute_on&#x27; input parameter for output
  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());

  // Add ability to append to the &#x27;execute_on&#x27; list
  params.addParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;, exec_enum, exec_enum.getDocString());
  params.set&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;).clear();
  params.addParamNamesToGroup(&quot;execute_on additional_execute_on&quot;, &quot;Execution scheduling&quot;);

  // &#x27;Timing&#x27; group
  params.addParamNamesToGroup(
      &quot;time_tolerance interval sync_times sync_times_object sync_only start_time end_time &quot;
      &quot;start_step end_step minimum_time_interval&quot;,
      &quot;Timing and frequency of output&quot;);

  // Add a private parameter for indicating if it was created with short-cut syntax
  params.addPrivateParam&lt;bool&gt;(&quot;_built_by_moose&quot;, false);

  // Register this class as base class
  params.declareControllable(&quot;enable&quot;);
  params.registerBase(&quot;Output&quot;);

  return params;
}

ExecFlagEnum
Output::getDefaultExecFlagEnum()
{
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  return exec_enum;
}

Output::Output(const InputParameters &amp; parameters)
  : MooseObject(parameters),
    Restartable(this, &quot;Output&quot;),
    MeshChangedInterface(parameters),
    SetupInterface(this),
    FunctionInterface(this),
    PostprocessorInterface(this),
    VectorPostprocessorInterface(this),
    ReporterInterface(this),
    PerfGraphInterface(this),
    _problem_ptr(getParam&lt;FEProblemBase *&gt;(&quot;_fe_problem_base&quot;)),
    _transient(_problem_ptr-&gt;isTransient()),
    _use_displaced(getParam&lt;bool&gt;(&quot;use_displaced&quot;)),
    _es_ptr(nullptr),
    _mesh_ptr(nullptr),
    _execute_on(getParam&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;)),
    _current_execute_flag(EXEC_NONE),
    _time(_problem_ptr-&gt;time()),
    _time_old(_problem_ptr-&gt;timeOld()),
    _t_step(_problem_ptr-&gt;timeStep()),
    _dt(_problem_ptr-&gt;dt()),
    _dt_old(_problem_ptr-&gt;dtOld()),
    _num(0),
    _interval(getParam&lt;unsigned int&gt;(&quot;interval&quot;)),
    _minimum_time_interval(getParam&lt;Real&gt;(&quot;minimum_time_interval&quot;)),
    _sync_times(std::set&lt;Real&gt;(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).begin(),
                               getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).end())),
    _sync_times_object(isParamValid(&quot;sync_times_object&quot;)
                           ? static_cast&lt;Times *&gt;(&amp;_problem_ptr-&gt;getUserObject&lt;Times&gt;(
                                 getParam&lt;TimesName&gt;(&quot;sync_times_object&quot;)))
                           : nullptr),
    _start_time(isParamValid(&quot;start_time&quot;) ? getParam&lt;Real&gt;(&quot;start_time&quot;)
                                           : std::numeric_limits&lt;Real&gt;::lowest()),
    _end_time(isParamValid(&quot;end_time&quot;) ? getParam&lt;Real&gt;(&quot;end_time&quot;)
                                       : std::numeric_limits&lt;Real&gt;::max()),
    _start_step(isParamValid(&quot;start_step&quot;) ? getParam&lt;int&gt;(&quot;start_step&quot;)
                                           : std::numeric_limits&lt;int&gt;::lowest()),
    _end_step(isParamValid(&quot;end_step&quot;) ? getParam&lt;int&gt;(&quot;end_step&quot;)
                                       : std::numeric_limits&lt;int&gt;::max()),
    _t_tol(getParam&lt;Real&gt;(&quot;time_tolerance&quot;)),
    _sync_only(getParam&lt;bool&gt;(&quot;sync_only&quot;)),
    _allow_output(true),
    _is_advanced(false),
    _advanced_execute_on(_execute_on, parameters),
    _last_output_time(
        declareRestartableData&lt;Real&gt;(&quot;last_output_time&quot;, std::numeric_limits&lt;Real&gt;::lowest()))
{
  if (_use_displaced)
  {
    std::shared_ptr&lt;DisplacedProblem&gt; dp = _problem_ptr-&gt;getDisplacedProblem();
    if (dp != nullptr)
    {
      _es_ptr = &amp;dp-&gt;es();
      _mesh_ptr = &amp;dp-&gt;mesh();
    }
    else
    {
      mooseWarning(
          name(),
          &quot;: Parameter &#x27;use_displaced&#x27; ignored, there is no displaced problem in your simulation.&quot;);
      _es_ptr = &amp;_problem_ptr-&gt;es();
      _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
    }
  }
  else
  {
    _es_ptr = &amp;_problem_ptr-&gt;es();
    _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
  }

  // Apply the additional output flags
  if (isParamValid(&quot;additional_execute_on&quot;))
  {
    const ExecFlagEnum &amp; add = getParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;);
    for (auto &amp; me : add)
      _execute_on.push_back(me);
  }

  if (isParamValid(&quot;output_limiting_function&quot;))
  {
    const Function &amp; olf = getFunction(&quot;output_limiting_function&quot;);
    const PiecewiseBase * pwb_olf = dynamic_cast&lt;const PiecewiseBase *&gt;(&amp;olf);
    if (pwb_olf == nullptr)
      mooseError(&quot;Function muse have a piecewise base!&quot;);

    for (auto i = 0; i &lt; pwb_olf-&gt;functionSize(); i++)
      _sync_times.insert(pwb_olf-&gt;domain(i));
  }

  // Check that the sync times were retrieved as expected
  if (_sync_times_object &amp;&amp;
      (isParamValid(&quot;output_limiting_function&quot;) || isParamSetByUser(&quot;sync_times&quot;)))
    paramError(&quot;sync_times_object&quot;,
               &quot;Only one method of specifying sync times is supported at a time&quot;);
}

void
Output::solveSetup()
{
}

void
Output::outputStep(const ExecFlagType &amp; type)
{
  // Output is not allowed
  if (!_allow_output &amp;&amp; type != EXEC_FORCED)
    return;

  // If recovering disable output of initial condition, it was already output
  if (type == EXEC_INITIAL &amp;&amp; _app.isRecovering())
    return;

  // Return if the current output is not on the desired interval
  if (type != EXEC_FINAL &amp;&amp; !onInterval())
    return;

  // store current simulation time
  _last_output_time = _time;

  // set current type
  _current_execute_flag = type;

  // Call the output method
  if (shouldOutput())
  {
    TIME_SECTION(&quot;outputStep&quot;, 2, &quot;Outputting Step&quot;);
    output();
  }

  _current_execute_flag = EXEC_NONE;
}

bool
Output::shouldOutput()
{
  if (_execute_on.contains(_current_execute_flag) || _current_execute_flag == EXEC_FORCED)
    return true;
  return false;
}

bool
Output::onInterval()
{
  // The output flag to return
  bool output = false;

  // Return true if the current step on the current output interval and within the output time range
  // and within the output step range
  if (_time &gt;= _start_time &amp;&amp; _time &lt;= _end_time &amp;&amp; _t_step &gt;= _start_step &amp;&amp;
      _t_step &lt;= _end_step &amp;&amp; (_t_step % _interval) == 0)
    output = true;

  // Return false if &#x27;sync_only&#x27; is set to true
  if (_sync_only)
    output = false;

  // Update sync times if a sync time object is in use
  if (_sync_times_object)
    _sync_times = _sync_times_object-&gt;getUniqueTimes();

  // If sync times are not skipped, return true if the current time is a sync_time
  if (_sync_times.find(_time) != _sync_times.end())
    output = true;

  // check if enough time has passed between outputs
  if (_time &gt; _last_output_time &amp;&amp; _last_output_time + _minimum_time_interval &gt; _time + _t_tol)
    return false;

  // Return the output status
  return output;
}

Real
Output::time()
{
  if (_transient)
    return _time;
  else
    return _t_step;
}

Real
Output::timeOld()
{
  if (_transient)
    return _time_old;
  else
    return _t_step - 1;
}

Real
Output::dt()
{
  if (_transient)
    return _dt;
  else
    return 1;
}

Real
Output::dtOld()
{
  if (_transient)
    return _dt_old;
  else
    return 1;
}

int
Output::timeStep()
{
  return _t_step;
}

const MultiMooseEnum &amp;
Output::executeOn() const
{
  return _execute_on;
}

bool
Output::isAdvanced()
{
  return _is_advanced;
}

const OutputOnWarehouse &amp;
Output::advancedExecuteOn() const
{
  mooseError(&quot;The output object &quot;, name(), &quot; is not an AdvancedOutput, use isAdvanced() to check.&quot;);
  return _advanced_execute_on;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="cb7456c4-b5b4-48e9-85dd-1d6a436c2a66"><div class="modal-content"><h4>(moose/framework/src/outputs/Output.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Standard includes
#include &lt;cmath&gt;
#include &lt;limits&gt;

// MOOSE includes
#include &quot;Output.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;DisplacedProblem.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Postprocessor.h&quot;
#include &quot;Restartable.h&quot;
#include &quot;FileMesh.h&quot;
#include &quot;MooseUtils.h&quot;
#include &quot;MooseApp.h&quot;
#include &quot;Console.h&quot;
#include &quot;Function.h&quot;
#include &quot;PiecewiseLinear.h&quot;
#include &quot;Times.h&quot;

#include &quot;libmesh/equation_systems.h&quot;

InputParameters
Output::validParams()
{
  // Get the parameters from the parent object
  InputParameters params = MooseObject::validParams();
  params += SetupInterface::validParams();

  // Displaced Mesh options
  params.addParam&lt;bool&gt;(
      &quot;use_displaced&quot;, false, &quot;Enable/disable the use of the displaced mesh for outputting&quot;);

  // Output intervals and timing
  params.addParam&lt;unsigned int&gt;(
      &quot;interval&quot;, 1, &quot;The interval at which time steps are output to the solution file&quot;);
  params.addParam&lt;Real&gt;(
      &quot;minimum_time_interval&quot;, 0.0, &quot;The minimum simulation time between output steps&quot;);
  params.addParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;,
                                     &quot;Times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;TimesName&gt;(
      &quot;sync_times_object&quot;,
      &quot;Times object providing the times at which the output and solution is forced to occur&quot;);
  params.addParam&lt;bool&gt;(&quot;sync_only&quot;, false, &quot;Only export results at sync times&quot;);
  params.addParam&lt;Real&gt;(&quot;start_time&quot;, &quot;Time at which this output object begins to operate&quot;);
  params.addParam&lt;Real&gt;(&quot;end_time&quot;, &quot;Time at which this output object stop operating&quot;);
  params.addParam&lt;int&gt;(&quot;start_step&quot;, &quot;Time step at which this output object begins to operate&quot;);
  params.addParam&lt;int&gt;(&quot;end_step&quot;, &quot;Time step at which this output object stop operating&quot;);
  params.addParam&lt;Real&gt;(
      &quot;time_tolerance&quot;, 1e-14, &quot;Time tolerance utilized checking start and end times&quot;);
  params.addDeprecatedParam&lt;FunctionName&gt;(
      &quot;output_limiting_function&quot;,
      &quot;Piecewise base function that sets sync_times&quot;,
      &quot;Replaced by using the Times system with the sync_times_objects parameter&quot;);

  // Update the &#x27;execute_on&#x27; input parameter for output
  ExecFlagEnum &amp; exec_enum = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;, true);
  exec_enum = Output::getDefaultExecFlagEnum();
  exec_enum = {EXEC_INITIAL, EXEC_TIMESTEP_END};
  params.setDocString(&quot;execute_on&quot;, exec_enum.getDocString());

  // Add ability to append to the &#x27;execute_on&#x27; list
  params.addParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;, exec_enum, exec_enum.getDocString());
  params.set&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;).clear();
  params.addParamNamesToGroup(&quot;execute_on additional_execute_on&quot;, &quot;Execution scheduling&quot;);

  // &#x27;Timing&#x27; group
  params.addParamNamesToGroup(
      &quot;time_tolerance interval sync_times sync_times_object sync_only start_time end_time &quot;
      &quot;start_step end_step minimum_time_interval&quot;,
      &quot;Timing and frequency of output&quot;);

  // Add a private parameter for indicating if it was created with short-cut syntax
  params.addPrivateParam&lt;bool&gt;(&quot;_built_by_moose&quot;, false);

  // Register this class as base class
  params.declareControllable(&quot;enable&quot;);
  params.registerBase(&quot;Output&quot;);

  return params;
}

ExecFlagEnum
Output::getDefaultExecFlagEnum()
{
  ExecFlagEnum exec_enum = MooseUtils::getDefaultExecFlagEnum();
  exec_enum.addAvailableFlags(EXEC_FAILED);
  return exec_enum;
}

Output::Output(const InputParameters &amp; parameters)
  : MooseObject(parameters),
    Restartable(this, &quot;Output&quot;),
    MeshChangedInterface(parameters),
    SetupInterface(this),
    FunctionInterface(this),
    PostprocessorInterface(this),
    VectorPostprocessorInterface(this),
    ReporterInterface(this),
    PerfGraphInterface(this),
    _problem_ptr(getParam&lt;FEProblemBase *&gt;(&quot;_fe_problem_base&quot;)),
    _transient(_problem_ptr-&gt;isTransient()),
    _use_displaced(getParam&lt;bool&gt;(&quot;use_displaced&quot;)),
    _es_ptr(nullptr),
    _mesh_ptr(nullptr),
    _execute_on(getParam&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;)),
    _current_execute_flag(EXEC_NONE),
    _time(_problem_ptr-&gt;time()),
    _time_old(_problem_ptr-&gt;timeOld()),
    _t_step(_problem_ptr-&gt;timeStep()),
    _dt(_problem_ptr-&gt;dt()),
    _dt_old(_problem_ptr-&gt;dtOld()),
    _num(0),
    _interval(getParam&lt;unsigned int&gt;(&quot;interval&quot;)),
    _minimum_time_interval(getParam&lt;Real&gt;(&quot;minimum_time_interval&quot;)),
    _sync_times(std::set&lt;Real&gt;(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).begin(),
                               getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;sync_times&quot;).end())),
    _sync_times_object(isParamValid(&quot;sync_times_object&quot;)
                           ? static_cast&lt;Times *&gt;(&amp;_problem_ptr-&gt;getUserObject&lt;Times&gt;(
                                 getParam&lt;TimesName&gt;(&quot;sync_times_object&quot;)))
                           : nullptr),
    _start_time(isParamValid(&quot;start_time&quot;) ? getParam&lt;Real&gt;(&quot;start_time&quot;)
                                           : std::numeric_limits&lt;Real&gt;::lowest()),
    _end_time(isParamValid(&quot;end_time&quot;) ? getParam&lt;Real&gt;(&quot;end_time&quot;)
                                       : std::numeric_limits&lt;Real&gt;::max()),
    _start_step(isParamValid(&quot;start_step&quot;) ? getParam&lt;int&gt;(&quot;start_step&quot;)
                                           : std::numeric_limits&lt;int&gt;::lowest()),
    _end_step(isParamValid(&quot;end_step&quot;) ? getParam&lt;int&gt;(&quot;end_step&quot;)
                                       : std::numeric_limits&lt;int&gt;::max()),
    _t_tol(getParam&lt;Real&gt;(&quot;time_tolerance&quot;)),
    _sync_only(getParam&lt;bool&gt;(&quot;sync_only&quot;)),
    _allow_output(true),
    _is_advanced(false),
    _advanced_execute_on(_execute_on, parameters),
    _last_output_time(
        declareRestartableData&lt;Real&gt;(&quot;last_output_time&quot;, std::numeric_limits&lt;Real&gt;::lowest()))
{
  if (_use_displaced)
  {
    std::shared_ptr&lt;DisplacedProblem&gt; dp = _problem_ptr-&gt;getDisplacedProblem();
    if (dp != nullptr)
    {
      _es_ptr = &amp;dp-&gt;es();
      _mesh_ptr = &amp;dp-&gt;mesh();
    }
    else
    {
      mooseWarning(
          name(),
          &quot;: Parameter &#x27;use_displaced&#x27; ignored, there is no displaced problem in your simulation.&quot;);
      _es_ptr = &amp;_problem_ptr-&gt;es();
      _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
    }
  }
  else
  {
    _es_ptr = &amp;_problem_ptr-&gt;es();
    _mesh_ptr = &amp;_problem_ptr-&gt;mesh();
  }

  // Apply the additional output flags
  if (isParamValid(&quot;additional_execute_on&quot;))
  {
    const ExecFlagEnum &amp; add = getParam&lt;ExecFlagEnum&gt;(&quot;additional_execute_on&quot;);
    for (auto &amp; me : add)
      _execute_on.push_back(me);
  }

  if (isParamValid(&quot;output_limiting_function&quot;))
  {
    const Function &amp; olf = getFunction(&quot;output_limiting_function&quot;);
    const PiecewiseBase * pwb_olf = dynamic_cast&lt;const PiecewiseBase *&gt;(&amp;olf);
    if (pwb_olf == nullptr)
      mooseError(&quot;Function muse have a piecewise base!&quot;);

    for (auto i = 0; i &lt; pwb_olf-&gt;functionSize(); i++)
      _sync_times.insert(pwb_olf-&gt;domain(i));
  }

  // Check that the sync times were retrieved as expected
  if (_sync_times_object &amp;&amp;
      (isParamValid(&quot;output_limiting_function&quot;) || isParamSetByUser(&quot;sync_times&quot;)))
    paramError(&quot;sync_times_object&quot;,
               &quot;Only one method of specifying sync times is supported at a time&quot;);
}

void
Output::solveSetup()
{
}

void
Output::outputStep(const ExecFlagType &amp; type)
{
  // Output is not allowed
  if (!_allow_output &amp;&amp; type != EXEC_FORCED)
    return;

  // If recovering disable output of initial condition, it was already output
  if (type == EXEC_INITIAL &amp;&amp; _app.isRecovering())
    return;

  // Return if the current output is not on the desired interval
  if (type != EXEC_FINAL &amp;&amp; !onInterval())
    return;

  // store current simulation time
  _last_output_time = _time;

  // set current type
  _current_execute_flag = type;

  // Call the output method
  if (shouldOutput())
  {
    TIME_SECTION(&quot;outputStep&quot;, 2, &quot;Outputting Step&quot;);
    output();
  }

  _current_execute_flag = EXEC_NONE;
}

bool
Output::shouldOutput()
{
  if (_execute_on.contains(_current_execute_flag) || _current_execute_flag == EXEC_FORCED)
    return true;
  return false;
}

bool
Output::onInterval()
{
  // The output flag to return
  bool output = false;

  // Return true if the current step on the current output interval and within the output time range
  // and within the output step range
  if (_time &gt;= _start_time &amp;&amp; _time &lt;= _end_time &amp;&amp; _t_step &gt;= _start_step &amp;&amp;
      _t_step &lt;= _end_step &amp;&amp; (_t_step % _interval) == 0)
    output = true;

  // Return false if &#x27;sync_only&#x27; is set to true
  if (_sync_only)
    output = false;

  // Update sync times if a sync time object is in use
  if (_sync_times_object)
    _sync_times = _sync_times_object-&gt;getUniqueTimes();

  // If sync times are not skipped, return true if the current time is a sync_time
  if (_sync_times.find(_time) != _sync_times.end())
    output = true;

  // check if enough time has passed between outputs
  if (_time &gt; _last_output_time &amp;&amp; _last_output_time + _minimum_time_interval &gt; _time + _t_tol)
    return false;

  // Return the output status
  return output;
}

Real
Output::time()
{
  if (_transient)
    return _time;
  else
    return _t_step;
}

Real
Output::timeOld()
{
  if (_transient)
    return _time_old;
  else
    return _t_step - 1;
}

Real
Output::dt()
{
  if (_transient)
    return _dt;
  else
    return 1;
}

Real
Output::dtOld()
{
  if (_transient)
    return _dt_old;
  else
    return 1;
}

int
Output::timeStep()
{
  return _t_step;
}

const MultiMooseEnum &amp;
Output::executeOn() const
{
  return _execute_on;
}

bool
Output::isAdvanced()
{
  return _is_advanced;
}

const OutputOnWarehouse &amp;
Output::advancedExecuteOn() const
{
  mooseError(&quot;The output object &quot;, name(), &quot; is not an AdvancedOutput, use isAdvanced() to check.&quot;);
  return _advanced_execute_on;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4c6f3f1e-0481-4473-9a2a-0f210779284a"><div class="modal-content"><h4>(moose/framework/include/interfaces/SetupInterface.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;MooseTypes.h&quot;
#include &quot;ExecFlagEnum.h&quot;
#include &quot;MooseEnum.h&quot;
#include &quot;InputParameters.h&quot;

// Forward declarations
class InputParameters;
class MooseObject;
template &lt;typename T&gt;
InputParameters validParams();

class SetupInterface
{
public:
  SetupInterface(const MooseObject * moose_object);
  virtual ~SetupInterface();

  static InputParameters validParams();

  /**
   * Gets called at the beginning of the simulation before this object is asked to do its job
   */
  virtual void initialSetup();

  /**
   * Gets called at the beginning of the timestep before this object is asked to do its job
   */
  virtual void timestepSetup();

  /**
   * Gets called just before the Jacobian is computed and before this object is asked to do its job
   */
  virtual void jacobianSetup();

  /**
   * Gets called just before the residual is computed and before this object is asked to do its job
   */
  virtual void residualSetup();

  /**
   * Gets called when the subdomain changes (i.e. in a Jacobian or residual loop) and before this
   * object is asked to do its job
   */
  virtual void subdomainSetup();

  /**
   * Gets called in FEProblemBase::execute() for execute flags other than initial, timestep_begin,
   * nonlinear, linear and subdomain
   */
  virtual void customSetup(const ExecFlagType &amp; /*exec_type*/) {}

  /**
   * Return the execute on MultiMooseEnum for this object.
   */
  const ExecFlagEnum &amp; getExecuteOnEnum() const;

private:
  /// Empty ExecFlagEnum for the case when the &quot;execute_on&quot; parameter is not included. This
  /// is private because others should not be messing with it.
  ExecFlagEnum _empty_execute_enum;

protected:
  /// Execute settings for this object.
  const ExecFlagEnum &amp; _execute_enum;

  /// Reference to FEProblemBase
  const ExecFlagType &amp; _current_execute_flag;

  // FEProblemBase::addMultiApp needs to reset the execution flags
  friend class FEProblemBase;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b8b10745-2fa2-46e4-9c86-fda9f2b64aaa"><div class="modal-content"><h4>(moose/modules/level_set/include/base/LevelSetTypes.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Moose.h&quot;

namespace LevelSet
{
extern const ExecFlagType EXEC_ADAPT_MESH;
extern const ExecFlagType EXEC_COMPUTE_MARKERS;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="7453a2b7-41e0-4158-854b-fed7e8cc65cb"><div class="modal-content"><h4>(moose/modules/level_set/src/base/LevelSetTypes.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// Level set includes
#include &quot;LevelSetTypes.h&quot;

// MOOSE includes
#include &quot;ExecFlagRegistry.h&quot;

const ExecFlagType LevelSet::EXEC_ADAPT_MESH = registerExecFlag(&quot;ADAPT_MESH&quot;);
const ExecFlagType LevelSet::EXEC_COMPUTE_MARKERS = registerExecFlag(&quot;COMPUTE_MARKERS&quot;);
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f83f30dc-663e-4879-98b6-46c851d7278c"><div class="modal-content"><h4>(moose/modules/level_set/src/transfers/LevelSetMeshRefinementTransfer.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LevelSetMeshRefinementTransfer.h&quot;

// MOOSE includes
#include &quot;Adaptivity.h&quot;
#include &quot;FEProblem.h&quot;
#include &quot;MooseVariable.h&quot;
#include &quot;MultiApp.h&quot;
#include &quot;LevelSetTypes.h&quot;

registerMooseObject(&quot;LevelSetApp&quot;, LevelSetMeshRefinementTransfer);

InputParameters
LevelSetMeshRefinementTransfer::validParams()
{
  InputParameters params = MultiAppCopyTransfer::validParams();
  params.addClassDescription(&quot;Transfers the mesh from the master application to the sub &quot;
                             &quot;application for the purposes of level set reinitialization problems &quot;
                             &quot;with mesh adaptivity.&quot;);
  params.suppressParameter&lt;MultiMooseEnum&gt;(&quot;direction&quot;);

  ExecFlagEnum &amp; exec = params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);
  exec.addAvailableFlags(LevelSet::EXEC_ADAPT_MESH, LevelSet::EXEC_COMPUTE_MARKERS);
  exec = {LevelSet::EXEC_COMPUTE_MARKERS, LevelSet::EXEC_ADAPT_MESH};
  params.set&lt;bool&gt;(&quot;check_multiapp_execute_on&quot;) = false;
  params.suppressParameter&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;);

  return params;
}

LevelSetMeshRefinementTransfer::LevelSetMeshRefinementTransfer(const InputParameters &amp; parameters)
  : MultiAppCopyTransfer(parameters)
{
  if (hasFromMultiApp())
    paramError(&quot;from_multi_app&quot;, &quot;from_multiapp or between_multiapp transfers are not supported&quot;);
}

void
LevelSetMeshRefinementTransfer::initialSetup()
{
  FEProblemBase &amp; from_problem = getToMultiApp()-&gt;problemBase();
  for (unsigned int i = 0; i &lt; getToMultiApp()-&gt;numGlobalApps(); i++)
    if (getToMultiApp()-&gt;hasLocalApp(i))
    {
      FEProblemBase &amp; to_problem = getToMultiApp()-&gt;appProblemBase(i);
      MooseVariable &amp; to_var = to_problem.getStandardVariable(0, _to_var_name);
      Adaptivity &amp; adapt = to_problem.adaptivity();
      adapt.setMarkerVariableName(to_var.name());
      adapt.setCyclesPerStep(from_problem.adaptivity().getCyclesPerStep());
      adapt.init(1, 0);
      adapt.setUseNewSystem();
      adapt.setMaxHLevel(from_problem.adaptivity().getMaxHLevel());
      adapt.setAdaptivityOn(false);
    }
}

void
LevelSetMeshRefinementTransfer::execute()
{
  if (_current_execute_flag == LevelSet::EXEC_COMPUTE_MARKERS)
    MultiAppCopyTransfer::execute();

  else if (_current_execute_flag == LevelSet::EXEC_ADAPT_MESH)
  {
    for (unsigned int i = 0; i &lt; getToMultiApp()-&gt;numGlobalApps(); i++)
      if (getToMultiApp()-&gt;hasLocalApp(i))
      {
        FEProblemBase &amp; to_problem = getToMultiApp()-&gt;appProblemBase(i);
        Adaptivity &amp; adapt = to_problem.adaptivity();
        adapt.setAdaptivityOn(true);
        to_problem.adaptMesh();
        adapt.setAdaptivityOn(false);
      }
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e3b353c2-6805-4d4d-9435-158952d8e182"><div class="modal-content"><h4>(moose/modules/level_set/src/base/LevelSetProblem.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;LevelSetProblem.h&quot;
#include &quot;LevelSetTypes.h&quot;

#include &quot;MultiAppTransfer.h&quot;

registerMooseObject(&quot;LevelSetApp&quot;, LevelSetProblem);

InputParameters
LevelSetProblem::validParams()
{
  InputParameters params = FEProblem::validParams();
  params.addClassDescription(&quot;A specilized problem class that adds a custom call to &quot;
                             &quot;MultiAppTransfer execution to transfer adaptivity for the level set &quot;
                             &quot;reinitialization.&quot;);
  return params;
}

LevelSetProblem::LevelSetProblem(const InputParameters &amp; parameters) : FEProblem(parameters) {}

void
LevelSetProblem::computeMarkers()
{
  FEProblem::computeMarkers();
  setCurrentExecuteOnFlag(LevelSet::EXEC_COMPUTE_MARKERS);
  execMultiAppTransfers(LevelSet::EXEC_COMPUTE_MARKERS, MultiAppTransfer::TO_MULTIAPP);
  setCurrentExecuteOnFlag(EXEC_NONE);
}

bool
LevelSetProblem::adaptMesh()
{
  bool adapt = FEProblem::adaptMesh();
  setCurrentExecuteOnFlag(LevelSet::EXEC_ADAPT_MESH);
  execMultiAppTransfers(LevelSet::EXEC_ADAPT_MESH, MultiAppTransfer::TO_MULTIAPP);
  setCurrentExecuteOnFlag(EXEC_NONE);
  return adapt;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#d6e0f691-cb57-4838-ba35-cf5b287b31d8" class="tooltipped" data-position="left" data-tooltip="Execute On">Execute On</a></li><li><a href="#625673fb-0837-4617-9caf-1715bde17809" class="tooltipped" data-position="left" data-tooltip="Modifying Execute On">Modifying Execute On</a></li><li><a href="#d332beed-91c2-4d24-b09a-1a3e018446dd" class="tooltipped" data-position="left" data-tooltip="Virtual Setup Methods">Virtual Setup Methods</a></li><li><a href="#b9e2e51d-f34c-48e1-bdc9-d5cb7733cbfc" class="tooltipped" data-position="left" data-tooltip="Creating Custom Execute Flags">Creating Custom Execute Flags</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>