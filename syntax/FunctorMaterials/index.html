<!DOCTYPE html><head><meta charset="UTF-8"><title>FunctorMaterials | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="92bf519b-ac9e-4e90-a102-ca30aa727309" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b07ae07a-9fe4-44f5-8838-0066c5cac9a5" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="770415bf-aef0-4112-840c-dab496ec76e2" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="09f69f1b-698f-4b87-8dec-e635b0bb4295"><i class="material-icons">menu</i></a><ul class="sidenav" id="09f69f1b-698f-4b87-8dec-e635b0bb4295"><li><a href="#!" class="dropdown-trigger" data-target="7c9d3891-5668-4b23-9ade-c6eb81cb454c" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c35a2667-4990-4877-a724-c5b2802a996c" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="4cb24801-bcd9-416e-8263-4a9fb7648aef" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="92bf519b-ac9e-4e90-a102-ca30aa727309"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="b07ae07a-9fe4-44f5-8838-0066c5cac9a5"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="770415bf-aef0-4112-840c-dab496ec76e2"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="7c9d3891-5668-4b23-9ade-c6eb81cb454c"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="c35a2667-4990-4877-a724-c5b2802a996c"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="4cb24801-bcd9-416e-8263-4a9fb7648aef"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">FunctorMaterials</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="79a5fb3c-9808-468b-9a3e-fbc216e85ece" data-section-level="1" data-section-text="FunctorMaterials"><h1 id="functormaterials">FunctorMaterials</h1><p>Much like regular materials declare regular material properties, functor materials declare functor material properties. Functor material properties are properties that are evaluated on-the-fly. Along with multiple other classes of MOOSE objects, they are <a href="../Functors/index.html">Functors</a>. This allows for the creation of objects with considerable inter-operability between systems.</p><section class="scrollspy" id="62b59b9a-aaef-44c3-83e6-3a3741cd194d" data-section-level="2" data-section-text="Using functor materials"><h2 id="using-functor-materials">Using functor materials</h2><p>Following a producer/consumer model, <code>FunctorMaterials</code> produce functor material properties, which kernels, boundary conditions, other functor materials, etc, may consume. Both regular and functor material properties support a wide array of data types (scalar, vector, tensors, <a href="../../automatic_differentiation/index.html">automatic differentiation</a> versions of all of these). Functor materials, because they are evaluated on-the-fly and call other functors on-the-fly as well, do not require dependency ordering.</p><p>All functor materials support caching in some capacity. This can avoid expensive material property computations, but is disabled by default due to the potential memory cost. The reader is referred to the <a href="../Functors/index.html#caching">Functors caching documentation</a>.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning</span></div><div class="card-content"><div class="moose-alert-content"><p>Functor material properties and regular material properties are generally <em></em>NOT** compatible with each other. Functor material properties can only be used as regular material properties using a <a href="../../source/materials/MaterialFunctorConverter.html">MaterialFunctorConverter</a> to process them.</p></div></div></div><p>Functor materials are created within the <code>[FunctorMaterials]</code> block.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>If a Functor is reported as missing by the simulation, and it was supposed to be created by a <code>FunctorMaterial</code>, you may use the <code>Debug/</code><a href="#87c93588-08cd-4d3f-9af1-7a84ad8a9c24" class="moose-modal-link modal-trigger">&quot;show_functors&quot;</a> parameter to get more information about what functors were created and requested.</p></div></div></div></section><section class="scrollspy" id="07b5a6ad-316f-40aa-a997-15b1e58245c7" data-section-level="2" data-section-text="Developing with functor materials"><h2 id="developing-with-functor-materials">Developing with functor materials</h2><section id="9627e980-3e20-4ba7-ace0-4450883f38e6" data-section-level="3" data-section-text="Evaluating functors"><h3 id="evaluating-functors">Evaluating functors</h3><p>See the <a href="../Functors/index.html#using-functors">Functor system documentation</a> for information on how to retrieve a functor material property value in a kernel, boundary condition, ... even another functor material property.</p></section><section id="1968f002-a2e1-4665-bed5-f12095aa59a8" data-section-level="3" data-section-text="Creating functor material properties"><h3 id="creating-functor-material-properties">Creating functor material properties</h3><p>The functor material property system introduces APIs slightly different from the traditional material property system for declaring/adding and getting properties. To add a functor property:</p><ul class="browser-default"><li><p><code>addFunctorProperty&lt;TYPE&gt;</code></p></li></ul><p>where <code>TYPE</code> can be anything such as <code>Real, ADReal, RealVectorValue, ADRealVectorValue</code> etc. To get a functor material property:</p><ul class="browser-default"><li><p><code>getFunctor&lt;TYPE&gt;</code></p></li></ul><p>It&#x27;s worth noting that whereas the traditional regular material property system has different methods to declare/get non-AD and AD properties, the new functor system has single APIs for both non-AD and AD property types.</p><p>Functor material property evaluations are defined using the API:</p><pre class="moose-pre"><code class="language-c++">
template &lt;typename T, typename PolymorphicLambda&gt;
const Moose::FunctorBase&lt;T&gt; &amp;
FunctorMaterial::addFunctorProperty(const std::string &amp; name,
                                    PolymorphicLambda my_lammy,
                                    const std::set&lt;ExecFlagType&gt; &amp; clearance_schedule = {
                                        EXEC_ALWAYS});
</code></pre><p>where the first argument will be the functor name stored in the problem functor database (all functor names must be unique), the second argument is a lambda defining the property evaluation, and the third optional argument is a set defining at which execution stages the functor evaluation cache should be cleared. The lambda must be callable with two arguments, the first corresponding to space, and the second corresponding to time, and must return the type <code>T</code> of the <code>FunctorMaterialProperty</code>. An example of adding a constant functor material property that returns a <code>Real</code> looks like:</p><pre class="moose-pre"><code class="language-c++">
    addFunctorProperty&lt;Real&gt;(
        &quot;foo&quot;, [](const auto &amp;, const auto &amp;) -&gt; Real { return 1.; });
</code></pre><p>An example of a functor material property that depends on a fluid properties user object and pressure and temperature functors looks like</p><pre class="moose-pre"><code class="language-c++">
  addFunctorProperty&lt;ADReal&gt;(_density_name,
                             [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
                             { return _fluid.rho_from_p_T(_pressure(r, t), _temperature(r, t)); });
</code></pre><p>In the above example, we simply forward the calling arguments along to the captured functors. <code>_pressure</code> and <code>_temperature</code> are captured in the lambda function because they are attributes to the local <code>FunctorMaterial</code> class, and <code>[this]</code> in the function definition captures all attributes from the class. Variable functor implementation is described in <a href="../../source/variables/MooseVariableBase.html#functor-vars">Variable functor evaluation</a>. A test functor material class to setup a dummy Euler problem is shown in</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#include &quot;ADCoupledVelocityMaterial.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADCoupledVelocityMaterial);

InputParameters
ADCoupledVelocityMaterial::validParams()
{
  InputParameters params = FunctorMaterial::validParams();
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;vel_x&quot;, &quot;the x velocity&quot;);
  params.addParam&lt;MooseFunctorName&gt;(&quot;vel_y&quot;, &quot;the y velocity&quot;);
  params.addParam&lt;MooseFunctorName&gt;(&quot;vel_z&quot;, &quot;the z velocity&quot;);
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;rho&quot;, &quot;The name of the density variable&quot;);
  params.addClassDescription(&quot;A material used to create a velocity from coupled variables&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;velocity&quot;, &quot;velocity&quot;, &quot;The name of the velocity material property to create&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_u&quot;, &quot;rho_u&quot;, &quot;The product of the density and the x-velocity component&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_v&quot;, &quot;rho_v&quot;, &quot;The product of the density and the y-velocity component&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_w&quot;, &quot;rho_w&quot;, &quot;The product of the density and the z-velocity component&quot;);
  params += SetupInterface::validParams();
  params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;) = {EXEC_ALWAYS};
  return params;
}

ADCoupledVelocityMaterial::ADCoupledVelocityMaterial(const InputParameters &amp; parameters)
  : FunctorMaterial(parameters),
    _vel_x(getFunctor&lt;ADReal&gt;(&quot;vel_x&quot;)),
    _vel_y(isParamValid(&quot;vel_y&quot;) ? &amp;getFunctor&lt;ADReal&gt;(&quot;vel_y&quot;) : nullptr),
    _vel_z(isParamValid(&quot;vel_z&quot;) ? &amp;getFunctor&lt;ADReal&gt;(&quot;vel_z&quot;) : nullptr),
    _rho(getFunctor&lt;ADReal&gt;(&quot;rho&quot;))
{
  const std::set&lt;ExecFlagType&gt; clearance_schedule(_execute_enum.begin(), _execute_enum.end());

  addFunctorProperty&lt;ADRealVectorValue&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;velocity&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADRealVectorValue
      {
        ADRealVectorValue velocity(_vel_x(r, t));
        velocity(1) = _vel_y ? (*_vel_y)(r, t) : ADReal(0);
        velocity(2) = _vel_z ? (*_vel_z)(r, t) : ADReal(0);
        return velocity;
      },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_u&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal { return _rho(r, t) * _vel_x(r, t); },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_v&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
      { return _vel_y ? _rho(r, t) * (*_vel_y)(r, t) : ADReal(0); },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_w&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
      { return _vel_z ? _rho(r, t) * (*_vel_z)(r, t) : ADReal(0); },
      clearance_schedule);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#64dfd704-0aeb-4d0a-b307-9adbbf160b78">(moose/test/src/materials/ADCoupledVelocityMaterial.C)</a></section><section id="b34348c0-da57-4d7e-b4a9-665415428010" data-section-level="3" data-section-text="Spatial arguments"><h3 id="spatial-arguments">Spatial arguments</h3><p>See the general <a href="../Functors/index.html#spatial-overload">Functor documentation</a> for an explanation about the spatial arguments that may be used for functor material properties.</p></section><section id="f8041649-bae3-475b-9626-629561ff6a4c" data-section-level="3" data-section-text="Value Caching"><h3 id="value-caching">Value Caching</h3><p>See the general <a href="../Functors/index.html#caching">Functor documentation</a> for an explanation about the caching capabilities that may be used with functor material properties. </p></section></section></section><div class="moose-modal modal" id="87c93588-08cd-4d3f-9af1-7a84ad8a9c24"><div class="modal-content"><h4>show_functors</h4><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to print information about the functors in the problem</p></div></div><div class="moose-modal modal" id="64dfd704-0aeb-4d0a-b307-9adbbf160b78"><div class="modal-content"><h4>(moose/test/src/materials/ADCoupledVelocityMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ADCoupledVelocityMaterial.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADCoupledVelocityMaterial);

InputParameters
ADCoupledVelocityMaterial::validParams()
{
  InputParameters params = FunctorMaterial::validParams();
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;vel_x&quot;, &quot;the x velocity&quot;);
  params.addParam&lt;MooseFunctorName&gt;(&quot;vel_y&quot;, &quot;the y velocity&quot;);
  params.addParam&lt;MooseFunctorName&gt;(&quot;vel_z&quot;, &quot;the z velocity&quot;);
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;rho&quot;, &quot;The name of the density variable&quot;);
  params.addClassDescription(&quot;A material used to create a velocity from coupled variables&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;velocity&quot;, &quot;velocity&quot;, &quot;The name of the velocity material property to create&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_u&quot;, &quot;rho_u&quot;, &quot;The product of the density and the x-velocity component&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_v&quot;, &quot;rho_v&quot;, &quot;The product of the density and the y-velocity component&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_w&quot;, &quot;rho_w&quot;, &quot;The product of the density and the z-velocity component&quot;);
  params += SetupInterface::validParams();
  params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;) = {EXEC_ALWAYS};
  return params;
}

ADCoupledVelocityMaterial::ADCoupledVelocityMaterial(const InputParameters &amp; parameters)
  : FunctorMaterial(parameters),
    _vel_x(getFunctor&lt;ADReal&gt;(&quot;vel_x&quot;)),
    _vel_y(isParamValid(&quot;vel_y&quot;) ? &amp;getFunctor&lt;ADReal&gt;(&quot;vel_y&quot;) : nullptr),
    _vel_z(isParamValid(&quot;vel_z&quot;) ? &amp;getFunctor&lt;ADReal&gt;(&quot;vel_z&quot;) : nullptr),
    _rho(getFunctor&lt;ADReal&gt;(&quot;rho&quot;))
{
  const std::set&lt;ExecFlagType&gt; clearance_schedule(_execute_enum.begin(), _execute_enum.end());

  addFunctorProperty&lt;ADRealVectorValue&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;velocity&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADRealVectorValue
      {
        ADRealVectorValue velocity(_vel_x(r, t));
        velocity(1) = _vel_y ? (*_vel_y)(r, t) : ADReal(0);
        velocity(2) = _vel_z ? (*_vel_z)(r, t) : ADReal(0);
        return velocity;
      },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_u&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal { return _rho(r, t) * _vel_x(r, t); },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_v&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
      { return _vel_y ? _rho(r, t) * (*_vel_y)(r, t) : ADReal(0); },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_w&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
      { return _vel_z ? _rho(r, t) * (*_vel_z)(r, t) : ADReal(0); },
      clearance_schedule);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#62b59b9a-aaef-44c3-83e6-3a3741cd194d" class="tooltipped" data-position="left" data-tooltip="Using functor materials">Using functor materials</a></li><li><a href="#07b5a6ad-316f-40aa-a997-15b1e58245c7" class="tooltipped" data-position="left" data-tooltip="Developing with functor materials">Developing with functor materials</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>