<!DOCTYPE html><head><meta charset="UTF-8"><title>Postprocessor System | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="ffc443f6-1f34-4fa3-ac2a-db83e38d0e07" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="2d3dcdb6-8c22-4513-98f7-ccf4e36298ba" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="84f6ebbb-35d5-4951-acb5-437836c2bedb" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="e699b07a-b493-492f-bae6-8c90b722688e"><i class="material-icons">menu</i></a><ul class="sidenav" id="e699b07a-b493-492f-bae6-8c90b722688e"><li><a href="#!" class="dropdown-trigger" data-target="113c2e82-4293-4cdd-868e-b42f82e6ce4f" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="696f1879-dbee-4499-8439-64ffcae179e9" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="6441e2cc-f79e-4d40-893b-bc0dc6e54a82" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="ffc443f6-1f34-4fa3-ac2a-db83e38d0e07"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="2d3dcdb6-8c22-4513-98f7-ccf4e36298ba"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="84f6ebbb-35d5-4951-acb5-437836c2bedb"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="113c2e82-4293-4cdd-868e-b42f82e6ce4f"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="696f1879-dbee-4499-8439-64ffcae179e9"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="6441e2cc-f79e-4d40-893b-bc0dc6e54a82"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">Postprocessors</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="7d70ddae-6629-4029-8076-bc41c84aff2f" data-section-level="1" data-section-text="Postprocessor System"><h1 id="postprocessor-system">Postprocessor System</h1><p>A PostProcessor object in MOOSE is a C++ object that computes a single scalar (<code>Real</code>) value, typically the value computed is an aggregation of data from a simulation. For example, the maximum value of a variable (see <a href="../../source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a>). The value compute may be coupled to other systems via the <code>getPostprocessorValue</code> method available in most MOOSE objects.</p><p>MOOSE includes a large number of postprocessors within the framework, the complete list is provided in <a href="index.html#available-objects">Available Objects list</a> section.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>The <a href="../Reporters/index.html">Reporter System</a> is a newer, more flexible system for computing aggregate values. It is recommended that new objects for aggregate calculations use the Reporter system.</p></div></div></div><section class="scrollspy" id="5c0417e6-6179-4856-af40-b99e0868251f" data-section-level="2" data-section-text="Example Input File"><h2 id="example-input-file">Example Input File</h2><p>The following input file snippet demonstrates the use of the <a href="../../source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a> to compute the minimum and maximum of the solution variable &quot;u&quot;.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Postprocessors]
  [max]
    type = ElementExtremeValue
    variable = u
  []
  [min]
    type = ElementExtremeValue
    variable = u
    value_type = min
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#1432e318-eb74-44d5-853d-ebf048517d2a">(moose/test/tests/postprocessors/element_extreme_value/element_extreme_value.i)</a><p>This snippet is a part of a test that may be executed using the MOOSE test application as follows.</p><pre class="moose-pre"><code class="language-bash">
cd ~/projects/moose/test
make -j8
cd tests/postprocessors/element_extreme_value
~/projects/moose/test/moose_test-opt -i element_extreme_value.i
</code></pre><p>The data from this calculation is reported in the terminal output by default and if <a href="../../source/outputs/Exodus.html">Exodus</a> output is enabled the values will automatically be included in the output file. It is also possible to export the data to a comma separated value (csv) file by enabling the <a href="../../source/outputs/CSV.html">CSV</a> object within the <a href="../Outputs/index.html">Outputs</a> block.</p><pre class="moose-pre"><code class="language-bash">
Postprocessor Values:
+----------------+----------------+----------------+
| time           | max            | min            |
+----------------+----------------+----------------+
|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |
|   1.000000e+00 |   9.788675e-01 |   2.113249e-02 |
+----------------+----------------+----------------+
</code></pre></section><section class="scrollspy" id="ffd6c4a3-259b-4d7e-87f8-383871073b5e" data-section-level="2" data-section-text="Coupling Example Code"><h2 id="coupling-example-code">Coupling Example Code</h2><p>The values computed within a Postprocessor object may be used within other objects that inherit from the <a href="../../source/interfaces/PostprocessorInterface.html">PostprocessorInterface</a>, which is nearly every system within MOOSE. For example, the the <a href="../../source/bcs/PostprocessorNeumannBC.html">PostprocessorNeumannBC</a> object allows for a Neumann boundary condition to be set to a value computed from a postprocessor; this object will be used as example to demonstrate how coupling is performed.</p><p>To understand how the coupling is coded it is beneficial to first see how the coupling is defined via the input file. The following input file snippet shows that a <a href="../../source/postprocessors/PointValue.html">PointValue</a> postprocessor is created and named &quot;right_pp&quot; and the <a href="../../source/bcs/PostprocessorNeumannBC.html">PostprocessorNeumannBC</a> uses this value to set the boundary condition.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Postprocessors]
  [right_pp]
    type = PointValue
    point = &#x27;0.5 0.5 0&#x27;
    variable = aux
    execute_on = &#x27;initial&#x27;
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = PostprocessorNeumannBC
    variable = u
    boundary = right
    postprocessor = right_pp
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a18eaf55-7b4c-4d26-9b79-f5b0488bc364">(moose/test/tests/bcs/pp_neumann/pp_neumann.i)</a><p>This first step of coding this type of coupling begins by adding the necessary input file syntax to the object that requires a postprocessor value, PostprocessorNeumannBC in this example. In all MOOSE objects input file syntax is governed by the validParams function of an object. To add the ability to couple a postprocessor, simply add a new parameter using the <code>PostprocessorName</code> type, as shown below. Notice, that the add parameters call includes a default value that makes the use of the postprocessor optional.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

InputParameters
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#84c83a4c-bb8e-4108-8020-3bdfaa8829d2">(moose/framework/src/bcs/PostprocessorNeumannBC.C)</a><p>The actual postprocessor value must be assigned to a member variable of the class, thus in the header a member variable must be created, which should always be a constant reference to a <code>PostprocessorValue</code> type. Since this is a reference it must be initialized, this occurs in the source file by calling the <code>getPostprocessorValue</code> method and providing the name used in the validParams function. The following snippets show declaration of the reference in the header and the initialization of this reference in the source file.  The <code>_value</code> member variable is then available for use anywhere inside the object, for the case of the boundary condition it is utilized in the computation of the residual.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  const PostprocessorValue &amp; _value;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ef286b68-47ab-4528-ba70-c765ad24db1c">(moose/framework/include/bcs/PostprocessorNeumannBC.h)</a><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addClassDescription(
      &quot;Neumann boundary condition with value prescribed by a Postprocessor value.&quot;);
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#41671ed8-e3ee-4848-966b-dc3da9dc5fba">(moose/framework/src/bcs/PostprocessorNeumannBC.C)</a><section id="7191c42c-2212-47df-93f6-f129c319e221" data-section-level="3" data-section-text="Coupling to other values"><h3 id="coupling-to-other-values">Coupling to other values</h3><p>Just as Postprocessor values can be used in other objects, Postprocessors themselves can couple to Functions and Scalar Variables. See the following example that couples a scalar variable into a Postprocessor:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Postprocessors]
  [./totalFlux]
    type = ScalarCoupledPostprocessor
    variable = u
    coupled_scalar = scalar_variable
    boundary = left
  [../]
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b5449534-288d-4712-8c7e-470b44db49cf">(moose/test/tests/postprocessors/scalar_coupled_postprocessor/scalar_coupled_postprocessor_test.i)</a></section></section><section class="scrollspy" id="be0b5103-f8c9-4c7b-8973-a2fb42405313" data-section-level="2" data-section-text="Creating a Object Postprocessor"><h2 id="creating-a-object">Creating a <code>Postprocessor</code> Object</h2><p>In general, every Postprocessor object has two methods that must be defined &quot;execute&quot; and &quot;getValue&quot;.</p><p>First, consider the execute method. This method is called by MOOSE at different time depending on the type of postprocessor object. Therefore, when creating a Postprocessor object the new object should inherit from one of the following C++ classes:</p><ul class="browser-default"><li><p><strong>GeneralPostprocessor</strong>: &quot;execute&quot; is called once on each execution flag. </p></li><li><p><strong>NodalPostprocessor</strong>: &quot;execute&quot; is called for each <strong>node</strong> within the mesh on each execution flag. </p></li><li><p><strong>ElementalPostprocessor</strong>: &quot;execute&quot; is called for each <strong>element</strong> within the mesh on each execution  flag. </p></li><li><p><strong>InternalSidePostprocessor</strong>: &quot;execute&quot; is called for each <strong>side</strong>, that is not on a boundary,  within the mesh on each execution flag. </p></li><li><p><strong>SidePostprocessor</strong>: &quot;execute&quot; is called for each <strong>side</strong>, that is on a boundary, within the mesh  on each execution flag.</p></li></ul><p>The use of execution flags is discussed in the <a href="index.html#execute-on">Execute On</a> section.</p><p>The getValue method is responsible for returning the value of the postprocessor object, this value is what is used by all objects that are coupled to the postprocessor. In some cases the necessary communication is performed within this method, but in general this following is preferred.</p><section id="4ede590b-9cdd-4380-b7f3-cd8554fd6c18" data-section-level="3" data-section-text="Parallel Considerations"><h3 id="parallel-considerations">Parallel Considerations</h3><p>When creating a postprocessor it is often necessary to perform some parallel communication to ensure that the value being computed is correct across processes and threads. Three additional methods exists for making this process as simple as possible.</p><ul class="browser-default"><li><p><code>initialize</code>: This is called prior to the execution of the postprocessor and should be used  to setup the object to be in a known state. It is important to point out that execution  in this context includes all calls to the execute method. For example, for a <code>NodalPostprocessor</code>  object the initialize method is called and then the execute method is called for all nodes. </p></li><li><p><code>finalize</code>: This is called after the execution of the postprocessor and is intended to perform  communication to prepare the object for the call to the getValue method. </p></li><li><p><code>threadJoin</code>: This is called after the execution of the postprocessor and is intended to perform  aggregation for shared memory parallelism.</p></li></ul><p>To understand the use of these methods the <a href="../../source/postprocessors/AverageNodalVariableValue.html">AverageNodalVariableValue</a> postprocessor shall be used as an example. As the name suggests this postprocessor computes the average of the value of a variable at the nodes. To perform this calculation the variable values from each node are summed as is the number of values within the execute method. Then the getValue method returns the average by returning the sum divided by the count. The following snippet shows the these two methods: the <code>_u[_qp]</code> is the value of the variable at the current node that comes from a shared base class and  <code>_sum</code> and <code>_n</code> are a member variables defined within class for performing the calculation.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#edde943f-4762-4e7f-ab5c-6c90cdba780d">(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><p>In parallel, the calls to the execute method occur on each process or thread on a subset of the domain, in this case nodes. Therefore, the computed values must be combined to get the actual summations required to compute the average value. The first step is to setup the state of this calculation within the initialize method, which in this example sets the <code>_sum</code> and <code>_n</code> member variables to zero.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ef9e0806-5b43-4d19-b479-c91bc4cf2d6f">(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><p>After the aforementioned execute method is called for each node the computed values for <code>_sum</code> and <code>_n</code> must be aggregated from across processes to the root processes. For this problem a gather operation is required to collect the values computed on all processes to the root process. This is accomplished via the <code>gatherSum</code> method.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#9fb5fdab-448f-4ca2-8435-64671b011a70">(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a><p>Of course, the type of communication necessary depends on the calculation being performed. The <a href="../../source/userobjects/UserObject.html">UserObject</a> base class includes helper methods for common parallel communications functions.</p><p>The initialize and finalize methods are utilized to aggregate for message passing (MPI) based parallelism. For shared memory parallelism the theadJoin method is used. This method is called, like finalize, after execution is complete and includes a single argument. This argument is a reference to a UserObject, which is a base class of Postprocessor objects. The purpose of this method is to enable the aggregation for the Postprocessor objects that were executed on other threads to the object on the root thread. For the AverageNodalVariableValue postprocessor the values for <code>_sum</code> and <code>_n</code> on the root process object are updated to include the these same values from the other threads.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#f9e77f2a-d7a7-404d-bf01-2cd2947c6874">(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</a></section></section><section class="scrollspy" id="973cbb43-a404-4a2d-a431-9b7178bdc9a1" data-section-level="2" data-section-text="Execute On ..."><h2 id="execute-on">Execute On...</h2><p>Postprocessor objects inherit from the <a href="../../source/interfaces/SetupInterface.html">SetupInterface (execute_on)</a> that allows the objects to execute and varying and multiple times during a simulation, such as during initialization and at the end of each time step. Refer to the <a href="../../source/interfaces/SetupInterface.html">SetupInterface (execute_on)</a> for additional information.</p></section><section class="scrollspy" id="091a494f-521b-4325-88e7-6f7e4ad82ded" data-section-level="2" data-section-text="Using Old and Older values"><h2 id="using-old-and-older-values">Using Old and Older values</h2><p>MOOSE maintains previously computed values in the postprocessor system for using lagged information in a computation. Both the previous time step&#x27;s value and the value computed two steps back may be retrieved. One reason you might use older values is to break cyclic dependencies. MOOSE does not consider a dependence on an old value when considering the order of evaluation among objects with dependencies.</p></section><section class="scrollspy" id="274402a5-fdb5-45c5-8bea-aa77370884b6" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageMaterialProperty.html">ADElementAverageMaterialProperty</a>Computes the average of a material property over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeFunctorValue.html">ADElementExtremeFunctorValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeMaterialProperty.html">ADElementExtremeMaterialProperty</a>Determines the minimum or maximum of a material property over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralFunctorPostprocessor.html">ADElementIntegralFunctorPostprocessor</a>Computes a volume integral of the specified functor</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralMaterialProperty.html">ADElementIntegralMaterialProperty</a>Compute the integral of the material property over the domain</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2FunctorError.html">ADElementL2FunctorError</a>Computes L2 error between an &#x27;approximate&#x27; functor and an &#x27;exact&#x27; functor</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceDiffusiveFluxAverage.html">ADInterfaceDiffusiveFluxAverage</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceDiffusiveFluxIntegral.html">ADInterfaceDiffusiveFluxIntegral</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="../../source/postprocessors/SideAdvectiveFluxIntegral.html">ADSideAdvectiveFluxIntegral</a>Computes the volumetric advected quantity through a sideset.</li><li class="collection-item"><a href="../../source/postprocessors/SideAverageMaterialProperty.html">ADSideAverageMaterialProperty</a>Computes the average of a material property over a side set.</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxAverage.html">ADSideDiffusiveFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideDiffusiveFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxAverage.html">ADSideFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralFunctorPostprocessor.html">ADSideIntegralFunctorPostprocessor</a>Computes a surface integral of the specified functor, using the single-sided face argument, which usually means that the functor will be evaluated from a single side of the surface, not interpolated between both sides.</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralMaterialProperty.html">ADSideIntegralMaterialProperty</a>Compute the integral of a scalar material property component over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">ADSideVectorDiffusivityFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/AreaPostprocessor.html">AreaPostprocessor</a>Computes the &quot;area&quot; or dimension - 1 &quot;volume&quot; of a given boundary or boundaries in your mesh.</li><li class="collection-item"><a href="../../source/postprocessors/AverageElementSize.html">AverageElementSize</a>Computes the average element size.</li><li class="collection-item"><a href="../../source/postprocessors/AverageNodalVariableValue.html">AverageNodalVariableValue</a>Computes the average value of a field by sampling all nodal solutions on the domain or within a subdomain</li><li class="collection-item"><a href="../../source/postprocessors/AxisymmetricCenterlineAverageValue.html">AxisymmetricCenterlineAverageValue</a>Computes the average value of a variable on a sideset located along the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/ChangeOverFixedPointPostprocessor.html">ChangeOverFixedPointPostprocessor</a>Computes the change or relative change in a post-processor value over a single or multiple fixed point iterations</li><li class="collection-item"><a href="../../source/postprocessors/ChangeOverTimePostprocessor.html">ChangeOverTimePostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="../../source/postprocessors/ChangeOverTimestepPostprocessor.html">ChangeOverTimestepPostprocessor</a>Computes the change or relative change in a post-processor value over a timestep or the entire transient</li><li class="collection-item"><a href="../../source/postprocessors/ConstantPostprocessor.html">ConstantPostprocessor</a>Postprocessor that holds a constant value</li><li class="collection-item"><a href="../../source/postprocessors/CumulativeValuePostprocessor.html">CumulativeValuePostprocessor</a>Creates a cumulative sum of a Postprocessor value with time.</li><li class="collection-item"><a href="../../source/postprocessors/DifferencePostprocessor.html">DifferencePostprocessor</a>Computes the difference between two postprocessors</li><li class="collection-item"><a href="../../source/postprocessors/ElementArrayL2Norm.html">ElementArrayL2Norm</a>Evaluates L2-norm of a component of an array variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageMaterialProperty.html">ElementAverageMaterialProperty</a>Computes the average of a material property over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageSecondTimeDerivative.html">ElementAverageSecondTimeDerivative</a>Computes the element averaged second derivative of variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageTimeDerivative.html">ElementAverageTimeDerivative</a>Computes a volume integral of the time derivative of a given variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementAverageValue.html">ElementAverageValue</a>Computes the volumetric average of a variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeFunctorValue.html">ElementExtremeFunctorValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeMaterialProperty.html">ElementExtremeMaterialProperty</a>Determines the minimum or maximum of a material property over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/ElementExtremeValue.html">ElementExtremeValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/ElementH1Error.html">ElementH1Error</a>Computes the H1 error between a variable and a function</li><li class="collection-item"><a href="../../source/postprocessors/ElementH1SemiError.html">ElementH1SemiError</a>Returns the gradient difference norm part of the H1 error</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralArrayVariablePostprocessor.html">ElementIntegralArrayVariablePostprocessor</a>Integral of one component of an array variable.</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralFunctorPostprocessor.html">ElementIntegralFunctorPostprocessor</a>Computes a volume integral of the specified functor</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralMaterialProperty.html">ElementIntegralMaterialProperty</a>Compute the integral of the material property over the domain</li><li class="collection-item"><a href="../../source/postprocessors/ElementIntegralVariablePostprocessor.html">ElementIntegralVariablePostprocessor</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementL1Error.html">ElementL1Error</a>Computes L1 error between an elemental field variable and an analytical function.</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Difference.html">ElementL2Difference</a>Computes the element-wise L2 difference between the current variable and a coupled variable.</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Error.html">ElementL2Error</a>Computes L2 error between a field variable and an analytical function</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2FunctorError.html">ElementL2FunctorError</a>Computes L2 error between an &#x27;approximate&#x27; functor and an &#x27;exact&#x27; functor</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Norm.html">ElementL2Norm</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/ElementSidesL2Norm.html">ElementSidesL2Norm</a>Computes the L2 norm of a variable over element sides.</li><li class="collection-item"><a href="../../source/postprocessors/ElementVectorL2Error.html">ElementVectorL2Error</a>Computes the Vector L2 difference of up to three variables simultaneously (normally x, y, z)</li><li class="collection-item"><a href="../../source/postprocessors/ElementW1pError.html">ElementW1pError</a>Computes the W1p norm of the difference between a variable and an analytic solution, as a function</li><li class="collection-item"><a href="../../source/postprocessors/ElementalVariableValue.html">ElementalVariableValue</a>Outputs an elemental variable value at a particular location</li><li class="collection-item"><a href="../../source/postprocessors/EmptyPostprocessor.html">EmptyPostprocessor</a>A postprocessor object that returns a value of zero.</li><li class="collection-item"><a href="../../source/postprocessors/FindValueOnLine.html">FindValueOnLine</a>Find a specific target value along a sampling line. The variable values along the line should change monotonically. The target value is searched using a bisection algorithm.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionElementAverage.html">FunctionElementAverage</a>Computes the average of a function over a volume.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionElementIntegral.html">FunctionElementIntegral</a>Integrates a function over elements</li><li class="collection-item"><a href="../../source/postprocessors/FunctionSideAverage.html">FunctionSideAverage</a>Computes the average of a function over a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionSideIntegral.html">FunctionSideIntegral</a>Computes the integral of a function over a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/FunctionValuePostprocessor.html">FunctionValuePostprocessor</a>Computes the value of a supplied function at a single point (scalable)</li><li class="collection-item"><a href="../../source/postprocessors/GreaterThanLessThanPostprocessor.html">GreaterThanLessThanPostprocessor</a>Count number of DOFs of a non-linear variable that are greater than or less than a given threshold</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceAverageVariableValuePostprocessor.html">InterfaceAverageVariableValuePostprocessor</a>Computes the average value of a variable on an interface. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceDiffusiveFluxAverage.html">InterfaceDiffusiveFluxAverage</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceDiffusiveFluxIntegral.html">InterfaceDiffusiveFluxIntegral</a>Computes the diffusive flux on the interface.</li><li class="collection-item"><a href="../../source/postprocessors/InterfaceIntegralVariableValuePostprocessor.html">InterfaceIntegralVariableValuePostprocessor</a>Add access to variables and their gradient on an interface.</li><li class="collection-item"><a href="../../source/postprocessors/InternalSideIntegralVariablePostprocessor.html">InternalSideIntegralVariablePostprocessor</a>Computes an integral on internal sides of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/LinearCombinationPostprocessor.html">LinearCombinationPostprocessor</a>Computes a linear combination between an arbitrary number of post-processors</li><li class="collection-item"><a href="../../source/postprocessors/MemoryUsage.html">MemoryUsage</a>Memory usage statistics for the running simulation.</li><li class="collection-item"><a href="../../source/postprocessors/NearestNodeNumber.html">NearestNodeNumber</a>Outputs the nearest node number to a point</li><li class="collection-item"><a href="../../source/postprocessors/NodalExtremeValue.html">NodalExtremeValue</a>Finds either the min or max elemental value of a variable over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/NodalL2Error.html">NodalL2Error</a>The L2-norm of the difference between a variable and a function computed at nodes.</li><li class="collection-item"><a href="../../source/postprocessors/NodalL2Norm.html">NodalL2Norm</a>Computes the nodal L2-norm of the coupled variable, which is defined by summing the square of its value at every node and taking the square root.</li><li class="collection-item"><a href="../../source/postprocessors/NodalMaxValue.html">NodalMaxValue</a>Computes the maximum (over all the nodal values) of a variable.</li><li class="collection-item"><a href="../../source/postprocessors/NodalMaxValueId.html">NodalMaxValueId</a>Finds the node id with the maximum nodal value across all postprocessors.</li><li class="collection-item"><a href="../../source/postprocessors/NodalMaxValueId.html">NodalProxyMaxValue</a>Finds the node id with the maximum nodal value across all postprocessors.</li><li class="collection-item"><a href="../../source/postprocessors/NodalSum.html">NodalSum</a>Computes the sum of all of the nodal values of the specified variable. Note: This object sets the default &quot;unique_node_execute&quot; flag to true to avoid double counting nodes between shared blocks.</li><li class="collection-item"><a href="../../source/postprocessors/NodalVariableValue.html">NodalVariableValue</a>Outputs values of a nodal variable at a particular location</li><li class="collection-item"><a href="../../source/postprocessors/NumDOFs.html">NumDOFs</a>Return the number of Degrees of freedom from either the NL, Aux or both systems.</li><li class="collection-item"><a href="../../source/postprocessors/NumElems.html">NumElems</a>Return the number of active or total elements in the simulation.</li><li class="collection-item"><a href="../../source/postprocessors/NumFailedTimeSteps.html">NumFailedTimeSteps</a>Collects the number of failed time steps from the time stepper.</li><li class="collection-item"><a href="../../source/postprocessors/NumFixedPointIterations.html">NumFixedPointIterations</a>Returns the number of fixed point iterations taken by the executioner.</li><li class="collection-item"><a href="../../source/postprocessors/NumLinearIterations.html">NumLinearIterations</a>Compute the number of linear iterations.</li><li class="collection-item"><a href="../../source/postprocessors/NumNodes.html">NumNodes</a>Returns the total number of nodes in a simulation (works with DistributedMesh)</li><li class="collection-item"><a href="../../source/postprocessors/NumNonlinearIterations.html">NumNonlinearIterations</a>Outputs the number of nonlinear iterations</li><li class="collection-item"><a href="../../source/postprocessors/NumFixedPointIterations.html">NumPicardIterations</a>Returns the number of fixed point iterations taken by the executioner.</li><li class="collection-item"><a href="../../source/postprocessors/NumPositions.html">NumPositions</a>Return the number of Positions from a Positions object.</li><li class="collection-item"><a href="../../source/postprocessors/NumRelationshipManagers.html">NumRelationshipManagers</a>Return the number of relationship managers active.</li><li class="collection-item"><a href="../../source/postprocessors/NumResidualEvaluations.html">NumResidualEvaluations</a>Returns the total number of residual evaluations performed.</li><li class="collection-item"><a href="../../source/postprocessors/NumVars.html">NumVars</a>Return the number of variables from either the NL, Aux, or both systems.</li><li class="collection-item"><a href="../../source/postprocessors/ParsedPostprocessor.html">ParsedPostprocessor</a>Computes a parsed expression with post-processors</li><li class="collection-item"><a href="../../source/postprocessors/PercentChangePostprocessor.html">PercentChangePostprocessor</a>Computes the percent change of a postprocessor value compared to the value at the previous timestep.</li><li class="collection-item"><a href="../../source/postprocessors/PerfGraphData.html">PerfGraphData</a>Retrieves performance information about a section from the PerfGraph.</li><li class="collection-item"><a href="../../source/postprocessors/PointValue.html">PointValue</a>Compute the value of a variable at a specified location</li><li class="collection-item"><a href="../../source/postprocessors/PostprocessorComparison.html">PostprocessorComparison</a>Compares two post-processors and produces a boolean value</li><li class="collection-item"><a href="../../source/postprocessors/Receiver.html">Receiver</a>Reports the value stored in this processor, which is usually filled in by another object. The Receiver does not compute its own value.</li><li class="collection-item"><a href="../../source/postprocessors/RelativeDifferencePostprocessor.html">RelativeDifferencePostprocessor</a>Computes the absolute value of the relative difference between 2 post-processor values.</li><li class="collection-item"><a href="../../source/postprocessors/RelativeSolutionDifferenceNorm.html">RelativeSolutionDifferenceNorm</a>Computes the relative norm of the solution difference of two consecutive time steps.</li><li class="collection-item"><a href="../../source/postprocessors/Residual.html">Residual</a>Report the non-linear residual.</li><li class="collection-item"><a href="../../source/postprocessors/ScalarL2Error.html">ScalarL2Error</a>Compute L2 error of a scalar variable using analytic function.</li><li class="collection-item"><a href="../../source/postprocessors/ScalarVariable.html">ScalarVariable</a>Returns the value of a scalar variable as a postprocessor value.</li><li class="collection-item"><a href="../../source/postprocessors/ScalePostprocessor.html">ScalePostprocessor</a>Scales a post-processor by a value</li><li class="collection-item"><a href="../../source/postprocessors/SideAdvectiveFluxIntegral.html">SideAdvectiveFluxIntegral</a>Computes the volumetric advected quantity through a sideset.</li><li class="collection-item"><a href="../../source/postprocessors/SideAverageMaterialProperty.html">SideAverageMaterialProperty</a>Computes the average of a material property over a side set.</li><li class="collection-item"><a href="../../source/postprocessors/SideAverageValue.html">SideAverageValue</a>Computes the average value of a variable on a sideset. Note that this cannot be used on the centerline of an axisymmetric model.</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxAverage.html">SideDiffusiveFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">SideDiffusiveFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideExtremeValue.html">SideExtremeValue</a>Finds either the min or max variable value of a variable over a boundary.</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxAverage.html">SideFluxAverage</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">SideFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralFunctorPostprocessor.html">SideIntegralFunctorPostprocessor</a>Computes a surface integral of the specified functor, using the single-sided face argument, which usually means that the functor will be evaluated from a single side of the surface, not interpolated between both sides.</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralMaterialProperty.html">SideIntegralMaterialProperty</a>Compute the integral of a scalar material property component over the domain.</li><li class="collection-item"><a href="../../source/postprocessors/SideIntegralVariablePostprocessor.html">SideIntegralVariablePostprocessor</a>Computes a surface integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/SideDiffusiveFluxIntegral.html">SideVectorDiffusivityFluxIntegral</a>Computes the integral of the diffusive flux over the specified boundary</li><li class="collection-item"><a href="../../source/postprocessors/TimeExtremeValue.html">TimeExtremeValue</a>A postprocessor for reporting the extreme value of another postprocessor over time.</li><li class="collection-item"><a href="../../source/postprocessors/TimeIntegratedPostprocessor.html">TimeIntegratedPostprocessor</a>Integrate a Postprocessor value over time using trapezoidal rule.</li><li class="collection-item"><a href="../../source/postprocessors/TimePostprocessor.html">TimePostprocessor</a>Reports the current time</li><li class="collection-item"><a href="../../source/postprocessors/TimestepSize.html">TimestepSize</a>Reports the timestep size</li><li class="collection-item"><a href="../../source/postprocessors/TimeIntegratedPostprocessor.html">TotalVariableValue</a>Integrate a Postprocessor value over time using trapezoidal rule.</li><li class="collection-item"><a href="../../source/postprocessors/VariableInnerProduct.html">VariableInnerProduct</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/VariableResidual.html">VariableResidual</a>Computes the L2 norm of the residual of a single variable in the solution vector.</li><li class="collection-item"><a href="../../source/postprocessors/VectorPostprocessorComparison.html">VectorPostprocessorComparison</a>Compares two vector post-processors of equal size and produces a boolean value</li><li class="collection-item"><a href="../../source/postprocessors/VectorPostprocessorComponent.html">VectorPostprocessorComponent</a>Returns the value of the specified component of a VectorPostprocessor</li><li class="collection-item"><a href="../../source/postprocessors/VectorPostprocessorReductionValue.html">VectorPostprocessorReductionValue</a>Takes a VectorPostprocessor and performs a reduction operation on it (max, min, sum, average) and stores as postprocessor.</li><li class="collection-item"><a href="../../source/postprocessors/VolumePostprocessor.html">VolumePostprocessor</a>Computes the volume of a specified block</li><li class="collection-header">Moltres App</li><li class="collection-item"><a href="../../source/postprocessors/AverageFissionHeat.html">AverageFissionHeat</a></li><li class="collection-item"><a href="../../source/postprocessors/DivisionPostprocessor.html">DivisionPostprocessor</a>Computes the difference between two postprocessors</li><li class="collection-item"><a href="../../source/postprocessors/ElementL2Diff.html">ElementL2Diff</a>Computes a volume integral of the specified variable</li><li class="collection-item"><a href="../../source/postprocessors/ElmIntegTotFissHeatPostprocessor.html">ElmIntegTotFissHeatPostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/ElmIntegTotFissNtsPostprocessor.html">ElmIntegTotFissNtsPostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/ElmIntegTotFissPostprocessor.html">ElmIntegTotFissPostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/IntegralNewVariablePostprocessor.html">IntegralNewVariablePostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/IntegralOldVariablePostprocessor.html">IntegralOldVariablePostprocessor</a></li><li class="collection-item"><a href="../../source/postprocessors/LimitK.html">LimitK</a>Reports the timestep size</li><li class="collection-item"><a href="../../source/postprocessors/SideWeightedIntegralPostprocessor.html">SideWeightedIntegralPostprocessor</a>Postprocessor for calculating the weighted integral sum/average of a variable along a boundary</li></ul></section><section class="scrollspy" id="d936e4a0-740b-4b69-8b1e-228e9a318132" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddPostprocessorAction.html">AddPostprocessorAction</a>Add a Postprocessor object to the simulation.</li></ul></section></section><div class="moose-modal modal" id="1432e318-eb74-44d5-853d-ebf048517d2a"><div class="modal-content"><h4>(moose/test/tests/postprocessors/element_extreme_value/element_extreme_value.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = right
    value = 1
  []
[]

[Postprocessors]
  [max]
    type = ElementExtremeValue
    variable = u
  []
  [min]
    type = ElementExtremeValue
    variable = u
    value_type = min
  []
[]

[Executioner]
  type = Steady
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a18eaf55-7b4c-4d26-9b79-f5b0488bc364"><div class="modal-content"><h4>(moose/test/tests/bcs/pp_neumann/pp_neumann.i)</h4><pre class="moose-pre"><code class="language-text"># NOTE: This file is used within the documentation, so please do not change names within the file
# without checking that associated documentation is not affected, see syntax/Postprocessors/index.md.
[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [u]
  []
[]

[AuxVariables]
  [aux]
    initial_condition = 5
  []
[]

[Kernels]
  [diff]
    type = Diffusion
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = left
    value = 0
  []
  [right]
    type = PostprocessorNeumannBC
    variable = u
    boundary = right
    postprocessor = right_pp
  []
[]

[Postprocessors]
  [right_pp]
    type = PointValue
    point = &#x27;0.5 0.5 0&#x27;
    variable = aux
    execute_on = &#x27;initial&#x27;
  []
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  execute_on = &#x27;timestep_end&#x27;
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="84c83a4c-bb8e-4108-8020-3bdfaa8829d2"><div class="modal-content"><h4>(moose/framework/src/bcs/PostprocessorNeumannBC.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

InputParameters
PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addClassDescription(
      &quot;Neumann boundary condition with value prescribed by a Postprocessor value.&quot;);
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}

PostprocessorNeumannBC::PostprocessorNeumannBC(const InputParameters &amp; parameters)
  : IntegratedBC(parameters), _value(getPostprocessorValue(&quot;postprocessor&quot;))
{
}

Real
PostprocessorNeumannBC::computeQpResidual()
{
  return -_test[_i][_qp] * _value;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ef286b68-47ab-4528-ba70-c765ad24db1c"><div class="modal-content"><h4>(moose/framework/include/bcs/PostprocessorNeumannBC.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;IntegratedBC.h&quot;

/**
 * Implements a constant Neumann BC where grad(u) is a equal to a postprocessor on the boundary.
 * Uses the term produced from integrating the diffusion operator by parts.
 */
class PostprocessorNeumannBC : public IntegratedBC
{
public:
  /**
   * Factory constructor, takes parameters so that all derived classes can be built using the same
   * constructor.
   */
  static InputParameters validParams();

  PostprocessorNeumannBC(const InputParameters &amp; parameters);

protected:
  virtual Real computeQpResidual() override;

  /// Value of grad(u) on the boundary.
  const PostprocessorValue &amp; _value;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="41671ed8-e3ee-4848-966b-dc3da9dc5fba"><div class="modal-content"><h4>(moose/framework/src/bcs/PostprocessorNeumannBC.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;PostprocessorNeumannBC.h&quot;

registerMooseObject(&quot;MooseApp&quot;, PostprocessorNeumannBC);

InputParameters
PostprocessorNeumannBC::validParams()
{
  InputParameters params = IntegratedBC::validParams();
  params.addClassDescription(
      &quot;Neumann boundary condition with value prescribed by a Postprocessor value.&quot;);
  params.addParam&lt;PostprocessorName&gt;(
      &quot;postprocessor&quot;, 0.0, &quot;The postprocessor to use for value of the gradient on the boundary.&quot;);
  return params;
}

PostprocessorNeumannBC::PostprocessorNeumannBC(const InputParameters &amp; parameters)
  : IntegratedBC(parameters), _value(getPostprocessorValue(&quot;postprocessor&quot;))
{
}

Real
PostprocessorNeumannBC::computeQpResidual()
{
  return -_test[_i][_qp] * _value;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b5449534-288d-4712-8c7e-470b44db49cf"><div class="modal-content"><h4>(moose/test/tests/postprocessors/scalar_coupled_postprocessor/scalar_coupled_postprocessor_test.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 5
  ny = 5
  xmax = 1
  ymax = 1
  elem_type = QUAD4
[]

[Variables]
  [./u]
    initial_condition = 1
  [../]
  [./scalar_variable]
    family = SCALAR
    order = FIRST
    initial_condition = 2
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[ScalarKernels]
  [./td1]
    type = ODETimeDerivative
    variable = scalar_variable
  [../]
[]

[BCs]
  [./leftDirichlet]
      type = DirichletBC
      variable = u
      boundary = &#x27;left&#x27;
      value = 1
  [../]
  [./rightDirichlet]
      type = DirichletBC
      variable = u
      boundary = &#x27;right&#x27;
      value = 0
  [../]
[]

[Postprocessors]
  [./totalFlux]
    type = ScalarCoupledPostprocessor
    variable = u
    coupled_scalar = scalar_variable
    boundary = left
  [../]
[]

[Executioner]
  type = Transient
  dt = 1
  num_steps = 1
  solve_type = JFNK
  l_max_its = 30
  l_tol = 1e-6
  nl_max_its = 20
  nl_rel_tol = 1e-5
[]

[Outputs]
  csv = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="edde943f-4762-4e7f-ab5c-6c90cdba780d"><div class="modal-content"><h4>(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ef9e0806-5b43-4d19-b479-c91bc4cf2d6f"><div class="modal-content"><h4>(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="9fb5fdab-448f-4ca2-8435-64671b011a70"><div class="modal-content"><h4>(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f9e77f2a-d7a7-404d-bf01-2cd2947c6874"><div class="modal-content"><h4>(moose/framework/src/postprocessors/AverageNodalVariableValue.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;AverageNodalVariableValue.h&quot;
#include &quot;MooseMesh.h&quot;
#include &quot;SubProblem.h&quot;

registerMooseObject(&quot;MooseApp&quot;, AverageNodalVariableValue);

InputParameters
AverageNodalVariableValue::validParams()
{
  InputParameters params = NodalVariablePostprocessor::validParams();

  params.addClassDescription(&quot;Computes the average value of a field by sampling all nodal &quot;
                             &quot;solutions on the domain or within a subdomain&quot;);
  return params;
}

AverageNodalVariableValue::AverageNodalVariableValue(const InputParameters &amp; parameters)
  : NodalVariablePostprocessor(parameters), _sum(0), _n(0)
{
}

// doco-init-start
void
AverageNodalVariableValue::initialize()
{
  _sum = 0;
  _n = 0;
}
// doco-init-end

// doco-execute-get-start
void
AverageNodalVariableValue::execute()
{
  _sum += _u[_qp];
  _n++;
}

Real
AverageNodalVariableValue::getValue() const
{
  return _sum / _n;
}
// doco-execute-get-end

// doco-final-start
void
AverageNodalVariableValue::finalize()
{
  gatherSum(_sum);
  gatherSum(_n);
}
// doco-final-end

// doco-thread-start
void
AverageNodalVariableValue::threadJoin(const UserObject &amp; y)
{
  const AverageNodalVariableValue &amp; pps = static_cast&lt;const AverageNodalVariableValue &amp;&gt;(y);
  _sum += pps._sum;
  _n += pps._n;
}
// doco-thread-end
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#5c0417e6-6179-4856-af40-b99e0868251f" class="tooltipped" data-position="left" data-tooltip="Example Input File">Example Input File</a></li><li><a href="#ffd6c4a3-259b-4d7e-87f8-383871073b5e" class="tooltipped" data-position="left" data-tooltip="Coupling Example Code">Coupling Example Code</a></li><li><a href="#be0b5103-f8c9-4c7b-8973-a2fb42405313" class="tooltipped" data-position="left" data-tooltip="Creating a Object Postprocessor">Creating a Object Postprocessor</a></li><li><a href="#973cbb43-a404-4a2d-a431-9b7178bdc9a1" class="tooltipped" data-position="left" data-tooltip="Execute On ...">Execute On ...</a></li><li><a href="#091a494f-521b-4325-88e7-6f7e4ad82ded" class="tooltipped" data-position="left" data-tooltip="Using Old and Older values">Using Old and Older values</a></li><li><a href="#274402a5-fdb5-45c5-8bea-aa77370884b6" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#d936e4a0-740b-4b69-8b1e-228e9a318132" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>