<!DOCTYPE html><head><meta charset="UTF-8"><title>Mesh System | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="713c94d1-9aa6-4460-8c61-d6585cb55464" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="92929895-49d9-4de9-99cb-208f8c74db54" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1cc4b2ac-fde4-441e-8302-69468ee770e8" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="992064e5-b21a-4f1a-a9dd-07d687fce877"><i class="material-icons">menu</i></a><ul class="sidenav" id="992064e5-b21a-4f1a-a9dd-07d687fce877"><li><a href="#!" class="dropdown-trigger" data-target="bec97105-38c4-46ba-80b2-32fa9b91b764" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="07df844c-4b51-4941-bc88-fbc5566e8c5c" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7f1a2738-5e51-46da-a24d-87f95c9a6b09" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="713c94d1-9aa6-4460-8c61-d6585cb55464"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="92929895-49d9-4de9-99cb-208f8c74db54"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="1cc4b2ac-fde4-441e-8302-69468ee770e8"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="bec97105-38c4-46ba-80b2-32fa9b91b764"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="07df844c-4b51-4941-bc88-fbc5566e8c5c"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="7f1a2738-5e51-46da-a24d-87f95c9a6b09"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">Mesh</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="a75d15b0-d7e5-465f-b1a5-832555520006" data-section-level="1" data-section-text="Mesh System"><h1 id="mesh-system">Mesh System</h1><section class="scrollspy" id="eaabe8e1-2a99-4433-b5a9-20f54926d1f1" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>There are two primary ways of creating a mesh for use in a MOOSE simulation: &quot;offline generation&quot; through a tool like <a href="https://cubit.sandia.gov/">CUBIT</a> from <a href="http://www.sandia.gov/">Sandia National Laboratories</a>, and &quot;online generation&quot; through programmatic interfaces. CUBIT is useful for creating complex geometries, and can be licensed from CSimSoft for a fee depending on the type of organization and work being performed. Other mesh generators can work as long as they output a file format that is supported by the <a href="../../source/mesh/FileMesh.html">FileMesh</a> object.</p></section><section class="scrollspy" id="d3d645f9-9f26-42ff-bfd4-b6a5b9546b1a" data-section-level="2" data-section-text="Example Syntax and Mesh Objects"><h2 id="example-syntax-and-mesh-objects">Example Syntax and Mesh Objects</h2><p>Mesh settings are applied with the <code>[Mesh]</code> of the input files, for example the basic input file syntax for reading a file from a mesh is shown below. For additional information on the other types of Mesh objects refer to the individual object pages listed below.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#e40eeb1f-c807-4c68-a1b6-745b8bbb5463">(moose/test/tests/auxkernels/solution_aux/build.i)</a></section><section class="scrollspy" id="1b760fcb-d0e6-4d3b-be1a-52afb3bd3465" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/meshgenerators/AddMetaDataGenerator.html">AddMetaDataGenerator</a>This mesh generator assigns extraneous mesh metadata to the input mesh</li><li class="collection-item"><a href="../../source/meshgenerators/AdvancedExtruderGenerator.html">AdvancedExtruderGenerator</a>Extrudes a 1D mesh into 2D, or a 2D mesh into 3D, can have a variable height for each elevation, variable number of layers within each elevation, variable growth factors of axial element sizes within each elevation and remap subdomain_ids, boundary_ids and element extra integers within each elevation as well as interface boundaries between neighboring elevation layers.</li><li class="collection-item"><a href="../../source/meshgenerators/AllSideSetsByNormalsGenerator.html">AllSideSetsByNormalsGenerator</a>Adds sidesets to the entire mesh based on unique normals.</li><li class="collection-item"><a href="../../source/meshgenerators/AnnularMeshGenerator.html">AnnularMeshGenerator</a>For rmin&gt;0: creates an annular mesh of QUAD4 elements. For rmin=0: creates a disc mesh of QUAD4 and TRI3 elements. Boundary sidesets are created at rmax and rmin, and given these names. If dmin!<u>0 and dmax!</u>360, a sector of an annulus or disc is created. In this case boundary sidesets are also created at dmin and dmax, and given these names</li><li class="collection-item"><a href="../../source/meshgenerators/BlockDeletionGenerator.html">BlockDeletionGenerator</a>Mesh generator which removes elements from the specified subdomains</li><li class="collection-item"><a href="../../source/meshgenerators/BlockToMeshConverterGenerator.html">BlockToMeshConverterGenerator</a>Converts one or more blocks (subdomains) from a mesh into a stand-alone mesh with a single block in it.</li><li class="collection-item"><a href="../../source/meshgenerators/BoundaryDeletionGenerator.html">BoundaryDeletionGenerator</a>Mesh generator which removes side sets</li><li class="collection-item"><a href="../../source/meshgenerators/BoundingBoxNodeSetGenerator.html">BoundingBoxNodeSetGenerator</a>Assigns all of the nodes either inside or outside of a bounding box to a new nodeset.</li><li class="collection-item"><a href="../../source/meshgenerators/BreakBoundaryOnSubdomainGenerator.html">BreakBoundaryOnSubdomainGenerator</a>Break boundaries based on the subdomains to which their sides are attached. Naming convention for the new boundaries will be the old boundary name plus &quot;_to_&quot; plus the subdomain name</li><li class="collection-item"><a href="../../source/meshgenerators/BreakMeshByBlockGenerator.html">BreakMeshByBlockGenerator</a>Break boundaries based on the subdomains to which their sides are attached. Naming convention for the new boundaries will be the old boundary name plus &quot;_to_&quot; plus the subdomain name. At the momentthis only works on REPLICATED mesh</li><li class="collection-item"><a href="../../source/meshgenerators/CartesianMeshGenerator.html">CartesianMeshGenerator</a>This CartesianMeshGenerator creates a non-uniform Cartesian mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/CircularBoundaryCorrectionGenerator.html">CircularBoundaryCorrectionGenerator</a>This CircularBoundaryCorrectionGenerator object is designed to correct full or partial circular boundaries in a 2D mesh to preserve areas.</li><li class="collection-item"><a href="../../source/meshgenerators/CombinerGenerator.html">CombinerGenerator</a>Combine multiple meshes (or copies of one mesh) together into one (disjoint) mesh.  Can optionally translate those meshes before combining them.</li><li class="collection-item"><a href="../../source/meshgenerators/ConcentricCircleMeshGenerator.html">ConcentricCircleMeshGenerator</a>This ConcentricCircleMeshGenerator source code is to generate concentric circle meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/DistributedRectilinearMeshGenerator.html">DistributedRectilinearMeshGenerator</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ElementGenerator.html">ElementGenerator</a>Generates individual elements given a list of nodal positions.</li><li class="collection-item"><a href="../../source/meshgenerators/ElementSubdomainIDGenerator.html">ElementSubdomainIDGenerator</a>Allows the user to assign each element the subdomain ID of their choice</li><li class="collection-item"><a href="../../source/meshgenerators/ExplodeMeshGenerator.html">ExplodeMeshGenerator</a>Break all element-element interfaces in the specified subdomains.</li><li class="collection-item"><a href="../../source/meshgenerators/ExtraNodesetGenerator.html">ExtraNodesetGenerator</a>Creates a new node set and a new boundary made with the nodes the user provides.</li><li class="collection-item"><a href="../../source/meshgenerators/AdvancedExtruderGenerator.html">FancyExtruderGenerator</a>Extrudes a 1D mesh into 2D, or a 2D mesh into 3D, can have a variable height for each elevation, variable number of layers within each elevation, variable growth factors of axial element sizes within each elevation and remap subdomain_ids, boundary_ids and element extra integers within each elevation as well as interface boundaries between neighboring elevation layers.</li><li class="collection-item"><a href="../../source/meshgenerators/FileMeshGenerator.html">FileMeshGenerator</a>Read a mesh from a file.</li><li class="collection-item"><a href="../../source/meshgenerators/FillBetweenCurvesGenerator.html">FillBetweenCurvesGenerator</a>This FillBetweenCurvesGenerator object is designed to generate a transition layer to connect two boundaries of two input meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/FillBetweenPointVectorsGenerator.html">FillBetweenPointVectorsGenerator</a>This FillBetweenPointVectorsGenerator object is designed to generate a transition layer with two sides containing different numbers of nodes.</li><li class="collection-item"><a href="../../source/meshgenerators/FillBetweenSidesetsGenerator.html">FillBetweenSidesetsGenerator</a>This FillBetweenSidesetsGenerator object is designed to generate a transition layer to connect two boundaries of two input meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/GeneratedMeshGenerator.html">GeneratedMeshGenerator</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ImageMeshGenerator.html">ImageMeshGenerator</a>Generated mesh with the aspect ratio of a given image stack.</li><li class="collection-item"><a href="../../source/meshgenerators/ImageSubdomainGenerator.html">ImageSubdomainGenerator</a>Samples an image at the coordinates of each element centroid, using the resulting pixel color value as each element&#x27;s subdomain ID</li><li class="collection-item"><a href="../../source/meshgenerators/LowerDBlockFromSidesetGenerator.html">LowerDBlockFromSidesetGenerator</a>Adds lower dimensional elements on the specified sidesets.</li><li class="collection-item"><a href="../../source/meshgenerators/MeshCollectionGenerator.html">MeshCollectionGenerator</a>Collects multiple meshes into a single (unconnected) mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/MeshExtruderGenerator.html">MeshExtruderGenerator</a>Takes a 1D or 2D mesh and extrudes the entire structure along the specified axis increasing the dimensionality of the mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/MoveNodeGenerator.html">MoveNodeGenerator</a>Modifies the position of one or more nodes</li><li class="collection-item"><a href="../../source/meshgenerators/NodeSetsFromSideSetsGenerator.html">NodeSetsFromSideSetsGenerator</a>Mesh generator which constructs node sets from side sets</li><li class="collection-item"><a href="../../source/meshgenerators/OrientedSubdomainBoundingBoxGenerator.html">OrientedSubdomainBoundingBoxGenerator</a>Defines a subdomain inside or outside of a bounding box with arbitrary orientation.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedCurveGenerator.html">ParsedCurveGenerator</a>This ParsedCurveGenerator object is designed to generate a mesh of a curve that consists of EDGE2 elements.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedGenerateSideset.html">ParsedGenerateSideset</a>A MeshGenerator that adds element sides to a sideset if the centroid satisfies the <code>combinatorial_geometry</code> expression. Optionally, element sides are also added if they are included in <code>included_subdomain_ids</code> and if they feature the designated normal.</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedNodeTransformGenerator.html">ParsedNodeTransformGenerator</a>Applies a transform to a the x,y,z coordinates of a Mesh</li><li class="collection-item"><a href="../../source/meshgenerators/ParsedSubdomainMeshGenerator.html">ParsedSubdomainMeshGenerator</a>Uses a parsed expression (<code>combinatorial_geometry</code>) to determine if an element (via its centroid) is inside the region defined by the expression and assigns a new block ID.</li><li class="collection-item"><a href="../../source/meshgenerators/PatchMeshGenerator.html">PatchMeshGenerator</a>Creates 2D or 3D patch meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/PatternedMeshGenerator.html">PatternedMeshGenerator</a>Creates a 2D mesh from a specified set of unique &#x27;tiles&#x27; meshes and a two-dimensional pattern.</li><li class="collection-item"><a href="../../source/meshgenerators/PlaneDeletionGenerator.html">PlaneDeletionGenerator</a>Removes elements lying &#x27;above&#x27; the plane (in the direction of the normal).</li><li class="collection-item"><a href="../../source/meshgenerators/PlaneIDMeshGenerator.html">PlaneIDMeshGenerator</a>Adds an extra element integer that identifies planes in a mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/PolyLineMeshGenerator.html">PolyLineMeshGenerator</a>Generates meshes from edges connecting a list of points.</li><li class="collection-item"><a href="../../source/meshgenerators/RefineBlockGenerator.html">RefineBlockGenerator</a>Mesh generator which refines one or more blocks in an existing mesh</li><li class="collection-item"><a href="../../source/meshgenerators/RefineSidesetGenerator.html">RefineSidesetGenerator</a>Mesh generator which refines one or more sidesets</li><li class="collection-item"><a href="../../source/meshgenerators/RenameBlockGenerator.html">RenameBlockGenerator</a>Changes the block IDs and/or block names for a given set of blocks defined by either block ID or block name. The changes are independent of ordering. The merging of blocks is supported.</li><li class="collection-item"><a href="../../source/meshgenerators/RenameBoundaryGenerator.html">RenameBoundaryGenerator</a>Changes the boundary IDs and/or boundary names for a given set of boundaries defined by either boundary ID or boundary name. The changes are independent of ordering. The merging of boundaries is supported.</li><li class="collection-item"><a href="../../source/meshgenerators/RinglebMeshGenerator.html">RinglebMeshGenerator</a>Creates a mesh for the Ringleb problem.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetExtruderGenerator.html">SideSetExtruderGenerator</a>Takes a 1D or 2D mesh and extrudes a selected sideset along the specified axis.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsAroundSubdomainGenerator.html">SideSetsAroundSubdomainGenerator</a>Adds element faces that are on the exterior of the given block to the sidesets specified</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsBetweenSubdomainsGenerator.html">SideSetsBetweenSubdomainsGenerator</a>MeshGenerator that creates a sideset composed of the nodes located between two or more subdomains.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromBoundingBoxGenerator.html">SideSetsFromBoundingBoxGenerator</a>Defines new sidesets using currently-defined sideset IDs inside or outside of a bounding box.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromNodeSetsGenerator.html">SideSetsFromNodeSetsGenerator</a>Mesh generator which constructs side sets from node sets</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromNormalsGenerator.html">SideSetsFromNormalsGenerator</a>Adds a new named sideset to the mesh for all faces matching the specified normal.</li><li class="collection-item"><a href="../../source/meshgenerators/SideSetsFromPointsGenerator.html">SideSetsFromPointsGenerator</a>Adds a new sideset starting at the specified point containing all connected element faces with the same normal.</li><li class="collection-item"><a href="../../source/meshgenerators/SmoothMeshGenerator.html">SmoothMeshGenerator</a>Utilizes a simple Laplacian based smoother to attempt to improve mesh quality.  Will not move boundary nodes or nodes along block/subdomain boundaries</li><li class="collection-item"><a href="../../source/meshgenerators/SphereMeshGenerator.html">SphereMeshGenerator</a>Generate a 3-D sphere mesh centered on the origin</li><li class="collection-item"><a href="../../source/meshgenerators/SpiralAnnularMeshGenerator.html">SpiralAnnularMeshGenerator</a>Creates an annular mesh based on TRI3 or TRI6 elements on several rings.</li><li class="collection-item"><a href="../../source/meshgenerators/StackGenerator.html">StackGenerator</a>Use the supplied meshes and stitch them on top of each other</li><li class="collection-item"><a href="../../source/meshgenerators/StitchedMeshGenerator.html">StitchedMeshGenerator</a>Allows multiple mesh files to be stitched together to form a single mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/SubdomainBoundingBoxGenerator.html">SubdomainBoundingBoxGenerator</a>Changes the subdomain ID of elements either (XOR) inside or outside the specified box to the specified ID.</li><li class="collection-item"><a href="../../source/meshgenerators/SubdomainIDGenerator.html">SubdomainIDGenerator</a>Sets all the elements of the input mesh to a unique subdomain ID.</li><li class="collection-item"><a href="../../source/meshgenerators/SymmetryTransformGenerator.html">SymmetryTransformGenerator</a>Applies a symmetry transformation to the entire mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/TiledMeshGenerator.html">TiledMeshGenerator</a>Use the supplied mesh and create a tiled grid by repeating this mesh in the x, y, and z directions.</li><li class="collection-item"><a href="../../source/meshgenerators/TransfiniteMeshGenerator.html">TransfiniteMeshGenerator</a>Creates a QUAD4 mesh given a set of corner vertices and edge types. The edge type can be either LINE, CIRCARC, DISCRETE or PARSED, with LINE as the default option. For the non-default options the user needs to specify additional parameters via the edge_parameter option as follows: for CIRCARC the deviation of the midpoint from an arccircle, for DISCRETE a set of points, or a paramterization via the PARSED option. Opposite edges may have different distributions s long as the number of points is identical. Along opposite edges a different point distribution can be prescribed via the options bias_x or bias_y for opposing edges.</li><li class="collection-item"><a href="../../source/meshgenerators/TransformGenerator.html">TransformGenerator</a>Applies a linear transform to the entire mesh.</li><li class="collection-item"><a href="../../source/meshgenerators/UniqueExtraIDMeshGenerator.html">UniqueExtraIDMeshGenerator</a>Add a new extra element integer ID by finding unique combinations of the existing extra element integer ID values</li><li class="collection-item"><a href="../../source/meshgenerators/XYDelaunayGenerator.html">XYDelaunayGenerator</a>Triangulates meshes within boundaries defined by input meshes.</li><li class="collection-item"><a href="../../source/meshgenerators/XYMeshLineCutter.html">XYMeshLineCutter</a>This XYMeshLineCutter object is designed to trim the input mesh by removing all the elements on one side of a given straight line with special processing on the elements crossed by the cutting line to ensure a smooth cross-section.</li><li class="collection-item"><a href="../../source/mesh/AnnularMesh.html">AnnularMesh</a>For rmin&gt;0: creates an annular mesh of QUAD4 elements.  For rmin=0: creates a disc mesh of QUAD4 and TRI3 elements.  Boundary sidesets are created at rmax and rmin, and given these names.  If dmin!<u>0 and dmax!</u>360, a sector of an annulus or disc is created.  In this case boundary sidesets are also created a dmin and dmax, and given these names</li><li class="collection-item"><a href="../../source/mesh/ConcentricCircleMesh.html">ConcentricCircleMesh</a>This ConcentricCircleMesh source code is to generate concentric circle meshes.</li><li class="collection-item"><a href="../../source/mesh/FileMesh.html">FileMesh</a>Read a mesh from a file.</li><li class="collection-item"><a href="../../source/mesh/GeneratedMesh.html">GeneratedMesh</a>Create a line, square, or cube mesh with uniformly spaced or biased elements.</li><li class="collection-item"><a href="../../source/mesh/ImageMesh.html">ImageMesh</a>Generated mesh with the aspect ratio of a given image stack.</li><li class="collection-item"><a href="../../source/mesh/MeshGeneratorMesh.html">MeshGeneratorMesh</a>Mesh generated using mesh generators</li><li class="collection-item"><a href="../../source/mesh/PatternedMesh.html">PatternedMesh</a>Creates a 2D mesh from a specified set of unique &#x27;tiles&#x27; meshes and a two-dimensional pattern.</li><li class="collection-item"><a href="../../source/mesh/RinglebMesh.html">RinglebMesh</a>Creates a mesh for the Ringleb problem.</li><li class="collection-item"><a href="../../source/mesh/SpiralAnnularMesh.html">SpiralAnnularMesh</a>Creates an annual mesh based on TRI3 elements (it can also be TRI6 elements) on several rings.</li><li class="collection-item"><a href="../../source/mesh/StitchedMesh.html">StitchedMesh</a>Reads in all of the given meshes and stitches them all together into one mesh.</li><li class="collection-item"><a href="../../source/mesh/TiledMesh.html">TiledMesh</a>Use the supplied mesh and create a tiled grid by repeating this mesh in the x,y, and z directions.</li></ul></section><section class="scrollspy" id="7c33cfc4-9da2-46e0-ae6f-de25c724a084" data-section-level="2" data-section-text="Available Subsystems"><h2 id="available-subsystems">Available Subsystems</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="Partitioner/index.html">Partitioner</a></li></ul></section><section class="scrollspy" id="4f317869-9756-43f2-a0b4-b1e23aa5afcd" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/CreateDisplacedProblemAction.html">CreateDisplacedProblemAction</a>Create a Problem object that utilizes displacements.</li><li class="collection-item"><a href="../../source/actions/DisplayGhostingAction.html">DisplayGhostingAction</a>Action to setup AuxVariables and AuxKernels to display ghosting when running in parallel</li><li class="collection-item"><a href="../../source/actions/ElementIDOutputAction.html">ElementIDOutputAction</a>Action for copying extra element IDs into auxiliary variables for output.</li><li class="collection-item"><a href="../../source/actions/SetupMeshAction.html">SetupMeshAction</a>Add or create Mesh object to the simulation.</li><li class="collection-item"><a href="../../source/actions/SetupMeshCompleteAction.html">SetupMeshCompleteAction</a>Perform operations on the mesh in preparation for a simulation.</li><li class="collection-item"><a href="../../source/actions/AddMeshGeneratorAction.html">AddMeshGeneratorAction</a>Add a MeshGenerator object to the simulation.</li></ul></section><section class="scrollspy" id="ca939f05-d486-457a-9db4-967aa36bad11" data-section-level="2" data-section-text="MeshGenerator System"><h2 id="meshgenerator-system">MeshGenerator System</h2><p>The MeshGenerator System is useful for programmatically constructing a mesh. This includes generating the mesh from a serious of points and connectivity, adding features on the fly, linearly transforming the mesh, stitching together pieces of meshes, etc. There are several built-in generators but this system is also extendable. MeshGenerators may or may not consumer the output from other generators and produce a single mesh. They can be chained together through dependencies so that complex meshes may be built up from a series of simple processes.</p><section id="2bed90b7-b10a-45e1-afbf-2d203ebc3f96" data-section-level="3" data-section-text="Mesh Generator development"><h3 id="mesh-generator-development">Mesh Generator development</h3><p>Mesh generator developers should call <code>mesh-&gt;set_isnt_prepared()</code> at the end of the <code>generate</code> routine unless they are confident that their mesh is indeed prepared. Examples of actions that render the mesh unprepared are</p><ul class="browser-default"><li><p>Translating, rotating, or scaling the mesh. This will conceptually change the mesh bounding box, invalidate the point locator, and potentially change the spatial dimension of the mesh (e.g. rotating a line from the x-axis into the xy plane, etc.) </p></li><li><p>Adding elements. These elements will need their neighbor links set in order for things like finite volume to work </p></li><li><p>Changing element subdomains. This will invalidate the mesh subdomain cached data on the <code>libMesh::MeshBase</code> object </p></li><li><p>Changing boundary IDs. This invalidates global data (e.g. data aggregated across all processes) in the <code>libMesh::BoundaryInfo</code> object</p></li></ul><p>When in doubt, the mesh is likely not prepared. Calling <code>set_isnt_prepared</code> is a defensive action that at worst will incur an unnecessary <code>prepare_for_use</code>, which may slow down the simulation setup, and at best may save follow-on mesh generators or simulation execution from undesirable behavior.</p></section><section id="17d9631a-e7f0-4e50-80e6-abd1b95dcbe0" data-section-level="3" data-section-text="DAG and final mesh selection"><h3 id="dag-and-final-mesh-selection">DAG and final mesh selection</h3><p>When chaining together several MeshGenerators, you are implicitly creating a DAG (directed acyclic graph). MOOSE evaluates and generates the individual objects to build up your final mesh. If your input file has multiple end points, (e.g. B-&gt;A and C-&gt;A) then MOOSE will issue an error and terminate. Generally, it doesn&#x27;t make sense to have multiple end points since the output of one would simply be discarded anyway. It is possible to force the selection of a particular end point by using the &quot;final_generator&quot; parameter in the Mesh block. This parameter can be used on any generator whether there is ambiguity or not in the generator dependencies.</p></section></section><section class="scrollspy" id="9d071e7e-9d91-4c36-9050-8d71db609397" data-section-level="2" data-section-text="Outputting The Mesh"><h2 id="outputting-the-mesh">Outputting The Mesh</h2><p>Since MOOSE contains a lot of ability to read/generate/modify meshes - it&#x27;s often useful to be able to run all of the Mesh related portions of the input file and then output the mesh.  This mesh can then be viewed (such as with Peacock) or used in other MOOSE input files for further combination/modification.</p><p>This can be achieved by using the command line option <code>--mesh-only</code>.  By default <code>--mesh-only</code> will write a mesh file with <code>_in.e</code> (the opposite of the <code>_out.e</code> that is appended from the output system) appended to the input file name.  You can also optionally provide a mesh filename to write out using <code>--mesh-only output_file.e</code>. When using the <code>--mesh-only</code> option, by default any extra element integers defined on the mesh will also be outputted to the output Exodus file. To prevent extra element ids from being output, the parameter <code>output_extra_element_ids</code> should be set to <code>false</code> in the <code>[Outputs]</code> block of the input file as shown below:</p><pre class="moose-pre"><code class="language-text">
[Outputs]
  [out]
    type = Exodus
    output_extra_element_ids = false
  []
[]
</code></pre><p>Alternatively, if only a subset of extra element ids should be outputted to the Exodus file, the parameter <code>extra_element_ids_to_output</code> should be set in the <code>[Outputs]</code> block of the input file like so:</p><pre class="moose-pre"><code class="language-text">
[Outputs]
  [out]
    type = Exodus
    output_extra_element_ids = true
    extra_element_ids_to_output = &#x27;id_to_output1 id_to_output2 ...&#x27;
  []
[]
</code></pre><p>Here are a couple of examples showing the usage of <code>--mesh-only</code>:</p><pre class="moose-pre"><code class="language-text">
# Will run all mesh related sections in input_file.i and write out input_file_in.e
./myapp-opt -i input_file.i --mesh-only

# Will do the same but write out mesh_file.e
./myapp-opt -i input_file.i --mesh-only mesh_file.e

# Run in parallel and write out parallel checkpoint format (which can be read as a split)
mpiexec -n 3 ./myapp-opt -i input_file.i Mesh/parallel_type=distributed --mesh-only mesh_file.cpr
</code></pre></section><section class="scrollspy" id="98e0c854-9786-4076-be05-1e5fecd64175" data-section-level="2" data-section-text="Named Entity Support"><h2 id="named-entity-support">Named Entity Support</h2><p>Human-readable names can be assigned to blocks, sidesets, and nodesets. These names will be automatically read in and can be used throughout the input file. Mesh generators such as CUBIT will generally provide the capability internally.  Any parameter that takes entity IDs in the input file will accept either numbers or &quot;names&quot;. Names can also be assigned to IDs on-the-fly in existing meshes to ease input file maintenance (see example). On-the-fly names will also be written to Exodus/XDA/XDR files. An illustration for mesh in exodus file format.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Mesh]
  file = three_block.e

  # These names will be applied on the fly to the
  # mesh so that they can be used in the input file
  # In addition they will show up in the output file
  block_id = &#x27;1 2 3&#x27;
  block_name = &#x27;wood steel copper&#x27;

  boundary_id = &#x27;1 2&#x27;
  boundary_name = &#x27;left right&#x27;
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#386ee1ea-892a-49a3-abf5-87ffe6070596">(moose/test/tests/mesh/named_entities/name_on_the_fly.i)</a></section><section class="scrollspy" id="881464d0-cf08-4b01-a122-427dac36c27a" data-section-level="2" data-section-text="Replicated and Distributed Mesh"><h2 id="replicated-and-distributed-mesh">Replicated and Distributed Mesh</h2><p>The core of the mesh capabilities are derived from <a href="http://libmesh.github.io/">libMesh</a>, which has two underlying parallel mesh formats: &quot;replicated&quot; and &quot;distributed&quot;.</p><p>The replicated mesh format is the default format for MOOSE and is the most appropriate format to utilize for nearly all simulations. In parallel, the replicated format copies the complete mesh to all processors allowing for efficient access to the geometry elements.</p><p>The distributed mesh format is useful when the mesh data structure dominates memory usage. Only the pieces of the mesh &quot;owned&quot; by a processor are actually stored on the processor. If the mesh is too large to read in on a single processor, it can be split prior to the simulation.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>Both the &quot;replicated&quot; and &quot;distributed&quot; mesh formats are parallel with respect to the execution of the finite element assembly and solve. In both types the solution data is distributed, which is the portion of the simulation that usually dominates memory demands.</p></div></div></div><section id="33e0de7a-7dfa-4082-af57-57756d0d3159" data-section-level="3" data-section-text="Distributed Mesh Output Format ( Nemesis )"><h3 id="distributed-mesh-output-format-nemesis">Distributed Mesh Output Format (Nemesis)</h3><p>When running a simulation with <code>DistributedMesh</code> it is generally desirable to avoid serializing the mesh to the first rank for output. In the largest case this may cause your simulation to run out of memory, in smaller cases, it may just cause unnecessary communication to serialize your parallel data structure. The solution is to use &quot;nemesis&quot; output.</p><p>Nemesis creates separate Exodus files that are automatically read by Paraview and displayed as if a normal Exodus mesh had been output. The output files have the following naming convention:</p><pre class="moose-pre"><code class="language-text">
&lt;filename&gt;.e.&lt;num_processors&gt;.&lt;rank&gt;

# For example, on a 4 processor run, you can expect filenames like this:
out.e.4.0
out.e.4.1
out.e.4.2
out.e.4.3
</code></pre></section></section><section class="scrollspy" id="7bfef915-2412-4ca5-b7b4-df33a1e5103d" data-section-level="2" data-section-text="Mesh splitting"><h2 id="mesh-splitting">Mesh splitting</h2><p>For large meshes, MOOSE provides the ability to pre-split a mesh for use in the the &quot;distributed&quot; format/mode. To split and use a mesh for distributed runs:</p><pre class="moose-pre"><code class="language-text">
// For input files with a file-based mesh:
$ moose-app-opt -i your_input-file.i --split-mesh 500,1000,2000 // comma-separated list of split configurations
Splitting 500 ways...
    - writing 500 files per process...
Splitting 1000 ways...
    - writing 1000 files per process...
...

// MOOSE automatically selects the pre-split mesh configuration based on MPI processes
$ mpiexec -n 1000 moose-app-opt -i your_input-file.i --use-split
</code></pre><p>For more details see &quot;<a href="splitting.html">Mesh Splitting</a>&quot;.</p></section><section class="scrollspy" id="fe034578-5be4-4acc-9085-52e109e54eff" data-section-level="2" data-section-text="Displaced Mesh"><h2 id="displaced-mesh">Displaced Mesh</h2><p>Calculations can take place in either the initial mesh configuration or, when requested, the &quot;displaced&quot; configuration. To enable displacements, provide a vector of displacement variable names for each spatial dimension in the &#x27;displacements&#x27; parameters within the Mesh block.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Mesh]
  type = FileMesh
  file = truss_2d.e
  displacements = &#x27;disp_x disp_y&#x27;
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#f26c2267-ce1f-4e0e-867b-a599e4e7cde4">(moose/modules/tensor_mechanics/test/tests/truss/truss_2d.i)</a><p>Once enabled, the any object that should operate on the displaced configuration should set the &quot;use_displaced_mesh&quot; to true. For example, the following snippet enables the computation of a <a href="../Postprocessors/index.html">Postprocessor</a> with and without the displaced configuration.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Postprocessors]
  [./without]
    type = ElementIntegralVariablePostprocessor
    variable = c
    execute_on = initial
  [../]
  [./with]
    type = ElementIntegralVariablePostprocessor
    variable = c
    use_displaced_mesh = true
    execute_on = initial
  [../]
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#1e51bee8-f16f-40ba-9b06-19760dc871dc">(moose/test/tests/postprocessors/displaced_mesh/elemental.i)</a></section><section class="scrollspy" id="4fd9be53-10f2-408c-a77f-a38b33eed336" data-section-level="2" data-section-text="Mixed Dimension Meshes"><h2 id="mixed-dimension-meshes">Mixed Dimension Meshes</h2><p>MOOSE will function properly when running simulations on meshes containing mixed dimension elements (e.g. 1D and 2D, 1D and 3D, etc.). Residual calculation, material evaluation, etc should all work properly.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Mesh]
  file = 1d_3d.e
  # 1d_3d.e contains HEX8 and BEAM2 elements - no additional input file
  # changes are necessary to handle mixed-dim meshes.
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#393cc1e0-88e3-405f-9484-65ecda26c8b0">(moose/test/tests/mesh/mixed_dim/1d_3d.i)</a></section><section class="scrollspy" id="c555a663-ceef-4318-870b-8a5a0b401832" data-section-level="2" data-section-text="Unique IDs"><h2 id="unique-ids">Unique IDs</h2><p>There are two &quot;first-class&quot; id types for each mesh entity (elements or nodes): &quot;id and unique_id&quot;. Both the id and unique_id field are unique numbers for the current active set of mesh entities. Active entities are those that are currently representing the domain but doesn&#x27;t include &quot;coarse parents&quot; of some elements that may become active during a coarsening step. The difference however is that unique_ids are never reused, but ids <strong>might</strong> be. Generally the id is &quot;good-enough&quot; for almost all use, but if you need guarantees that an element id is never recycled (because it might be a key to an important map), you should use unique_id.</p></section><section class="scrollspy" id="7ef7b2bb-9dfb-427d-a442-f7d9822f0fae" data-section-level="2" data-section-text="Periodic Node Map"><h2 id="periodic-node-map">Periodic Node Map</h2><p>The MooseMesh object has a method for building a map (technically a multimap) of paired periodic nodes in the simulation. This map provides a quick lookup of all paired nodes on a periodic boundary. in the 2D and 3D cases each corner node will map to 2 or 3 other nodes (respectively).</p></section><section class="scrollspy" id="6d356711-1c73-463e-b460-87157719b85b" data-section-level="2" data-section-text="Extra integer IDs"><h2 id="extra-integer-ids">Extra integer IDs</h2><p>Extra integer IDs for all the elements of a mesh can be useful for handling complicated material assignment, performing specific calculations on groups of elements, etc. Often times, we do not want to use subdomain IDs for these tasks because otherwise too many subdomains could be needed, and in turn large penalty on run-time performance could be introduced.</p><p>MooseMesh<a href="../../source/mesh/MooseMesh.html">MooseMesh</a> has a parameter <code>extra_integers</code> to allow users to introduce more integer IDs for elements each identified with a name in the parameter. When this parameter is specified, extra integers will be made available for all elements through <code>Assembly</code> in MOOSE objects such as kernels, aux kernels, materials, initial conditions, element user objects, etc. To retrieve the integer on an element, one needs to simply call</p><pre class="moose-pre"><code class="language-text">
getElementID(integer_name_parameter, comp),
</code></pre><p>within the initialization list of your constructor. <code>integer_name_parameter</code> is the name of the parameter in type of <code>std::vector&lt;ExtraElementIDName&gt;</code> of this object listing all integer names. <code>comp</code> is the index into the integer names if multiple are specified for <code>integer_name_parameter</code>. It is noticed that the returned value of this function call must be in type of <code>const dof_id_type &amp;</code>, which is used to refer the value set by MOOSE in <code>Assembly</code>. The returned reference should be held in a class member variable for later use. Based on this ID, one can proceed with any particular operations, for example, choosing a different set of data for evaluating material properties.</p><p>IDs can be assigned to the mesh elements with <code>MeshGenerators</code> in a similar way to assigning subdomain IDs. We note that the element IDs are part of the mesh and will be initialized properly for restart/recover.</p></section><section class="scrollspy" id="b14f8252-1061-44f6-b276-f880884d0c97" data-section-level="2" data-section-text="Mesh meta data"><h2 id="mesh-meta-data">Mesh meta data</h2><p>Mesh generators can declare mesh meta data, which can be obtained later in Actions or in UserObjects. Mesh meta data can only be declared in the constructors of mesh generators so that they can be restarted without re-running mesh generators. Mesh meta data can be useful for setting up specific postprocessors, kernels, etc. that require certain geometry information. Mesh meta data are not possible or extremely hard to be derived directly from libMesh mesh object. A simple example of mesh meta data is the <code>num_elements_x</code> provided by <a href="../../source/meshgenerators/GeneratedMeshGenerator.html">GeneratedMeshGenerator</a>, which can be used as an indicator for a mesh regular in x direction.</p></section><section class="scrollspy" id="e2c9899d-77e2-4235-93a7-697c7aa45657" data-section-level="2" data-section-text="Debugging in - MOOSE mesh generation"><h2 id="troubleshooting">Debugging in-MOOSE mesh generation</h2><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p>The MOOSE mesh generation tutorial is the most comprehensive resource on learning how to mesh within MOOSE. We summarize here only a few techniques.</p></div></div></div><p>Mesh generation in MOOSE is a sequential tree-based process. Mesh generators are executed sorted by dependencies, and the output of each generator may be fed to multiple other generators. To succeed in this process, you must decompose the creation of the mesh into many individual steps. To debug this process, one can:</p><ul class="browser-default"><li><p>use the <code>show_info(=true)</code> input parameter on each mesh generator. This will output numerous pieces of metadata about the mesh at each stage of the generation process. You can check there if all the subdomains that you expected at this stage are present in the mesh and if they are of the expected size, both in terms of number of elements but also bounding box. </p></li><li><p>use the <code>output</code> input parameter on the mesh generator right before the problematic stage. This will output the mesh, by default using the <a href="../../source/outputs/Exodus.html">Exodus</a> format with the name <code>&lt;mesh_generator_name&gt;_in.e</code>, so you may visualize it before it gets acted upon by the next mesh generator(s).</p></li></ul></section><section class="scrollspy" id="da2599df-5f30-48a8-9bb9-124adc563d86" data-section-level="2" data-section-text="Examining meshes"><h2 id="examination">Examining meshes</h2><p>The results of finite element/volume simulations are highly dependent on the quality of the mesh(es) used. It happens regularly that results are excellent and meeting all predictions using a regular Cartesian grid mesh, but significantly deteriorate or do not converge on the real system mesh, often created outside MOOSE.</p><p>We point out in this section a few things to look for. - Sidesets in MOOSE are oriented. If you place a Neumann/flux boundary condition on a sideset, the direction of   the flux will depend on the orientation of the sideset. - MOOSE generally does not support non-conformal meshes for regular kernels, except when they arise from online mesh refinement.   When inspecting your mesh, you should not see any hanging nodes or surfaces not exactly touching. If you are using such   a mesh, you <em></em>MUST** use interface kernels, mortar or other advanced numerical treatments. - Many physics will give better results with high element quality and smooth distributions of element volumes.   You may examine the spatial distribution of these quantities using the <a href="../../source/auxkernels/ElementQualityAux.html">ElementQualityAux</a> and <a href="../../source/auxkernels/VolumeAux.html">VolumeAux</a>   respectively.</p></section><section class="scrollspy" id="f707a1c1-e0da-40da-a88d-ba6012721059" data-section-level="2" data-section-text="Coordinate Systems"><h2 id="coordinate_systems">Coordinate Systems</h2><p>The following are the coordinate systems currently available in MOOSE:</p><ul class="browser-default"><li><p><code>XYZ</code>: 3D Cartesian. </p></li><li><p><code>RZ</code>: 2D axisymmetric coordinates. </p></li><li><p><code>RSPHERICAL</code>: 1D spherical coordinates with the origin at <span class="moose-katex-inline-equation" id="moose-equation-26e71a6e-bcaf-4c46-ad9d-cb6de8f04e04"><script>var element = document.getElementById("moose-equation-26e71a6e-bcaf-4c46-ad9d-cb6de8f04e04");katex.render("(0,0,0)", element, {displayMode:false,throwOnError:false});</script></span>.</p></li></ul><p>Coordinate systems may be specified in the input file or within code.</p><section id="cd5ea970-1b3b-4eb3-b15b-f09c79413d2b" data-section-level="3" data-section-text="Specifying coordinate systems in the input file"><h3 id="specifying-coordinate-systems-in-the-input-file">Specifying coordinate systems in the input file</h3><p>In an input file, coordinate systems may be specified in the <a href="index.html">Mesh</a> block. First, <a href="#f6885a3b-8d7c-4124-b874-ca6da7b2f96f" class="moose-modal-link modal-trigger">&quot;coord_type&quot;</a> is used to specify the coordinate system type. If you would like to use multiple coordinate systems in your application, you can supply multiple entries in this parameter. Then you must specify <a href="#3e657ffd-3180-4451-b3f3-5b684ae2689a" class="moose-modal-link modal-trigger">&quot;coord_block&quot;</a> to specify the corresponding blocks to which each coordinate system applies.</p><p>If the <code>RZ</code> coordinate system is used, there are two options for how to specify the coordinate axis(es) in an input file:</p><ul class="browser-default"><li><p>Specify <a href="#9fdc187a-708e-4a60-a0d7-5424ada85cf0" class="moose-modal-link modal-trigger">&quot;rz_coord_axis&quot;</a> to choose a single <code>RZ</code> coordinate system, using the <span class="moose-katex-inline-equation" id="moose-equation-46b0bc6b-d950-45b5-b007-2dabc0549917"><script>var element = document.getElementById("moose-equation-46b0bc6b-d950-45b5-b007-2dabc0549917");katex.render("\\hat{x}", element, {displayMode:false,throwOnError:false});</script></span> or <span class="moose-katex-inline-equation" id="moose-equation-449c73f7-44f5-401e-a825-eaee66729331"><script>var element = document.getElementById("moose-equation-449c73f7-44f5-401e-a825-eaee66729331");katex.render("\\hat{y}", element, {displayMode:false,throwOnError:false});</script></span> direction and starting at <span class="moose-katex-inline-equation" id="moose-equation-402eb63d-2714-44ae-abd0-de93506af09c"><script>var element = document.getElementById("moose-equation-402eb63d-2714-44ae-abd0-de93506af09c");katex.render("(0,0,0)", element, {displayMode:false,throwOnError:false});</script></span>. If the former is used, then the axial coordinate is <span class="moose-katex-inline-equation" id="moose-equation-92545aca-a753-45a0-b6ed-59ef3e19924d"><script>var element = document.getElementById("moose-equation-92545aca-a753-45a0-b6ed-59ef3e19924d");katex.render("x", element, {displayMode:false,throwOnError:false});</script></span>, and the radial coordinate is <span class="moose-katex-inline-equation" id="moose-equation-27152f7f-4183-431c-a9a9-9114c195992a"><script>var element = document.getElementById("moose-equation-27152f7f-4183-431c-a9a9-9114c195992a");katex.render("y", element, {displayMode:false,throwOnError:false});</script></span>; if the latter is used, these are switched. </p></li><li><p>Specify the following three parameters:</p><ul class="browser-default"><li><p><a href="#96e215b1-cda1-4725-adb5-c33150c57552" class="moose-modal-link modal-trigger">&quot;rz_coord_blocks&quot;</a>: The list of blocks using an <code>RZ</code> coordinate system (all must be specified). </p></li><li><p><a href="#e8e1efb2-b9fe-4f2a-8be8-80efab977ebe" class="moose-modal-link modal-trigger">&quot;rz_coord_origins&quot;</a>: The list of origin points for the axisymmetric axes corresponding to each block in <a href="#b3324384-d70c-4f29-9d5c-f48c8f9fc8d6" class="moose-modal-link modal-trigger">&quot;rz_coord_blocks&quot;</a>. </p></li><li><p><a href="#e8a77a30-6590-42d6-b8a0-40f67f76bb89" class="moose-modal-link modal-trigger">&quot;rz_coord_directions&quot;</a>: The list of direction vectors for the axisymmetric axes corresponding to each block in <a href="#d24b677a-b129-4862-a898-7595429249be" class="moose-modal-link modal-trigger">&quot;rz_coord_blocks&quot;</a>. Note that these direction vectors need not be unit vectors, just nonzero vectors.</p></li></ul></li></ul><p>The second option has greater flexibility, as it allows the following, which the first option does not:</p><ul class="browser-default"><li><p>Multiple axisymmetric coordinate systems can be defined. </p></li><li><p>Any point can be used for the origin of the coordinate system, not just <span class="moose-katex-inline-equation" id="moose-equation-26850db2-545d-42b0-a914-8d48280fbbb7"><script>var element = document.getElementById("moose-equation-26850db2-545d-42b0-a914-8d48280fbbb7");katex.render("(0,0,0)", element, {displayMode:false,throwOnError:false});</script></span>. </p></li><li><p>Any direction can be used for the axisymmetric axis, not just the <span class="moose-katex-inline-equation" id="moose-equation-71a9e0d3-af1e-418c-a4fb-2b6b97bbf23a"><script>var element = document.getElementById("moose-equation-71a9e0d3-af1e-418c-a4fb-2b6b97bbf23a");katex.render("\\hat{x}", element, {displayMode:false,throwOnError:false});</script></span> or <span class="moose-katex-inline-equation" id="moose-equation-df9411c6-aba6-4060-923f-09579ae8c06d"><script>var element = document.getElementById("moose-equation-df9411c6-aba6-4060-923f-09579ae8c06d");katex.render("\\hat{y}", element, {displayMode:false,throwOnError:false});</script></span> direction.</p></li></ul><p>Note that the <a href="../Transfers/index.html">Transfers</a> ability for the second option is more limited</p></section><section id="38f5b597-eab7-4b8f-bb37-ae527006dab9" data-section-level="3" data-section-text="Specifying coordinate systems within code"><h3 id="specifying-coordinate-systems-within-code">Specifying coordinate systems within code</h3><p>To specify coordinate systems within code, <code>MooseMesh::setCoordSystem(blocks, coord_sys)</code> is used, where <code>blocks</code> and <code>coord_sys</code> have the same behavior as the <a href="#f696a786-6e8f-4b84-b953-c835e8461954" class="moose-modal-link modal-trigger">&quot;coord_block&quot;</a> and <a href="#57ff1850-543d-409a-b96a-83e6f43a8fa2" class="moose-modal-link modal-trigger">&quot;coord_type&quot;</a> parameters, respectively.</p><p>If the <code>RZ</code> coordinate system is used, there are two options for how to specify the coordinate axis(es) within the code, just like in the input file:</p><ul class="browser-default"><li><p>Call <code>MooseMesh::setAxisymmetricCoordAxis(rz_coord_axis)</code>, where <code>rz_coord_axis</code> is like <a href="#519b6192-f4ac-4206-afbe-e0e6eebdd5c0" class="moose-modal-link modal-trigger">&quot;rz_coord_axis&quot;</a>. </p></li><li><p>Call <code>MooseMesh::setGeneralAxisymmetricCoordAxes(blocks, axes)</code>, where <code>blocks</code> is similar to <a href="#794172f3-1d15-4d48-aca1-7ccd888cb093" class="moose-modal-link modal-trigger">&quot;rz_coord_blocks&quot;</a> and <code>axes</code> pairs up the origins and directions, similar to combining the parameters <a href="#852dc8ae-4c54-43a6-9d41-ec454e31865f" class="moose-modal-link modal-trigger">&quot;rz_coord_origins&quot;</a> and <a href="#00cd455c-fa54-4993-9f5f-09dd4a5bc132" class="moose-modal-link modal-trigger">&quot;rz_coord_directions&quot;</a>.</p></li></ul></section></section></section><div class="moose-modal modal" id="e40eeb1f-c807-4c68-a1b6-745b8bbb5463"><div class="modal-content"><h4>(moose/test/tests/auxkernels/solution_aux/build.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./square]
    type = GeneratedMeshGenerator
    nx = 2
    ny = 2
    dim = 2
  [../]
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]


[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 3
    value = 2
  [../]
  [./right]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 3
  [../]
[]

[Executioner]
  type = Steady
  solve_type = &#x27;PJFNK&#x27;
  nl_rel_tol = 1e-10
[]

[Outputs]
  exodus = true
  xda = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="386ee1ea-892a-49a3-abf5-87ffe6070596"><div class="modal-content"><h4>(moose/test/tests/mesh/named_entities/name_on_the_fly.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = three_block.e

  # These names will be applied on the fly to the
  # mesh so that they can be used in the input file
  # In addition they will show up in the output file
  block_id = &#x27;1 2 3&#x27;
  block_name = &#x27;wood steel copper&#x27;

  boundary_id = &#x27;1 2&#x27;
  boundary_name = &#x27;left right&#x27;
[]

[Variables]
  active = &#x27;u&#x27;

  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  active = &#x27;diff&#x27;

  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  active = &#x27;left right&#x27;

  [./left]
    type = DirichletBC
    variable = u
    boundary = &#x27;left&#x27;
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = &#x27;right&#x27;
    value = 1
  [../]
[]

[Materials]
  active = empty

  [./empty]
    type = MTMaterial
    block = &#x27;wood steel copper&#x27;
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f26c2267-ce1f-4e0e-867b-a599e4e7cde4"><div class="modal-content"><h4>(moose/modules/tensor_mechanics/test/tests/truss/truss_2d.i)</h4><pre class="moose-pre"><code class="language-text">#
# Truss in two dimensional space
#
# The truss is made of five equilateral triangles supported at each end.
# The truss starts at (0,0).  At (1,0), there is a point load of 25.
# The reactions are therefore
#  Ryleft  = 2/3 * 25 = 16.7
#  Ryright = 1/3 * 25 = 8.33
# The area of each member is 0.8.
# Statics gives the stress in each member.  For example, for element 6 (from
#   (0,0) to (1/2,sqrt(3)/2)), the force is
#   f = 2/3 * 25 * 2/sqrt(3) = 100/3/sqrt(3) (compressive)
#   and the stress is
#   s = -100/3/sqrt(3)/0.8 = -24.06
#

[Mesh]
  type = FileMesh
  file = truss_2d.e
  displacements = &#x27;disp_x disp_y&#x27;
[]

[Variables]
  [./disp_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./disp_y]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[AuxVariables]
  [./axial_stress]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./e_over_l]
    order = CONSTANT
    family = MONOMIAL
  [../]
  [./area]
    order = CONSTANT
    family = MONOMIAL
#    initial_condition = 1.0
  [../]
  [./react_x]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_y]
    order = FIRST
    family = LAGRANGE
  [../]
  [./react_z]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Functions]
  [./x2]
    type = PiecewiseLinear
    x = &#x27;0  1 2 3&#x27;
    y = &#x27;0 .5 1 1&#x27;
  [../]
  [./y2]
    type = PiecewiseLinear
    x = &#x27;0 1  2 3&#x27;
    y = &#x27;0 0 .5 1&#x27;
  [../]
[]

[BCs]
  [./fixx1]
    type = DirichletBC
    variable = disp_x
    boundary = 1
    value = 0
  [../]
  [./fixy1]
    type = DirichletBC
    variable = disp_y
    boundary = 1
    value = 0
  [../]

  [./fixy4]
    type = DirichletBC
    variable = disp_y
    boundary = 4
    value = 0
  [../]
[]

[DiracKernels]
  [./pull]
    type = ConstantPointSource
    value = -25
    point = &#x27;1 0 0&#x27;
    variable = disp_y
  [../]
[]

[AuxKernels]
  [./axial_stress]
    type = MaterialRealAux
    block = 1
    property = axial_stress
    variable = axial_stress
  [../]
  [./e_over_l]
    type = MaterialRealAux
    block = 1
    property = e_over_l
    variable = e_over_l
  [../]
  [./area]
    type = ConstantAux
    block = 1
    variable = area
    value = 0.8
    execute_on = &#x27;initial timestep_begin&#x27;
  [../]
[]

[Preconditioning]
  [./SMP]
    type = SMP
    full = true
  [../]
[]

[Executioner]
  type = Transient

  solve_type = PJFNK

  petsc_options_iname = &#x27;-pc_type -ksp_gmres_restart&#x27;
  petsc_options_value = &#x27;jacobi   101&#x27;

  nl_max_its = 15
  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10

  dt = 1
  num_steps = 1
  end_time = 1
[]

[Kernels]
  [./solid_x]
    type = StressDivergenceTensorsTruss
    block = 1
    displacements = &#x27;disp_x disp_y&#x27;
    component = 0
    variable = disp_x
    area = area
    save_in = react_x
  [../]
  [./solid_y]
    type = StressDivergenceTensorsTruss
    block = 1
    displacements = &#x27;disp_x disp_y&#x27;
    component = 1
    variable = disp_y
    area = area
    save_in = react_y
  [../]
[]

[Materials]
  [./linelast]
    type = LinearElasticTruss
    block = 1
    youngs_modulus = 1e6
    displacements = &#x27;disp_x disp_y&#x27;
  [../]
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="1e51bee8-f16f-40ba-9b06-19760dc871dc"><div class="modal-content"><h4>(moose/test/tests/postprocessors/displaced_mesh/elemental.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
  displacements = &#x27;ux uy&#x27;
[]

[AuxVariables]
  [./ux]
    [./InitialCondition]
      type = FunctionIC
      function = x
    [../]
  [../]
  [./uy]
    [./InitialCondition]
      type = FunctionIC
      function = y
    [../]
  [../]
  [./c]
    initial_condition = 1
  [../]
[]

[Variables]
  [./a]
  [../]
[]
[Kernels]
  [./a]
    type = Diffusion
    variable = a
  [../]
[]

[Postprocessors]
  [./without]
    type = ElementIntegralVariablePostprocessor
    variable = c
    execute_on = initial
  [../]
  [./with]
    type = ElementIntegralVariablePostprocessor
    variable = c
    use_displaced_mesh = true
    execute_on = initial
  [../]
[]

[Problem]
  solve = false
[]

[Executioner]
  type = Transient
  num_steps = 0
[]

[Outputs]
  [./out]
    type = Exodus
  [../]
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="393cc1e0-88e3-405f-9484-65ecda26c8b0"><div class="modal-content"><h4>(moose/test/tests/mesh/mixed_dim/1d_3d.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  file = 1d_3d.e
  # 1d_3d.e contains HEX8 and BEAM2 elements - no additional input file
  # changes are necessary to handle mixed-dim meshes.
[]

[Variables]
  [./u]
    order = FIRST
    family = LAGRANGE
  [../]
[]

[Kernels]
  [./diff]
    type = Diffusion
    variable = u
  [../]
[]

[BCs]
  [./left]
    type = DirichletBC
    variable = u
    boundary = 4
    value = 0
  [../]

  [./right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 1
  [../]

  [./bottom]
    type = DirichletBC
    variable = u
    boundary = 100
    value = 0
  [../]

  [./top]
    type = DirichletBC
    variable = u
    boundary = 101
    value = 1
  [../]
[]

[Executioner]
  type = Steady

  solve_type = &#x27;PJFNK&#x27;
[]

[Outputs]
  file_base = 1d_3d_out
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="f6885a3b-8d7c-4124-b874-ca6da7b2f96f"><div class="modal-content"><h4>coord_type</h4><p class="moose-parameter-description-default"><span>Default:</span>XYZ</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>XYZ, RZ, RSPHERICAL</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Type of the coordinate system per block param</p></div></div><div class="moose-modal modal" id="3e657ffd-3180-4451-b3f3-5b684ae2689a"><div class="modal-content"><h4>coord_block</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Block IDs for the coordinate systems. If this parameter is specified, then it must encompass all the subdomains on the mesh.</p></div></div><div class="moose-modal modal" id="9fdc187a-708e-4a60-a0d7-5424ada85cf0"><div class="modal-content"><h4>rz_coord_axis</h4><p class="moose-parameter-description-default"><span>Default:</span>Y</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>X, Y</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The rotation axis (X | Y) for axisymmetric coordinates</p></div></div><div class="moose-modal modal" id="96e215b1-cda1-4725-adb5-c33150c57552"><div class="modal-content"><h4>rz_coord_blocks</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Blocks using general axisymmetric coordinate systems</p></div></div><div class="moose-modal modal" id="e8e1efb2-b9fe-4f2a-8be8-80efab977ebe"><div class="modal-content"><h4>rz_coord_origins</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;libMesh::Point&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Axis origin points for each block in 'rz_coord_blocks'</p></div></div><div class="moose-modal modal" id="b3324384-d70c-4f29-9d5c-f48c8f9fc8d6"><div class="modal-content"><h4>rz_coord_blocks</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Blocks using general axisymmetric coordinate systems</p></div></div><div class="moose-modal modal" id="e8a77a30-6590-42d6-b8a0-40f67f76bb89"><div class="modal-content"><h4>rz_coord_directions</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;libMesh::VectorValue&lt;double&gt;&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Axis directions for each block in 'rz_coord_blocks'</p></div></div><div class="moose-modal modal" id="d24b677a-b129-4862-a898-7595429249be"><div class="modal-content"><h4>rz_coord_blocks</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Blocks using general axisymmetric coordinate systems</p></div></div><div class="moose-modal modal" id="f696a786-6e8f-4b84-b953-c835e8461954"><div class="modal-content"><h4>coord_block</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Block IDs for the coordinate systems. If this parameter is specified, then it must encompass all the subdomains on the mesh.</p></div></div><div class="moose-modal modal" id="57ff1850-543d-409a-b96a-83e6f43a8fa2"><div class="modal-content"><h4>coord_type</h4><p class="moose-parameter-description-default"><span>Default:</span>XYZ</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>XYZ, RZ, RSPHERICAL</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Type of the coordinate system per block param</p></div></div><div class="moose-modal modal" id="519b6192-f4ac-4206-afbe-e0e6eebdd5c0"><div class="modal-content"><h4>rz_coord_axis</h4><p class="moose-parameter-description-default"><span>Default:</span>Y</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>X, Y</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The rotation axis (X | Y) for axisymmetric coordinates</p></div></div><div class="moose-modal modal" id="794172f3-1d15-4d48-aca1-7ccd888cb093"><div class="modal-content"><h4>rz_coord_blocks</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;SubdomainName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Blocks using general axisymmetric coordinate systems</p></div></div><div class="moose-modal modal" id="852dc8ae-4c54-43a6-9d41-ec454e31865f"><div class="modal-content"><h4>rz_coord_origins</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;libMesh::Point&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Axis origin points for each block in 'rz_coord_blocks'</p></div></div><div class="moose-modal modal" id="00cd455c-fa54-4993-9f5f-09dd4a5bc132"><div class="modal-content"><h4>rz_coord_directions</h4><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;libMesh::VectorValue&lt;double&gt;&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Axis directions for each block in 'rz_coord_blocks'</p></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#eaabe8e1-2a99-4433-b5a9-20f54926d1f1" class="tooltipped" data-position="left" data-tooltip="Overview">Overview</a></li><li><a href="#d3d645f9-9f26-42ff-bfd4-b6a5b9546b1a" class="tooltipped" data-position="left" data-tooltip="Example Syntax and Mesh Objects">Example Syntax and Mesh Objects</a></li><li><a href="#1b760fcb-d0e6-4d3b-be1a-52afb3bd3465" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#7c33cfc4-9da2-46e0-ae6f-de25c724a084" class="tooltipped" data-position="left" data-tooltip="Available Subsystems">Available Subsystems</a></li><li><a href="#4f317869-9756-43f2-a0b4-b1e23aa5afcd" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li><li><a href="#ca939f05-d486-457a-9db4-967aa36bad11" class="tooltipped" data-position="left" data-tooltip="MeshGenerator System">MeshGenerator System</a></li><li><a href="#9d071e7e-9d91-4c36-9050-8d71db609397" class="tooltipped" data-position="left" data-tooltip="Outputting The Mesh">Outputting The Mesh</a></li><li><a href="#98e0c854-9786-4076-be05-1e5fecd64175" class="tooltipped" data-position="left" data-tooltip="Named Entity Support">Named Entity Support</a></li><li><a href="#881464d0-cf08-4b01-a122-427dac36c27a" class="tooltipped" data-position="left" data-tooltip="Replicated and Distributed Mesh">Replicated and Distributed Mesh</a></li><li><a href="#7bfef915-2412-4ca5-b7b4-df33a1e5103d" class="tooltipped" data-position="left" data-tooltip="Mesh splitting">Mesh splitting</a></li><li><a href="#fe034578-5be4-4acc-9085-52e109e54eff" class="tooltipped" data-position="left" data-tooltip="Displaced Mesh">Displaced Mesh</a></li><li><a href="#4fd9be53-10f2-408c-a77f-a38b33eed336" class="tooltipped" data-position="left" data-tooltip="Mixed Dimension Meshes">Mixed Dimension Meshes</a></li><li><a href="#c555a663-ceef-4318-870b-8a5a0b401832" class="tooltipped" data-position="left" data-tooltip="Unique IDs">Unique IDs</a></li><li><a href="#7ef7b2bb-9dfb-427d-a442-f7d9822f0fae" class="tooltipped" data-position="left" data-tooltip="Periodic Node Map">Periodic Node Map</a></li><li><a href="#6d356711-1c73-463e-b460-87157719b85b" class="tooltipped" data-position="left" data-tooltip="Extra integer IDs">Extra integer IDs</a></li><li><a href="#b14f8252-1061-44f6-b276-f880884d0c97" class="tooltipped" data-position="left" data-tooltip="Mesh meta data">Mesh meta data</a></li><li><a href="#e2c9899d-77e2-4235-93a7-697c7aa45657" class="tooltipped" data-position="left" data-tooltip="Debugging in - MOOSE mesh generation">Debugging in - MOOSE mesh generation</a></li><li><a href="#da2599df-5f30-48a8-9bb9-124adc563d86" class="tooltipped" data-position="left" data-tooltip="Examining meshes">Examining meshes</a></li><li><a href="#f707a1c1-e0da-40da-a88d-ba6012721059" class="tooltipped" data-position="left" data-tooltip="Coordinate Systems">Coordinate Systems</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>