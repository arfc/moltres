<!DOCTYPE html><head><meta charset="UTF-8"><title>AuxKernels System | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="94364426-7269-4a20-8ccf-9d9c4c5c2930" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="005af893-e120-4ee3-96d6-5a6b19afd64e" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a37d3a25-7cb0-4c4d-8ead-adb7740a9652" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="c5e5c195-69a0-4915-83fb-8a43ff8754d2"><i class="material-icons">menu</i></a><ul class="sidenav" id="c5e5c195-69a0-4915-83fb-8a43ff8754d2"><li><a href="#!" class="dropdown-trigger" data-target="28dd8fa2-80ec-4b0a-bc82-24a28dd09189" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="78ff940f-5199-4489-ad6c-7fb236de0662" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="65f8b142-453e-4262-ac22-19a133790cac" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="94364426-7269-4a20-8ccf-9d9c4c5c2930"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="005af893-e120-4ee3-96d6-5a6b19afd64e"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="a37d3a25-7cb0-4c4d-8ead-adb7740a9652"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="28dd8fa2-80ec-4b0a-bc82-24a28dd09189"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="78ff940f-5199-4489-ad6c-7fb236de0662"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="65f8b142-453e-4262-ac22-19a133790cac"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">AuxKernels</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="10183d2b-95ed-461e-b5e6-9291fc372a0e" data-section-level="1" data-section-text="AuxKernels System"><h1 id="auxkernels-system">AuxKernels System</h1><p>The AuxKernel system mimics the <a href="../Kernels/index.html">Kernels System</a> but compute values that can be defined explicitly with a known function. There are two main use cases for AuxKerenel system: computing a quantity that varies with space and time for postprocessing purposes or for decoupling systems of equations. Examples for both of these use cases shall be discussed further in the following sections.</p><p>Creating a custom AuxKernel object is done by creating a new C++ object that inherits from <code>AuxKernel</code>, <code>VectorAuxKernel</code> or <code>ArrayAuxKernel</code> and overriding the <code>computeValue</code> method, which returns a scalar (<code>Real</code>), vector (<code>RealVectorValue</code>) or a Eigen vector (<code>RealEigenVector</code>) for the two types respectively. A forth type (<code>AuxScalarKernel</code>) also exists, but the syntax for these objects is different and detailed in the <a href="../AuxScalarKernels/index.html">AuxScalarKernels System</a>.</p><p>AuxKernel objects, like Kernel objects, must operate on a variable. Thus, there is a required parameter (&quot;variable&quot;) that indicates the variable that the AuxKernel object is computing. These variables are defined in the <a href="../AuxVariables/index.html">AuxVariables</a> block of the input file. AuxKernel objects derived from <code>AuxKernel</code>, <code>VectorAuxKernel</code> or <code>ArrayAuxKernel</code> operate on standard scalar, vector or array field variables respectively. For example the following input file snippet creates an auxiliary variable suitable for use with an <code>VectorAuxKernel</code>.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[AuxVariables]
  [vec]
    family = LAGRANGE_VEC
    order = FIRST
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#057c6d2f-c883-4b4a-a268-78163e1b06b9">(moose/test/tests/auxkernels/vector_function_aux/vector_function_aux.i)</a><section class="scrollspy" id="43061287-d3ce-4fe4-bd10-5ddb70da06e2" data-section-level="2" data-section-text="Nodal vs Elemental AuxKernel Objects"><h2 id="nodal-vs-elemental-auxkernel-objects">Nodal vs Elemental AuxKernel Objects</h2><p>There are two flavors of AuxKernel objects: nodal and elemental. The distinction is based on the type of variable that is being operated on by the object. If the variable family is <code>LAGRANGE</code> or <code>LAGRANGE_VEC</code> then the AuxKernel will behave as nodal. If the variable family is <code>MONOMIAL</code> then the AuxKernel will behave as an elemental.</p><p>The difference is based on how the <code>computeValue</code> method of the object is called when the kernel is executed. In the nodal case the <code>computeValue</code> method will be executed on each <strong>node</strong> within the finite element mesh and the value returned from the method will directly assign the value of the shape function at that node.</p><p>In the elemental case the <code>computeValue</code> method will be executed on each quadrature point of an <strong>element</strong> of the finite element mesh. The values computed at the quadrature points are used to perform the correct finite element interpolation automatically and set the values for the degrees of freedom. Typically, in the elemental case the order of the monomial finite element is set to constant so there is a single DOF per element, but higher monomials are also supported.</p><p>As is evident by the functionality detailed, the distinction between the two arises from the nature of the finite element shape functions. For Lagrange shape functions the DOF values correspond with the nodes, while for elemental shape functions the DOF values are not associated with nodes.</p><p>The same AuxKernel object can be designed work both as elemental or nodal, for example the <code>computeValue</code> method for the <a href="../../source/auxkernels/FunctionAux.html">FunctionAux</a> object properly handles using the correct spatial location based on if the object is nodal or elemental with the <code>isNodal</code> method.</p></section><section class="scrollspy" id="bd491f57-8644-4644-b77b-e5f38c298f11" data-section-level="2" data-section-text="Block vs Boundary Restricted AuxKernel Objects"><h2 id="block-vs-boundary-restricted-auxkernel-objects">Block vs Boundary Restricted AuxKernel Objects</h2><p>While auxiliary variables are always defined on mesh subdomains, MOOSE allows auxiliary kernels to be either block (mesh subdomain) or boundary restricted. When an auxiliary kernel is boundary restricted, it evaluates an auxiliary variable only on the designated boundaries. Because of this, the auxiliary variable will only have meaningful values on the boundaries even though it is defined on mesh subdomains. When an auxiliary kernel is block restricted, the variable that it evaluates must be defined on a subdomain covering the blocks where the auxiliary kernel is defined. When an auxiliary kernel is boundary restricted, the variable must be defined on a subdomain that all the sides on the boundaries are connected with. An elemental auxiliary variable defined on an element that has multiple boundary sides cannot be properly evaluated within a boundary restricted auxiliary kernel because elemental auxiliary variables can only store one value per element. Users can split the boundaries and define multiple elemental auxiliary variables for each split to avoid the situation of element connecting with multiple boundary sides.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">Real
FunctionAux::computeValue()
{
  if (isNodal())
    return _func.value(_t, *_current_node);
  else
    return _func.value(_t, _q_point[_qp]);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#be6a2641-d8f5-4c46-9951-00521b78e0a8">(moose/framework/src/auxkernels/FunctionAux.C)</a><p>Nodal AuxKernel objects abuse the notion of quadrature points, the <code>_qp</code> member variable is set to zero, but still must be used to access coupled variable values and material properties. This is done to allow the syntax to be consistent regardless of the AuxKernel flavor: nodal or elemental.</p></section><section class="scrollspy" id="982ceb48-defa-4f1b-b591-dbdb9b1b1d20" data-section-level="2" data-section-text="Mortar Nodal Auxiliary Kernel Objects"><h2 id="mortar-nodal-auxiliary-kernel-objects">Mortar Nodal Auxiliary Kernel Objects</h2><p>In order to compute properties in the mortar sense, it is necessary to loop over the mortar segment mesh to spatially integrate variables. <code>MortarNodalAuxKernel</code>s offer this functionality where these &quot;weighted&quot; variables, which intervene in the computation of contact constraints and their residuals, can be coupled to generate the desired ouput value.  Therefore, if postprocessing of mortar quantities is required, nodal mortar auxiliary kernels can be employed.  Objects inheriting from <code>MortarNodalAuxKernel</code> allow for said operations on the mortar lower-dimensional domains featuring similar functionality to other nodal auxiliary kernels, including the possibility of computing quantities in an <code>incremental</code> manner.   ## Execute Flags</p><p>AuxKernel objects inherit from the <a href="../../source/interfaces/SetupInterface.html">SetupInterface (execute_on)</a> so they include the &quot;execute_on&quot; variable. By default this parameter is set to <code>EXEC_LINEAR</code> and <code>EXEC_TIMESTEP_END</code>. The <code>EXEC_LINEAR</code> flag is set because it is possible to couple values compute by an AuxKernel object to other objects such as Kernel or Material objects that are used in the residual calculation. In order to ensure that the values from the auxiliary variable are correct during the iterative solve they are computed for each iteration.</p><p>However, if the auxiliary variable be computed is not being coupled to objects computing the residual evaluating the AuxKernel on each linear iteration is not necessary and can slow down the execution of a simulation. In this case, the <code>EXEC_LINEAR</code> flag should be removed. Likely the <code>EXEC_INITIAL</code> flag should be added to perform the auxiliary variable calculation during the initial setup phase as well.</p></section><section class="scrollspy" id="8dba49fb-9c20-49b4-a2fd-87c90935276a" data-section-level="2" data-section-text="Example A : Post processing with AuxKernel"><h2 id="example-a-post-processing-with-auxkernel">Example A: Post processing with AuxKernel</h2><p>The following example is extracted from step 4 of the Darcy Flow and Thermomechanics Tutorial. Consider Darcy&#x27;s Law for flow in porous media neglecting changes in time and gravity:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-f2713235-6851-47e1-baad-545c0bf51317"></span><span class="moose-katex-equation-number">(1)</span><script>var element = document.getElementById("moose-equation-f2713235-6851-47e1-baad-545c0bf51317");katex.render(" -\\nabla\\cdot\\frac{\\mathbf{K}}{\\mu}\\nabla p = 0,", element, {displayMode:true,throwOnError:false});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-4bebe271-8d8e-4140-86fd-9ec070edb6f7"><script>var element = document.getElementById("moose-equation-4bebe271-8d8e-4140-86fd-9ec070edb6f7");katex.render("\\mathbf{K}", element, {displayMode:false,throwOnError:false});</script></span> is the permeability tensor, <span class="moose-katex-inline-equation" id="moose-equation-81a395b1-c498-4bbb-8955-83fe93ca5879"><script>var element = document.getElementById("moose-equation-81a395b1-c498-4bbb-8955-83fe93ca5879");katex.render("\\mu", element, {displayMode:false,throwOnError:false});</script></span> is the fluid viscosity, and <span class="moose-katex-inline-equation" id="moose-equation-74dd28cb-7966-4c38-8dad-d98bab266911"><script>var element = document.getElementById("moose-equation-74dd28cb-7966-4c38-8dad-d98bab266911");katex.render("p", element, {displayMode:false,throwOnError:false});</script></span> is the pressure and the velocity (<span class="moose-katex-inline-equation" id="moose-equation-985e95c5-0ff0-494e-a9d6-0d2aa18b2dbf"><script>var element = document.getElementById("moose-equation-985e95c5-0ff0-494e-a9d6-0d2aa18b2dbf");katex.render("\\vec{u}", element, {displayMode:false,throwOnError:false});</script></span>) may be computed as:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-86d5f5c6-286e-429f-8030-f9d722869ac3"></span><span class="moose-katex-equation-number">(2)</span><script>var element = document.getElementById("moose-equation-86d5f5c6-286e-429f-8030-f9d722869ac3");katex.render(" \\vec{u} = \\frac{\\mathbf{K}}{\\mu}\\nabla p.", element, {displayMode:true,throwOnError:false});</script></span></p><p>The left-hand side of <a href="#moose-equation-f2713235-6851-47e1-baad-545c0bf51317">Eq. (1)</a> would be solved with a nonlinear variable and an appropriate <a href="../Kernels/index.html">Kernel object</a>. The AuxKernel system can be used computing the velocity following <a href="#moose-equation-86d5f5c6-286e-429f-8030-f9d722869ac3">Eq. (2)</a>. In the tutorial the exact calculation is performed using the DarcyVelocity object, the header and source files for this object are listed below.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#pragma once

#include &quot;AuxKernel.h&quot;

/**
 * Auxiliary kernel responsible for computing the Darcy velocity given
 * several fluid properties and the pressure gradient.
 */
class DarcyVelocity : public VectorAuxKernel
{
public:
  static InputParameters validParams();

  DarcyVelocity(const InputParameters &amp; parameters);

protected:
  /**
   * AuxKernels MUST override computeValue.  computeValue() is called on
   * every quadrature point.  For Nodal Auxiliary variables those quadrature
   * points coincide with the nodes.
   */
  virtual RealVectorValue computeValue() override;

  /// The gradient of a coupled variable
  const VariableGradient &amp; _pressure_gradient;

  /// Holds the permeability and viscosity from the material system
  const ADMaterialProperty&lt;Real&gt; &amp; _permeability;
  const ADMaterialProperty&lt;Real&gt; &amp; _viscosity;
};
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#72a008e7-3604-4424-bf76-e1bbca15b8c3">(moose/tutorials/darcy_thermo_mech/step04_velocity_aux/include/auxkernels/DarcyVelocity.h)</a><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#include &quot;DarcyVelocity.h&quot;

#include &quot;metaphysicl/raw_type.h&quot;

registerMooseObject(&quot;DarcyThermoMechApp&quot;, DarcyVelocity);

InputParameters
DarcyVelocity::validParams()
{
  InputParameters params = VectorAuxKernel::validParams();

  // Add a &quot;coupling paramater&quot; to get a variable from the input file.
  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The pressure field.&quot;);

  return params;
}

DarcyVelocity::DarcyVelocity(const InputParameters &amp; parameters)
  : VectorAuxKernel(parameters),

    // Get the gradient of the variable
    _pressure_gradient(coupledGradient(&quot;pressure&quot;)),

    // Set reference to the permeability MaterialProperty.
    // Only AuxKernels operating on Elemental Auxiliary Variables can do this
    _permeability(getADMaterialProperty&lt;Real&gt;(&quot;permeability&quot;)),

    // Set reference to the viscosity MaterialProperty.
    // Only AuxKernels operating on Elemental Auxiliary Variables can do this
    _viscosity(getADMaterialProperty&lt;Real&gt;(&quot;viscosity&quot;))
{
}

RealVectorValue
DarcyVelocity::computeValue()
{
  // Access the gradient of the pressure at this quadrature point, then pull out the &quot;component&quot; of
  // it requested (x, y or z). Note, that getting a particular component of a gradient is done using
  // the parenthesis operator.
  return -MetaPhysicL::raw_value(_permeability[_qp] / _viscosity[_qp]) * _pressure_gradient[_qp];
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#daaf05c0-3ac7-4520-a9a4-e68b58284583">(moose/tutorials/darcy_thermo_mech/step04_velocity_aux/src/auxkernels/DarcyVelocity.C)</a></section><section class="scrollspy" id="923dae85-a575-4002-bd81-10c6c03b641f" data-section-level="2" data-section-text="Example B : Decoupling Equations"><h2 id="example-b-decoupling-equations">Example B: Decoupling Equations</h2><p>Auxiliary variables may be used interchangeably with nonlinear variables with respect to coupling allowing complicated systems of equations to be decoupled for solving individually. This is very useful for testing and validation.</p><p>Consider the heat equation with an advective term that is coupled to the pressure computed in <a href="#moose-equation-f2713235-6851-47e1-baad-545c0bf51317">Eq. (1)</a> as in step 6 of the Darcy Flow and Thermomechanics Tutorial:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-9395f6da-4360-48fe-8608-5db40a5ba4f5"></span><span class="moose-katex-equation-number">(3)</span><script>var element = document.getElementById("moose-equation-9395f6da-4360-48fe-8608-5db40a5ba4f5");katex.render(" C\\left( \\frac{\\partial T}{\\partial t} + \\epsilon \\vec{u}\\cdot\\nabla T \\right) - \\nabla \\cdot k \\nabla T = 0,", element, {displayMode:true,throwOnError:false});</script></span> where <span class="moose-katex-inline-equation" id="moose-equation-49a85e1d-5581-474a-bfec-e3c6c92593ed"><script>var element = document.getElementById("moose-equation-49a85e1d-5581-474a-bfec-e3c6c92593ed");katex.render("T", element, {displayMode:false,throwOnError:false});</script></span> is temperature, <span class="moose-katex-inline-equation" id="moose-equation-c38f8b97-7107-45fc-9cc8-dbc2be4ad39d"><script>var element = document.getElementById("moose-equation-c38f8b97-7107-45fc-9cc8-dbc2be4ad39d");katex.render("C", element, {displayMode:false,throwOnError:false});</script></span> is the heat capacity, <span class="moose-katex-inline-equation" id="moose-equation-1980062e-4722-4ac0-9a3f-eb632126a71c"><script>var element = document.getElementById("moose-equation-1980062e-4722-4ac0-9a3f-eb632126a71c");katex.render("k", element, {displayMode:false,throwOnError:false});</script></span> is the thermal conductivity, and <span class="moose-katex-inline-equation" id="moose-equation-7d3e00aa-2300-4c53-94a0-dc0208952877"><script>var element = document.getElementById("moose-equation-7d3e00aa-2300-4c53-94a0-dc0208952877");katex.render("\\epsilon", element, {displayMode:false,throwOnError:false});</script></span> is the porosity. The advective term (<span class="moose-katex-inline-equation" id="moose-equation-e247cfd5-5bf8-4680-91e2-cc800086f616"><script>var element = document.getElementById("moose-equation-e247cfd5-5bf8-4680-91e2-cc800086f616");katex.render("\\epsilon\\vec{u}\\cdot\\nabla T", element, {displayMode:false,throwOnError:false});</script></span>) is computed in a kernel object (<a class="moose-source-filename tooltipped modal-trigger" href="#3d51ca6d-711c-4ae1-bef2-c69f11819c20">(moose/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/kernels/DarcyAdvection.C)</a>) and requires the pressure variable be provided as a variable:</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The variable representing the pressure.&quot;);
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#be1f4391-284c-4c59-ae72-8822a97ed296">(moose/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/kernels/DarcyAdvection.C)</a><p>For testing purposes is it not desirable to include the solve for the pressure variable when examining the correctness of the heat equation solve, so an auxiliary variable that is assigned an arbitrary function of space and time is used instead. The following input file snippet demonstrates the decoupling of the pressure variable by computing it using an AuxVariable the FunctionAux object.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[AuxVariables]
  [pressure]
  []
[]

[AuxKernels]
  [pressure]
    type = FunctionAux
    variable = pressure
    function = &#x27;t*x*x*y&#x27;
    execute_on = timestep_end
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#df43128c-03e9-4d87-a532-909cd2db3f85">(moose/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/problems/step6c_decoupled.i)</a></section><section class="scrollspy" id="09eb7a8c-583d-48d4-be1d-b6b19a34fe4c" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/auxkernels/DivergenceAux.html">ADDivergenceAux</a>Computes the divergence of a vector of functors.</li><li class="collection-item"><a href="../../source/auxkernels/FunctorElementalAux.html">ADFunctorElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="../../source/auxkernels/FunctorVectorElementalAux.html">ADFunctorVectorElementalAux</a>Evaluates a vector functor (material property usually) on the current element.For finite volume, this evaluates the vector functor at the centroid.</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRankTwoTensorAux.html">ADMaterialRankTwoTensorAux</a>Access a component of a RankTwoTensor for automatic material property output</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealAux.html">ADMaterialRealAux</a>Outputs element volume-averaged material properties</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealVectorValueAux.html">ADMaterialRealVectorValueAux</a>Capture a component of a vector material property in an auxiliary variable.</li><li class="collection-item"><a href="../../source/auxkernels/MaterialStdVectorAux.html">ADMaterialStdVectorAux</a>Extracts a component of a material type std::vector&lt;Real&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="../../source/auxkernels/TimeDerivativeAux.html">ADTimeDerivativeAux</a>Returns the time derivative of the specified variable/functor as an auxiliary variable.</li><li class="collection-item"><a href="../../source/auxkernels/VectorMaterialRealVectorValueAux.html">ADVectorMaterialRealVectorValueAux</a>Converts a vector-quantity material property into a vector auxiliary variable</li><li class="collection-item"><a href="../../source/auxkernels/ArrayVariableComponent.html">ArrayVariableComponent</a>Copy a component of an array variable.</li><li class="collection-item"><a href="../../source/auxkernels/BuildArrayVariableAux.html">BuildArrayVariableAux</a>Combines multiple standard variables into an array variable.</li><li class="collection-item"><a href="../../source/auxkernels/ConstantAux.html">ConstantAux</a>Creates a constant field in the domain.</li><li class="collection-item"><a href="../../source/auxkernels/ConstantBoundsAux.html">ConstantBoundsAux</a>Provides constant bound of a variable for the PETSc&#x27;s variational inequalities solver</li><li class="collection-item"><a href="../../source/auxkernels/DebugResidualAux.html">DebugResidualAux</a>Populate an auxiliary variable with the residual contribution of a variable.</li><li class="collection-item"><a href="../../source/auxkernels/DiffusionFluxAux.html">DiffusionFluxAux</a>Compute components of flux vector for diffusion problems <span class="moose-katex-inline-equation" id="moose-equation-3155c6a3-1122-45ba-bcb1-2d096c590579"><script>var element = document.getElementById("moose-equation-3155c6a3-1122-45ba-bcb1-2d096c590579");katex.render("(\\vec{J} = -D \\nabla C)", element, {displayMode:false,throwOnError:false});</script></span>.</li><li class="collection-item"><a href="../../source/auxkernels/DivergenceAux.html">DivergenceAux</a>Computes the divergence of a vector of functors.</li><li class="collection-item"><a href="../../source/auxkernels/ExtraElementIDAux.html">ElemExtraIDAux</a>Puts element extra IDs into an aux variable.</li><li class="collection-item"><a href="../../source/auxkernels/ElementH1ErrorFunctionAux.html">ElementH1ErrorFunctionAux</a>Computes the H1 or W^{1,p} error between an exact function and a coupled variable.</li><li class="collection-item"><a href="../../source/auxkernels/ElementIntegerAux.html">ElementIntegerAux</a>Creates a field showing the element integer.</li><li class="collection-item"><a href="../../source/auxkernels/ElementL2ErrorFunctionAux.html">ElementL2ErrorFunctionAux</a>A class for computing the element-wise L^2 (Euclidean) error between a function and a coupled variable.</li><li class="collection-item"><a href="../../source/auxkernels/ElementLengthAux.html">ElementLengthAux</a>Compute the element size using Elem::hmin() or Elem::hmax() from libMesh.</li><li class="collection-item"><a href="../../source/auxkernels/ElementLpNormAux.html">ElementLpNormAux</a>Compute an elemental field variable (single value per element) equal to the Lp-norm of a coupled Variable.</li><li class="collection-item"><a href="../../source/auxkernels/ElementQualityAux.html">ElementQualityAux</a>Generates a field containing the quality metric for each element.  Useful for visualizing mesh quality.</li><li class="collection-item"><a href="../../source/auxkernels/ElementUOAux.html">ElementUOAux</a>Aux Kernel to display generic spatial (elemental) information from a UserObject that satisfies the underlying ElementUOProvider interface.</li><li class="collection-item"><a href="../../source/auxkernels/ExtraElementIDAux.html">ExtraElementIDAux</a>Puts element extra IDs into an aux variable.</li><li class="collection-item"><a href="../../source/auxkernels/ForcingFunctionAux.html">ForcingFunctionAux</a>Auxiliary Kernel that adds a forcing function to the value of an AuxVariable from the previous time step.</li><li class="collection-item"><a href="../../source/auxkernels/FunctionArrayAux.html">FunctionArrayAux</a>Auxiliary Kernel that creates and updates an array field variable by sampling functions through space and time.</li><li class="collection-item"><a href="../../source/auxkernels/FunctionAux.html">FunctionAux</a>Auxiliary Kernel that creates and updates a field variable by sampling a function through space and time.</li><li class="collection-item"><a href="../../source/auxkernels/FunctorElementalAux.html">FunctorADMatPropElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="../../source/auxkernels/FunctorElementalAux.html">FunctorElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="../../source/auxkernels/FunctorElementalAux.html">FunctorMatPropElementalAux</a>Evaluates a functor (variable, function or functor material property) on the current element or quadrature point.</li><li class="collection-item"><a href="../../source/auxkernels/FunctorVectorElementalAux.html">FunctorVectorElementalAux</a>Evaluates a vector functor (material property usually) on the current element.For finite volume, this evaluates the vector functor at the centroid.</li><li class="collection-item"><a href="../../source/auxkernels/GapValueAux.html">GapValueAux</a>Return the nearest value of a variable on a boundary from across a gap.</li><li class="collection-item"><a href="../../source/auxkernels/GhostingAux.html">GhostingAux</a>Colors the elements ghosted to the chosen PID.</li><li class="collection-item"><a href="../../source/auxkernels/HardwareIDAux.html">HardwareIDAux</a>Creates a field showing the assignment of partitions to physical nodes in the cluster.</li><li class="collection-item"><a href="../../source/auxkernels/InterfaceValueUserObjectAux.html">InterfaceValueUserObjectAux</a>Get stored value from the specified InterfaceQpUserObjectBase.</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRankFourTensorAux.html">MaterialRankFourTensorAux</a>Access a component of a RankFourTensor for automatic material property output</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRankTwoTensorAux.html">MaterialRankTwoTensorAux</a>Access a component of a RankTwoTensor for automatic material property output</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealAux.html">MaterialRealAux</a>Outputs element volume-averaged material properties</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealDenseMatrixAux.html">MaterialRealDenseMatrixAux</a>Populate an auxiliary variable with an entry from a dense matrix material property.</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealTensorValueAux.html">MaterialRealTensorValueAux</a>Object for extracting a component of a rank two tensor material property to populate an auxiliary variable.</li><li class="collection-item"><a href="../../source/auxkernels/MaterialRealVectorValueAux.html">MaterialRealVectorValueAux</a>Capture a component of a vector material property in an auxiliary variable.</li><li class="collection-item"><a href="../../source/auxkernels/MaterialStdVectorAux.html">MaterialStdVectorAux</a>Extracts a component of a material type std::vector&lt;Real&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="../../source/auxkernels/MaterialStdVectorRealGradientAux.html">MaterialStdVectorRealGradientAux</a>Extracts a component of a material&#x27;s std::vector&lt;RealGradient&gt; to an aux variable.  If the std::vector is not of sufficient size then zero is returned</li><li class="collection-item"><a href="../../source/auxkernels/NearestNodeDistanceAux.html">NearestNodeDistanceAux</a>Stores the distance between a block and boundary or between two boundaries.</li><li class="collection-item"><a href="../../source/auxkernels/NearestNodeValueAux.html">NearestNodeValueAux</a>Retrieves a field value from the closest node on the paired boundary and stores it on this boundary or block.</li><li class="collection-item"><a href="../../source/auxkernels/NormalizationAux.html">NormalizationAux</a>Normalizes a variable based on a Postprocessor value.</li><li class="collection-item"><a href="../../source/auxkernels/ParsedAux.html">ParsedAux</a>Sets a field variable value to the evaluation of a parsed expression.</li><li class="collection-item"><a href="../../source/auxkernels/PenetrationAux.html">PenetrationAux</a>Auxiliary Kernel for computing several geometry related quantities between two contacting bodies.</li><li class="collection-item"><a href="../../source/auxkernels/ProcessorIDAux.html">ProcessorIDAux</a>Creates a field showing the processors and partitioning.</li><li class="collection-item"><a href="../../source/auxkernels/QuotientAux.html">QuotientAux</a>Divides two coupled variables.</li><li class="collection-item"><a href="../../source/auxkernels/SelfAux.html">SelfAux</a>Returns the specified variable as an auxiliary variable with the same value.</li><li class="collection-item"><a href="../../source/auxkernels/SolutionAux.html">SolutionAux</a>Creates fields by using information from a SolutionUserObject.</li><li class="collection-item"><a href="../../source/auxkernels/SpatialUserObjectAux.html">SpatialUserObjectAux</a>Populates an auxiliary variable with a spatial value returned from a UserObject spatialValue method.</li><li class="collection-item"><a href="../../source/auxkernels/TagMatrixAux.html">TagMatrixAux</a>Couple the diagonal of a tag matrix, and return its nodal value</li><li class="collection-item"><a href="../../source/auxkernels/TagVectorArrayVariableAux.html">TagVectorArrayVariableAux</a>Couple a tagged vector, and return its evaluations at degree of freedom indices corresponding to the coupled array variable.</li><li class="collection-item"><a href="../../source/auxkernels/TagVectorArrayVariableValueAux.html">TagVectorArrayVariableValueAux</a>Couple a tagged vector, and return its array value.</li><li class="collection-item"><a href="../../source/auxkernels/TagVectorAux.html">TagVectorAux</a>Couple a tag vector, and return its nodal value</li><li class="collection-item"><a href="../../source/auxkernels/TimeDerivativeAux.html">TimeDerivativeAux</a>Returns the time derivative of the specified variable/functor as an auxiliary variable.</li><li class="collection-item"><a href="../../source/auxkernels/VariableGradientComponent.html">VariableGradientComponent</a>Creates a field consisting of one component of the gradient of a coupled variable.</li><li class="collection-item"><a href="../../source/auxkernels/VariableOldValueBoundsAux.html">VariableOldValueBoundsAux</a>Provides the upper and lower bound of the phase field fracture variable to PETSc&#x27;s SNES variational inequalities solver.</li><li class="collection-item"><a href="../../source/auxkernels/VariableTimeIntegrationAux.html">VariableTimeIntegrationAux</a>Integrates a field variable in time.</li><li class="collection-item"><a href="../../source/auxkernels/VectorFunctionAux.html">VectorFunctionAux</a>Auxiliary Kernel that creates and updates a vector field variable by sampling a Function object, via the vectorValue method, through space and time.</li><li class="collection-item"><a href="../../source/auxkernels/VectorMagnitudeAux.html">VectorMagnitudeAux</a>Creates a field representing the magnitude of three coupled variables using an Euclidean norm.</li><li class="collection-item"><a href="../../source/auxkernels/VectorMaterialRealVectorValueAux.html">VectorMaterialRealVectorValueAux</a>Converts a vector-quantity material property into a vector auxiliary variable</li><li class="collection-item"><a href="../../source/auxkernels/VectorPostprocessorVisualizationAux.html">VectorPostprocessorVisualizationAux</a>Read values from a VectorPostprocessor that is producing vectors that are &#x27;number of processors&#x27; * in length.  Puts the value for each processor into an elemental auxiliary field.</li><li class="collection-item"><a href="../../source/auxkernels/VectorVariableComponentAux.html">VectorVariableComponentAux</a>Creates a field consisting of one component of a coupled vector variable.</li><li class="collection-item"><a href="../../source/auxkernels/VectorVariableMagnitudeAux.html">VectorVariableMagnitudeAux</a>Creates a field consisting of the magnitude of a coupled vector variable.</li><li class="collection-item"><a href="../../source/auxkernels/VolumeAux.html">VolumeAux</a>Auxiliary Kernel that samples volumes.</li><li class="collection-item"><a href="../../source/auxkernels/WeightedGapAux.html">WeightedGapAux</a>Returns the specified variable as an auxiliary variable with the same value.</li><li class="collection-header">Squirrel App</li><li class="collection-item">Density</li><li class="collection-item">FunctionDerivativeAux</li><li class="collection-header">Moltres App</li><li class="collection-item"><a href="../../source/auxkernels/ConstantDifferenceAux.html">ConstantDifferenceAux</a></li><li class="collection-item"><a href="../../source/auxkernels/FissionHeatSourceAux.html">FissionHeatSourceAux</a></li><li class="collection-item"><a href="../../source/auxkernels/FissionHeatSourceTransientAux.html">FissionHeatSourceTransientAux</a></li><li class="collection-item"><a href="../../source/auxkernels/MatDiffusionAux.html">MatDiffusionAux</a></li><li class="collection-item"><a href="../../source/auxkernels/ModeratorHeatSourceTransientAux.html">ModeratorHeatSourceTransientAux</a></li></ul></section><section class="scrollspy" id="19cadfa9-a1cb-4ff6-9fe5-745b7dccd8b9" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddKernelAction.html">AddKernelAction</a>Add a Kernel object to the simulation.</li></ul></section></section><div class="moose-modal modal" id="057c6d2f-c883-4b4a-a268-78163e1b06b9"><div class="modal-content"><h4>(moose/test/tests/auxkernels/vector_function_aux/vector_function_aux.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 2
  ny = 2
[]

[AuxVariables]
  [vec]
    family = LAGRANGE_VEC
    order = FIRST
  []
[]

[Variables]
  [u][]
[]

[Functions]
  [function]
    type = ParsedVectorFunction
    value_x = t*x
    value_y = t*y
  []
[]

[AuxKernels]
  [vec]
    type = VectorFunctionAux
    variable = vec
    function = function
    execute_on = &#x27;INITIAL TIMESTEP_END&#x27;
  [../]
[]

[Problem]
  type = FEProblem
  #solve = false
  kernel_coverage_check = false
[]

[Executioner]
  type = Transient
  start_time = 0.0
  num_steps = 5
  dt = 1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="be6a2641-d8f5-4c46-9951-00521b78e0a8"><div class="modal-content"><h4>(moose/framework/src/auxkernels/FunctionAux.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;FunctionAux.h&quot;
#include &quot;Function.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FunctionAux);

InputParameters
FunctionAux::validParams()
{
  InputParameters params = AuxKernel::validParams();
  params.addClassDescription(&quot;Auxiliary Kernel that creates and updates a field variable by &quot;
                             &quot;sampling a function through space and time.&quot;);
  params.addRequiredParam&lt;FunctionName&gt;(&quot;function&quot;, &quot;The function to use as the value&quot;);
  return params;
}

FunctionAux::FunctionAux(const InputParameters &amp; parameters)
  : AuxKernel(parameters), _func(getFunction(&quot;function&quot;))
{
}

Real
FunctionAux::computeValue()
{
  if (isNodal())
    return _func.value(_t, *_current_node);
  else
    return _func.value(_t, _q_point[_qp]);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="72a008e7-3604-4424-bf76-e1bbca15b8c3"><div class="modal-content"><h4>(moose/tutorials/darcy_thermo_mech/step04_velocity_aux/include/auxkernels/DarcyVelocity.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;AuxKernel.h&quot;

/**
 * Auxiliary kernel responsible for computing the Darcy velocity given
 * several fluid properties and the pressure gradient.
 */
class DarcyVelocity : public VectorAuxKernel
{
public:
  static InputParameters validParams();

  DarcyVelocity(const InputParameters &amp; parameters);

protected:
  /**
   * AuxKernels MUST override computeValue.  computeValue() is called on
   * every quadrature point.  For Nodal Auxiliary variables those quadrature
   * points coincide with the nodes.
   */
  virtual RealVectorValue computeValue() override;

  /// The gradient of a coupled variable
  const VariableGradient &amp; _pressure_gradient;

  /// Holds the permeability and viscosity from the material system
  const ADMaterialProperty&lt;Real&gt; &amp; _permeability;
  const ADMaterialProperty&lt;Real&gt; &amp; _viscosity;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="daaf05c0-3ac7-4520-a9a4-e68b58284583"><div class="modal-content"><h4>(moose/tutorials/darcy_thermo_mech/step04_velocity_aux/src/auxkernels/DarcyVelocity.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;DarcyVelocity.h&quot;

#include &quot;metaphysicl/raw_type.h&quot;

registerMooseObject(&quot;DarcyThermoMechApp&quot;, DarcyVelocity);

InputParameters
DarcyVelocity::validParams()
{
  InputParameters params = VectorAuxKernel::validParams();

  // Add a &quot;coupling paramater&quot; to get a variable from the input file.
  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The pressure field.&quot;);

  return params;
}

DarcyVelocity::DarcyVelocity(const InputParameters &amp; parameters)
  : VectorAuxKernel(parameters),

    // Get the gradient of the variable
    _pressure_gradient(coupledGradient(&quot;pressure&quot;)),

    // Set reference to the permeability MaterialProperty.
    // Only AuxKernels operating on Elemental Auxiliary Variables can do this
    _permeability(getADMaterialProperty&lt;Real&gt;(&quot;permeability&quot;)),

    // Set reference to the viscosity MaterialProperty.
    // Only AuxKernels operating on Elemental Auxiliary Variables can do this
    _viscosity(getADMaterialProperty&lt;Real&gt;(&quot;viscosity&quot;))
{
}

RealVectorValue
DarcyVelocity::computeValue()
{
  // Access the gradient of the pressure at this quadrature point, then pull out the &quot;component&quot; of
  // it requested (x, y or z). Note, that getting a particular component of a gradient is done using
  // the parenthesis operator.
  return -MetaPhysicL::raw_value(_permeability[_qp] / _viscosity[_qp]) * _pressure_gradient[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="3d51ca6d-711c-4ae1-bef2-c69f11819c20"><div class="modal-content"><h4>(moose/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/kernels/DarcyAdvection.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;DarcyAdvection.h&quot;

registerMooseObject(&quot;DarcyThermoMechApp&quot;, DarcyAdvection);

InputParameters
DarcyAdvection::validParams()
{
  InputParameters params = ADKernelValue::validParams();
  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The variable representing the pressure.&quot;);
  return params;
}

DarcyAdvection::DarcyAdvection(const InputParameters &amp; parameters)
  : ADKernelValue(parameters),
    // Couple to the gradient of the pressure
    _pressure_grad(adCoupledGradient(&quot;pressure&quot;)),
    // Grab necessary material properties
    _permeability(getADMaterialProperty&lt;Real&gt;(&quot;permeability&quot;)),
    _porosity(getADMaterialProperty&lt;Real&gt;(&quot;porosity&quot;)),
    _viscosity(getADMaterialProperty&lt;Real&gt;(&quot;viscosity&quot;)),
    _density(getADMaterialProperty&lt;Real&gt;(&quot;density&quot;)),
    _specific_heat(getADMaterialProperty&lt;Real&gt;(&quot;specific_heat&quot;))
{
}

ADReal
DarcyAdvection::precomputeQpResidual()
{
  // See also: E. Majchrzak and L. Turchan, &quot;The Finite Difference
  // Method For Transient Convection Diffusion&quot;, Scientific Research
  // of the Institute of Mathematics and Computer Science, vol. 1,
  // no. 11, 2012, pp. 63-72.
  // http://srimcs.im.pcz.pl/2012_1/art_07.pdf

  // http://en.wikipedia.org/wiki/Superficial_velocity
  ADRealVectorValue superficial_velocity =
      _porosity[_qp] * -(_permeability[_qp] / _viscosity[_qp]) * _pressure_grad[_qp];

  return _density[_qp] * _specific_heat[_qp] * superficial_velocity * _grad_u[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="be1f4391-284c-4c59-ae72-8822a97ed296"><div class="modal-content"><h4>(moose/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/kernels/DarcyAdvection.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;DarcyAdvection.h&quot;

registerMooseObject(&quot;DarcyThermoMechApp&quot;, DarcyAdvection);

InputParameters
DarcyAdvection::validParams()
{
  InputParameters params = ADKernelValue::validParams();
  params.addRequiredCoupledVar(&quot;pressure&quot;, &quot;The variable representing the pressure.&quot;);
  return params;
}

DarcyAdvection::DarcyAdvection(const InputParameters &amp; parameters)
  : ADKernelValue(parameters),
    // Couple to the gradient of the pressure
    _pressure_grad(adCoupledGradient(&quot;pressure&quot;)),
    // Grab necessary material properties
    _permeability(getADMaterialProperty&lt;Real&gt;(&quot;permeability&quot;)),
    _porosity(getADMaterialProperty&lt;Real&gt;(&quot;porosity&quot;)),
    _viscosity(getADMaterialProperty&lt;Real&gt;(&quot;viscosity&quot;)),
    _density(getADMaterialProperty&lt;Real&gt;(&quot;density&quot;)),
    _specific_heat(getADMaterialProperty&lt;Real&gt;(&quot;specific_heat&quot;))
{
}

ADReal
DarcyAdvection::precomputeQpResidual()
{
  // See also: E. Majchrzak and L. Turchan, &quot;The Finite Difference
  // Method For Transient Convection Diffusion&quot;, Scientific Research
  // of the Institute of Mathematics and Computer Science, vol. 1,
  // no. 11, 2012, pp. 63-72.
  // http://srimcs.im.pcz.pl/2012_1/art_07.pdf

  // http://en.wikipedia.org/wiki/Superficial_velocity
  ADRealVectorValue superficial_velocity =
      _porosity[_qp] * -(_permeability[_qp] / _viscosity[_qp]) * _pressure_grad[_qp];

  return _density[_qp] * _specific_heat[_qp] * superficial_velocity * _grad_u[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="df43128c-03e9-4d87-a532-909cd2db3f85"><div class="modal-content"><h4>(moose/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/problems/step6c_decoupled.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [gmg]
    type = GeneratedMeshGenerator
    dim = 2
    nx = 200
    ny = 10
    xmax = 0.304 # Length of test chamber
    ymax = 0.0257 # Test chamber radius
  []
[]

[Variables]
  [temperature]
    initial_condition = 300 # Start at room temperature
  []
[]

[AuxVariables]
  [pressure]
  []
[]

[AuxKernels]
  [pressure]
    type = FunctionAux
    variable = pressure
    function = &#x27;t*x*x*y&#x27;
    execute_on = timestep_end
  []
[]

[Kernels]
  [heat_conduction]
    type = ADHeatConduction
    variable = temperature
  []
  [heat_conduction_time_derivative]
    type = ADHeatConductionTimeDerivative
    variable = temperature
  []
  [heat_convection]
    type = DarcyAdvection
    variable = temperature
    pressure = pressure
  []
[]

[BCs]
  [inlet_temperature]
    type = DirichletBC
    variable = temperature
    boundary = left
    value = 350
  []
  [outlet_temperature]
    type = HeatConductionOutflow
    variable = temperature
    boundary = right
  []
[]

[Materials]
  [column]
    type = PackedColumn
    radius = 1
    temperature = 293.15 # 20C
  []
[]

[Problem]
  type = FEProblem
  coord_type = RZ
  rz_coord_axis = X
[]

[Executioner]
  type = Transient
  num_steps = 300
  dt = 0.1
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#43061287-d3ce-4fe4-bd10-5ddb70da06e2" class="tooltipped" data-position="left" data-tooltip="Nodal vs Elemental AuxKernel Objects">Nodal vs Elemental AuxKernel Objects</a></li><li><a href="#bd491f57-8644-4644-b77b-e5f38c298f11" class="tooltipped" data-position="left" data-tooltip="Block vs Boundary Restricted AuxKernel Objects">Block vs Boundary Restricted AuxKernel Objects</a></li><li><a href="#982ceb48-defa-4f1b-b591-dbdb9b1b1d20" class="tooltipped" data-position="left" data-tooltip="Mortar Nodal Auxiliary Kernel Objects">Mortar Nodal Auxiliary Kernel Objects</a></li><li><a href="#8dba49fb-9c20-49b4-a2fd-87c90935276a" class="tooltipped" data-position="left" data-tooltip="Example A : Post processing with AuxKernel">Example A : Post processing with AuxKernel</a></li><li><a href="#923dae85-a575-4002-bd81-10c6c03b641f" class="tooltipped" data-position="left" data-tooltip="Example B : Decoupling Equations">Example B : Decoupling Equations</a></li><li><a href="#09eb7a8c-583d-48d4-be1d-b6b19a34fe4c" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#19cadfa9-a1cb-4ff6-9fe5-745b7dccd8b9" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>